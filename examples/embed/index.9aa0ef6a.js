// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function (modules, entry, mainEntry, parcelRequireName, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject[parcelRequireName] === 'function' &&
    globalObject[parcelRequireName];

  var cache = previousRequire.cache || {};
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof globalObject[parcelRequireName] === 'function' &&
          globalObject[parcelRequireName];
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      var res = localRequire.resolve(x);
      return res === false ? {} : newRequire(res);
    }

    function resolve(x) {
      var id = modules[name][1][x];
      return id != null ? id : x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [
      function (require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  Object.defineProperty(newRequire, 'root', {
    get: function () {
      return globalObject[parcelRequireName];
    },
  });

  globalObject[parcelRequireName] = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (mainEntry) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(mainEntry);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function () {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"4yoxy":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = null;
var HMR_SECURE = false;
var HMR_ENV_HASH = "d6ea1d42532a7575";
module.bundle.HMR_BUNDLE_ID = "9808432d9aa0ef6a";
"use strict";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH, HMR_SECURE, chrome, browser, __parcel__import__, __parcel__importScripts__, ServiceWorkerGlobalScope */ /*::
import type {
  HMRAsset,
  HMRMessage,
} from '@parcel/reporter-dev-server/src/HMRServer.js';
interface ParcelRequire {
  (string): mixed;
  cache: {|[string]: ParcelModule|};
  hotData: {|[string]: mixed|};
  Module: any;
  parent: ?ParcelRequire;
  isParcelRequire: true;
  modules: {|[string]: [Function, {|[string]: string|}]|};
  HMR_BUNDLE_ID: string;
  root: ParcelRequire;
}
interface ParcelModule {
  hot: {|
    data: mixed,
    accept(cb: (Function) => void): void,
    dispose(cb: (mixed) => void): void,
    // accept(deps: Array<string> | string, cb: (Function) => void): void,
    // decline(): void,
    _acceptCallbacks: Array<(Function) => void>,
    _disposeCallbacks: Array<(mixed) => void>,
  |};
}
interface ExtensionContext {
  runtime: {|
    reload(): void,
    getURL(url: string): string;
    getManifest(): {manifest_version: number, ...};
  |};
}
declare var module: {bundle: ParcelRequire, ...};
declare var HMR_HOST: string;
declare var HMR_PORT: string;
declare var HMR_ENV_HASH: string;
declare var HMR_SECURE: boolean;
declare var chrome: ExtensionContext;
declare var browser: ExtensionContext;
declare var __parcel__import__: (string) => Promise<void>;
declare var __parcel__importScripts__: (string) => Promise<void>;
declare var globalThis: typeof self;
declare var ServiceWorkerGlobalScope: Object;
*/ var OVERLAY_ID = "__parcel__error__overlay__";
var OldModule = module.bundle.Module;
function Module(moduleName) {
    OldModule.call(this, moduleName);
    this.hot = {
        data: module.bundle.hotData[moduleName],
        _acceptCallbacks: [],
        _disposeCallbacks: [],
        accept: function(fn) {
            this._acceptCallbacks.push(fn || function() {});
        },
        dispose: function(fn) {
            this._disposeCallbacks.push(fn);
        }
    };
    module.bundle.hotData[moduleName] = undefined;
}
module.bundle.Module = Module;
module.bundle.hotData = {};
var checkedAssets /*: {|[string]: boolean|} */ , assetsToDispose /*: Array<[ParcelRequire, string]> */ , assetsToAccept /*: Array<[ParcelRequire, string]> */ ;
function getHostname() {
    return HMR_HOST || (location.protocol.indexOf("http") === 0 ? location.hostname : "localhost");
}
function getPort() {
    return HMR_PORT || location.port;
}
// eslint-disable-next-line no-redeclare
var parent = module.bundle.parent;
if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== "undefined") {
    var hostname = getHostname();
    var port = getPort();
    var protocol = HMR_SECURE || location.protocol == "https:" && !/localhost|127.0.0.1|0.0.0.0/.test(hostname) ? "wss" : "ws";
    var ws = new WebSocket(protocol + "://" + hostname + (port ? ":" + port : "") + "/");
    // Web extension context
    var extCtx = typeof chrome === "undefined" ? typeof browser === "undefined" ? null : browser : chrome;
    // Safari doesn't support sourceURL in error stacks.
    // eval may also be disabled via CSP, so do a quick check.
    var supportsSourceURL = false;
    try {
        (0, eval)('throw new Error("test"); //# sourceURL=test.js');
    } catch (err) {
        supportsSourceURL = err.stack.includes("test.js");
    }
    // $FlowFixMe
    ws.onmessage = async function(event /*: {data: string, ...} */ ) {
        checkedAssets = {} /*: {|[string]: boolean|} */ ;
        assetsToAccept = [];
        assetsToDispose = [];
        var data /*: HMRMessage */  = JSON.parse(event.data);
        if (data.type === "update") {
            // Remove error overlay if there is one
            if (typeof document !== "undefined") removeErrorOverlay();
            let assets = data.assets.filter((asset)=>asset.envHash === HMR_ENV_HASH);
            // Handle HMR Update
            let handled = assets.every((asset)=>{
                return asset.type === "css" || asset.type === "js" && hmrAcceptCheck(module.bundle.root, asset.id, asset.depsByBundle);
            });
            if (handled) {
                console.clear();
                // Dispatch custom event so other runtimes (e.g React Refresh) are aware.
                if (typeof window !== "undefined" && typeof CustomEvent !== "undefined") window.dispatchEvent(new CustomEvent("parcelhmraccept"));
                await hmrApplyUpdates(assets);
                // Dispose all old assets.
                let processedAssets = {} /*: {|[string]: boolean|} */ ;
                for(let i = 0; i < assetsToDispose.length; i++){
                    let id = assetsToDispose[i][1];
                    if (!processedAssets[id]) {
                        hmrDispose(assetsToDispose[i][0], id);
                        processedAssets[id] = true;
                    }
                }
                // Run accept callbacks. This will also re-execute other disposed assets in topological order.
                processedAssets = {};
                for(let i = 0; i < assetsToAccept.length; i++){
                    let id = assetsToAccept[i][1];
                    if (!processedAssets[id]) {
                        hmrAccept(assetsToAccept[i][0], id);
                        processedAssets[id] = true;
                    }
                }
            } else fullReload();
        }
        if (data.type === "error") {
            // Log parcel errors to console
            for (let ansiDiagnostic of data.diagnostics.ansi){
                let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
                console.error("\uD83D\uDEA8 [parcel]: " + ansiDiagnostic.message + "\n" + stack + "\n\n" + ansiDiagnostic.hints.join("\n"));
            }
            if (typeof document !== "undefined") {
                // Render the fancy html overlay
                removeErrorOverlay();
                var overlay = createErrorOverlay(data.diagnostics.html);
                // $FlowFixMe
                document.body.appendChild(overlay);
            }
        }
    };
    ws.onerror = function(e) {
        console.error(e.message);
    };
    ws.onclose = function() {
        console.warn("[parcel] \uD83D\uDEA8 Connection to the HMR server was lost");
    };
}
function removeErrorOverlay() {
    var overlay = document.getElementById(OVERLAY_ID);
    if (overlay) {
        overlay.remove();
        console.log("[parcel] ✨ Error resolved");
    }
}
function createErrorOverlay(diagnostics) {
    var overlay = document.createElement("div");
    overlay.id = OVERLAY_ID;
    let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';
    for (let diagnostic of diagnostics){
        let stack = diagnostic.frames.length ? diagnostic.frames.reduce((p, frame)=>{
            return `${p}
<a href="/__parcel_launch_editor?file=${encodeURIComponent(frame.location)}" style="text-decoration: underline; color: #888" onclick="fetch(this.href); return false">${frame.location}</a>
${frame.code}`;
        }, "") : diagnostic.stack;
        errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          🚨 ${diagnostic.message}
        </div>
        <pre>${stack}</pre>
        <div>
          ${diagnostic.hints.map((hint)=>"<div>\uD83D\uDCA1 " + hint + "</div>").join("")}
        </div>
        ${diagnostic.documentation ? `<div>📝 <a style="color: violet" href="${diagnostic.documentation}" target="_blank">Learn more</a></div>` : ""}
      </div>
    `;
    }
    errorHTML += "</div>";
    overlay.innerHTML = errorHTML;
    return overlay;
}
function fullReload() {
    if ("reload" in location) location.reload();
    else if (extCtx && extCtx.runtime && extCtx.runtime.reload) extCtx.runtime.reload();
}
function getParents(bundle, id) /*: Array<[ParcelRequire, string]> */ {
    var modules = bundle.modules;
    if (!modules) return [];
    var parents = [];
    var k, d, dep;
    for(k in modules)for(d in modules[k][1]){
        dep = modules[k][1][d];
        if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) parents.push([
            bundle,
            k
        ]);
    }
    if (bundle.parent) parents = parents.concat(getParents(bundle.parent, id));
    return parents;
}
function updateLink(link) {
    var href = link.getAttribute("href");
    if (!href) return;
    var newLink = link.cloneNode();
    newLink.onload = function() {
        if (link.parentNode !== null) // $FlowFixMe
        link.parentNode.removeChild(link);
    };
    newLink.setAttribute("href", // $FlowFixMe
    href.split("?")[0] + "?" + Date.now());
    // $FlowFixMe
    link.parentNode.insertBefore(newLink, link.nextSibling);
}
var cssTimeout = null;
function reloadCSS() {
    if (cssTimeout) return;
    cssTimeout = setTimeout(function() {
        var links = document.querySelectorAll('link[rel="stylesheet"]');
        for(var i = 0; i < links.length; i++){
            // $FlowFixMe[incompatible-type]
            var href /*: string */  = links[i].getAttribute("href");
            var hostname = getHostname();
            var servedFromHMRServer = hostname === "localhost" ? new RegExp("^(https?:\\/\\/(0.0.0.0|127.0.0.1)|localhost):" + getPort()).test(href) : href.indexOf(hostname + ":" + getPort());
            var absolute = /^https?:\/\//i.test(href) && href.indexOf(location.origin) !== 0 && !servedFromHMRServer;
            if (!absolute) updateLink(links[i]);
        }
        cssTimeout = null;
    }, 50);
}
function hmrDownload(asset) {
    if (asset.type === "js") {
        if (typeof document !== "undefined") {
            let script = document.createElement("script");
            script.src = asset.url + "?t=" + Date.now();
            if (asset.outputFormat === "esmodule") script.type = "module";
            return new Promise((resolve, reject)=>{
                var _document$head;
                script.onload = ()=>resolve(script);
                script.onerror = reject;
                (_document$head = document.head) === null || _document$head === void 0 || _document$head.appendChild(script);
            });
        } else if (typeof importScripts === "function") {
            // Worker scripts
            if (asset.outputFormat === "esmodule") return import(asset.url + "?t=" + Date.now());
            else return new Promise((resolve, reject)=>{
                try {
                    importScripts(asset.url + "?t=" + Date.now());
                    resolve();
                } catch (err) {
                    reject(err);
                }
            });
        }
    }
}
async function hmrApplyUpdates(assets) {
    global.parcelHotUpdate = Object.create(null);
    let scriptsToRemove;
    try {
        // If sourceURL comments aren't supported in eval, we need to load
        // the update from the dev server over HTTP so that stack traces
        // are correct in errors/logs. This is much slower than eval, so
        // we only do it if needed (currently just Safari).
        // https://bugs.webkit.org/show_bug.cgi?id=137297
        // This path is also taken if a CSP disallows eval.
        if (!supportsSourceURL) {
            let promises = assets.map((asset)=>{
                var _hmrDownload;
                return (_hmrDownload = hmrDownload(asset)) === null || _hmrDownload === void 0 ? void 0 : _hmrDownload.catch((err)=>{
                    // Web extension bugfix for Chromium
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=1255412#c12
                    if (extCtx && extCtx.runtime && extCtx.runtime.getManifest().manifest_version == 3) {
                        if (typeof ServiceWorkerGlobalScope != "undefined" && global instanceof ServiceWorkerGlobalScope) {
                            extCtx.runtime.reload();
                            return;
                        }
                        asset.url = extCtx.runtime.getURL("/__parcel_hmr_proxy__?url=" + encodeURIComponent(asset.url + "?t=" + Date.now()));
                        return hmrDownload(asset);
                    }
                    throw err;
                });
            });
            scriptsToRemove = await Promise.all(promises);
        }
        assets.forEach(function(asset) {
            hmrApply(module.bundle.root, asset);
        });
    } finally{
        delete global.parcelHotUpdate;
        if (scriptsToRemove) scriptsToRemove.forEach((script)=>{
            if (script) {
                var _document$head2;
                (_document$head2 = document.head) === null || _document$head2 === void 0 || _document$head2.removeChild(script);
            }
        });
    }
}
function hmrApply(bundle /*: ParcelRequire */ , asset /*:  HMRAsset */ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (asset.type === "css") reloadCSS();
    else if (asset.type === "js") {
        let deps = asset.depsByBundle[bundle.HMR_BUNDLE_ID];
        if (deps) {
            if (modules[asset.id]) {
                // Remove dependencies that are removed and will become orphaned.
                // This is necessary so that if the asset is added back again, the cache is gone, and we prevent a full page reload.
                let oldDeps = modules[asset.id][1];
                for(let dep in oldDeps)if (!deps[dep] || deps[dep] !== oldDeps[dep]) {
                    let id = oldDeps[dep];
                    let parents = getParents(module.bundle.root, id);
                    if (parents.length === 1) hmrDelete(module.bundle.root, id);
                }
            }
            if (supportsSourceURL) // Global eval. We would use `new Function` here but browser
            // support for source maps is better with eval.
            (0, eval)(asset.output);
            // $FlowFixMe
            let fn = global.parcelHotUpdate[asset.id];
            modules[asset.id] = [
                fn,
                deps
            ];
        } else if (bundle.parent) hmrApply(bundle.parent, asset);
    }
}
function hmrDelete(bundle, id) {
    let modules = bundle.modules;
    if (!modules) return;
    if (modules[id]) {
        // Collect dependencies that will become orphaned when this module is deleted.
        let deps = modules[id][1];
        let orphans = [];
        for(let dep in deps){
            let parents = getParents(module.bundle.root, deps[dep]);
            if (parents.length === 1) orphans.push(deps[dep]);
        }
        // Delete the module. This must be done before deleting dependencies in case of circular dependencies.
        delete modules[id];
        delete bundle.cache[id];
        // Now delete the orphans.
        orphans.forEach((id)=>{
            hmrDelete(module.bundle.root, id);
        });
    } else if (bundle.parent) hmrDelete(bundle.parent, id);
}
function hmrAcceptCheck(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    if (hmrAcceptCheckOne(bundle, id, depsByBundle)) return true;
    // Traverse parents breadth first. All possible ancestries must accept the HMR update, or we'll reload.
    let parents = getParents(module.bundle.root, id);
    let accepted = false;
    while(parents.length > 0){
        let v = parents.shift();
        let a = hmrAcceptCheckOne(v[0], v[1], null);
        if (a) // If this parent accepts, stop traversing upward, but still consider siblings.
        accepted = true;
        else {
            // Otherwise, queue the parents in the next level upward.
            let p = getParents(module.bundle.root, v[1]);
            if (p.length === 0) {
                // If there are no parents, then we've reached an entry without accepting. Reload.
                accepted = false;
                break;
            }
            parents.push(...p);
        }
    }
    return accepted;
}
function hmrAcceptCheckOne(bundle /*: ParcelRequire */ , id /*: string */ , depsByBundle /*: ?{ [string]: { [string]: string } }*/ ) {
    var modules = bundle.modules;
    if (!modules) return;
    if (depsByBundle && !depsByBundle[bundle.HMR_BUNDLE_ID]) {
        // If we reached the root bundle without finding where the asset should go,
        // there's nothing to do. Mark as "accepted" so we don't reload the page.
        if (!bundle.parent) return true;
        return hmrAcceptCheck(bundle.parent, id, depsByBundle);
    }
    if (checkedAssets[id]) return true;
    checkedAssets[id] = true;
    var cached = bundle.cache[id];
    assetsToDispose.push([
        bundle,
        id
    ]);
    if (!cached || cached.hot && cached.hot._acceptCallbacks.length) {
        assetsToAccept.push([
            bundle,
            id
        ]);
        return true;
    }
}
function hmrDispose(bundle /*: ParcelRequire */ , id /*: string */ ) {
    var cached = bundle.cache[id];
    bundle.hotData[id] = {};
    if (cached && cached.hot) cached.hot.data = bundle.hotData[id];
    if (cached && cached.hot && cached.hot._disposeCallbacks.length) cached.hot._disposeCallbacks.forEach(function(cb) {
        cb(bundle.hotData[id]);
    });
    delete bundle.cache[id];
}
function hmrAccept(bundle /*: ParcelRequire */ , id /*: string */ ) {
    // Execute the module.
    bundle(id);
    // Run the accept callbacks in the new version of the module.
    var cached = bundle.cache[id];
    if (cached && cached.hot && cached.hot._acceptCallbacks.length) cached.hot._acceptCallbacks.forEach(function(cb) {
        var assetsToAlsoAccept = cb(function() {
            return getParents(module.bundle.root, id);
        });
        if (assetsToAlsoAccept && assetsToAccept.length) {
            assetsToAlsoAccept.forEach(function(a) {
                hmrDispose(a[0], a[1]);
            });
            // $FlowFixMe[method-unbinding]
            assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
        }
    });
}

},{}],"c1sIO":[function(require,module,exports) {
/**
 * by bitbof (bitbof.com)
 */ var _polyfills = require("./polyfills/polyfills");
var _kl = require("./klecks/kl");
var _klHistory = require("./klecks/history/kl-history");
var _klApp = require("./app/kl-app");
var _language = require("./language/language");
var _theme = require("../script/theme/theme");
function initError(e) {
    const el = document.createElement("div");
    el.style.textAlign = "center";
    el.style.background = "#fff";
    el.style.padding = "20px";
    el.innerHTML = "<h1>App failed to initialize</h1>";
    const errorMsg = document.createElement("div");
    errorMsg.textContent = "Error: " + (e.message ? e.message : "" + e);
    el.append(errorMsg);
    document.body.append(el);
    console.error(e);
}
(async ()=>{
    let klApp;
    let domIsLoaded = false;
    try {
        window.addEventListener("DOMContentLoaded", ()=>{
            domIsLoaded = true;
        });
        await (0, _language.initLANG)();
    } catch (e) {
        initError(e);
        return;
    }
    function onProjectLoaded(project, projectStore) {
        if (klApp) throw "onKlProjectObjLoaded called more than once";
        // in case an extension manipulated the page
        const loadingScreenEl = document.getElementById("loading-screen");
        loadingScreenEl?.remove();
        const saveReminder = new (0, _kl.KL).SaveReminder((0, _klHistory.klHistory), true, true, ()=>klApp.saveAsPsd(), ()=>{
            return klApp ? klApp.isDrawing() : false;
        }, null, null);
        klApp = new (0, _klApp.KlApp)(project, {
            saveReminder,
            projectStore
        });
        saveReminder.init();
        if (project) setTimeout(()=>{
            klApp.out((0, _language.LANG)("file-storage-restored"));
        }, 100);
        document.body.append(klApp.getEl());
    }
    async function onDomLoaded() {
        try {
            window.removeEventListener("DOMContentLoaded", onDomLoaded);
            const projectStore = new (0, _kl.KL).ProjectStore();
            let project = null;
            try {
                const readResult = await projectStore.read();
                if (readResult) project = readResult.project;
            } catch (e) {
                let message;
                if (e.message.indexOf("db-error") === 0) message = "Failed to access Browser Storage";
                else if (e.message.indexOf("format-error") === 0) message = "Failed to restore from Browser Storage";
                else message = "Failed to restore from Browser Storage";
                if (message) setTimeout(function() {
                    klApp && klApp.out(message);
                    throw new Error("Initial browser storage error, " + e);
                }, 100);
            }
            onProjectLoaded(project, projectStore);
        } catch (e) {
            initError(e);
        }
    }
    if (domIsLoaded) onDomLoaded();
    else window.addEventListener("DOMContentLoaded", onDomLoaded);
})();

},{"./polyfills/polyfills":"eklaz","./klecks/kl":"8nmWp","./klecks/history/kl-history":"klzEn","./app/kl-app":"1tywk","./language/language":"iiYGN","../script/theme/theme":"4G3JB"}],"eklaz":[function(require,module,exports) {
var _polyfillsNomodule = require("./polyfills-nomodule");
/*
 * ---- Below ----------------------
 * features that didn't have support until *after* browsers supported the modules script tag:
 * Chrome 61
 * Edge 16
 * Safari 11
 * Firefox 60
 * https://caniuse.com/es6-module
 */ // chrome 61, edge 79, safari 16, firefox 107
if (!("scrollTo" in Element.prototype)) Object.defineProperty(Element.prototype, "scrollTo", {
    value: function(x, y) {
        this.scrollLeft = x;
        this.scrollTop = y;
    }
});
// chrome 61, edge 79, safari 16, firefox 107
if (!("scrollBy" in Element.prototype)) Object.defineProperty(Element.prototype, "scrollBy", {
    value: function(x, y) {
        this.scrollLeft += x;
        this.scrollTop += y;
    }
});
// chrome 69, edge 79, safari 12, firefox 62
if (!Array.prototype.flat) Object.defineProperty(Array.prototype, "flat", {
    configurable: true,
    value: function flat(...args) {
        const depth = isNaN(args[0]) ? 1 : Number(args[0]);
        return depth ? Array.prototype.reduce.call(this, function(acc, cur) {
            if (Array.isArray(cur)) // eslint-disable-next-line prefer-spread
            acc.push.apply(acc, flat.call(cur, depth - 1));
            else acc.push(cur);
            return acc;
        }, []) : Array.prototype.slice.call(this);
    },
    writable: true
});
// Chrome 85, Firefox 77, Safari 13.1
// if there are problems, maybe use core-js
if (!String.prototype.replaceAll) Object.defineProperty(String.prototype, "replaceAll", {
    value: function(searchValue, replaceValue) {
        if (typeof replaceValue === "function") throw new Error("replaceAll polyfill does not support replaceValue: function");
        return this.replace(new RegExp(searchValue, "g"), replaceValue);
    }
});
/*
    Copyright 2018  Alfredo Mungo <alfredo.mungo@protonmail.ch>

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to
    deal in the Software without restriction, including without limitation the
    rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
    sell copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
    IN THE SOFTWARE.
*/ if (!Object.fromEntries) Object.defineProperty(Object, "fromEntries", {
    value (entries) {
        if (!entries || !entries[Symbol.iterator]) throw new Error("Object.fromEntries() requires a single iterable argument");
        const o = {};
        Object.keys(entries).forEach((key)=>{
            const [k, v] = entries[key];
            o[k] = v;
        });
        return o;
    }
});
// sometimes Android WebView has no localStorage
if (!("localStorage" in window)) try {
    window.localStorage = {
        getItem: ()=>null,
        setItem: ()=>{},
        removeItem: ()=>{}
    };
} catch (e) {
// maybe it fails?
}

},{"./polyfills-nomodule":"bKz6p"}],"bKz6p":[function(require,module,exports) {
/**
 * features that were available before module script tags:
 * chrome 61
 * edge 16
 * safari 11
 * firefox 60
 * https://caniuse.com/es6-module
 */ var _nodePrototypeAppend = require("mdn-polyfills/Node.prototype.append");
var _nodePrototypePrepend = require("mdn-polyfills/Node.prototype.prepend"); // edge 17 (one version after module)
var _stringPrototypePadStart = require("mdn-polyfills/String.prototype.padStart");
var _arrayPrototypeFindIndex = require("mdn-polyfills/Array.prototype.findIndex");

},{"mdn-polyfills/Node.prototype.append":"L3T5Q","mdn-polyfills/Node.prototype.prepend":"88hN8","mdn-polyfills/String.prototype.padStart":"1K2W5","mdn-polyfills/Array.prototype.findIndex":"cbNyr"}],"L3T5Q":[function(require,module,exports) {
!function() {
    function t() {
        var e = Array.prototype.slice.call(arguments), n = document.createDocumentFragment();
        e.forEach(function(e) {
            var t = e instanceof Node;
            n.appendChild(t ? e : document.createTextNode(String(e)));
        }), this.appendChild(n);
    }
    [
        Element.prototype,
        Document.prototype,
        DocumentFragment.prototype
    ].forEach(function(e) {
        e.hasOwnProperty("append") || Object.defineProperty(e, "append", {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: t
        });
    });
}();

},{}],"88hN8":[function(require,module,exports) {
!function() {
    function t() {
        var e = Array.prototype.slice.call(arguments), n = document.createDocumentFragment();
        e.forEach(function(e) {
            var t = e instanceof Node;
            n.appendChild(t ? e : document.createTextNode(String(e)));
        }), this.insertBefore(n, this.firstChild);
    }
    [
        Element.prototype,
        Document.prototype,
        DocumentFragment.prototype
    ].forEach(function(e) {
        e.hasOwnProperty("prepend") || Object.defineProperty(e, "prepend", {
            configurable: !0,
            enumerable: !0,
            writable: !0,
            value: t
        });
    });
}();

},{}],"1K2W5":[function(require,module,exports) {
String.prototype.padStart || (String.prototype.padStart = function(t, n) {
    return t >>= 0, n = String(n || " "), this.length > t ? String(this) : ((t -= this.length) > n.length && (n += n.repeat(t / n.length)), n.slice(0, t) + String(this));
});

},{}],"cbNyr":[function(require,module,exports) {
Array.prototype.findIndex || Object.defineProperty(Array.prototype, "findIndex", {
    value: function(r) {
        if (null == this) throw new TypeError('"this" is null or not defined');
        var e = Object(this), t = e.length >>> 0;
        if ("function" != typeof r) throw new TypeError("predicate must be a function");
        for(var n = arguments[1], o = 0; o < t;){
            var i = e[o];
            if (r.call(n, i, o, e)) return o;
            o++;
        }
        return -1;
    }
});

},{}],"8nmWp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KL", ()=>KL);
var _klHistory = require("./history/kl-history");
var _showModal = require("./ui/modals/base/showModal");
var _dynamicModal = require("./ui/modals/base/dynamic-modal");
var _modalCount = require("./ui/modals/modal-count");
var _checkbox = require("./ui/components/checkbox");
var _input = require("./ui/components/input");
var _select = require("./ui/components/select");
var _imageToggle = require("./ui/components/image-toggle");
var _imageRadioList = require("./ui/components/image-radio-list");
var _createPenPressureToggle = require("./ui/components/create-pen-pressure-toggle");
var _klSlider = require("./ui/components/kl-slider");
var _sliderFalloff = require("./ui/components/slider-falloff");
var _colorSliderHexDialog = require("./ui/modals/color-slider-hex-dialog");
var _klColorSlider = require("./ui/components/kl-color-slider");
var _klColorSliderSmall = require("./ui/components/kl-color-slider-small");
var _pointSlider = require("./ui/components/point-slider");
var _colorOptions = require("./ui/components/color-options");
var _options = require("./ui/components/options");
var _statusOverlay = require("./ui/components/status-overlay");
var _cropCopy = require("./ui/components/crop-copy");
var _clipboardDialog = require("./ui/modals/clipboard-dialog");
var _layerManager = require("./ui/tool-tabs/layer-manager/layer-manager");
var _workspaceSvgOverlay = require("./canvas-ui/workspace-svg-overlay");
var _klCanvasWorkspace = require("./canvas-ui/kl-canvas-workspace");
var _canvasPreview = require("./canvas-ui/canvas-preview");
var _freeTransform = require("./ui/components/free-transform");
var _freeTransformCanvas = require("./ui/components/free-transform-canvas");
var _cropper = require("./ui/components/cropper");
var _layerPreview = require("./ui/components/layer-preview");
var _showImportAsLayerDialog = require("./ui/modals/show-import-as-layer-dialog");
var _klImageDropper = require("./ui/components/kl-image-dropper");
var _overlayToolspace = require("./ui/components/overlay-toolspace");
var _toolspaceTopRow = require("./ui/components/toolspace-top-row");
var _toolDropdown = require("./ui/components/tool-dropdown");
var _toolspaceToolRow = require("./ui/components/toolspace-tool-row");
var _toolspaceStabilizerRow = require("./ui/components/toolspace-stabilizer-row");
var _tabRow = require("./ui/components/tab-row");
var _handUi = require("./ui/tool-tabs/hand-ui");
var _fillUi = require("./ui/tool-tabs/fill-ui");
var _textUi = require("./ui/tool-tabs/text-ui");
var _shapeUi = require("./ui/tool-tabs/shape-ui");
var _newImageDialog = require("./ui/modals/new-image-dialog");
var _toolspaceCollapser = require("./ui/components/toolspace-collapser");
var _renderText = require("./image-operations/render-text");
var _textToolDialog = require("./ui/modals/text-tool-dialog/text-tool-dialog");
var _showImportImageDialog = require("./ui/modals/show-import-image-dialog");
var _floodFill = require("./image-operations/flood-fill");
var _psd = require("./storage/psd");
var _shapeTool = require("./image-operations/shape-tool");
var _klCanvas = require("./canvas/kl-canvas");
var _indexedDb = require("./storage/indexed-db");
var _filters = require("./filters/filters");
var _brushes = require("./brushes/brushes");
var _brushesUi = require("./brushes-ui/brushes-ui");
var _showIframeModal = require("./ui/modals/show-iframe-modal");
var _radioList = require("./ui/components/radio-list");
var _browserStorageUi = require("./ui/components/browser-storage-ui");
var _drawProject = require("./canvas/draw-project");
var _projectStore = require("./storage/project-store");
var _fileTab = require("./ui/tool-tabs/file-tab");
var _filterTab = require("./ui/tool-tabs/filter-tab");
var _imgurUpload = require("./ui/modals/imgur-upload");
var _loadAgPsd = require("./storage/load-ag-psd");
var _saveReminder = require("./ui/components/save-reminder");
var _saveToComputer = require("./storage/save-to-computer");
var _undoRedoCatchup = require("./history/undo-redo-catchup");
var _brushSettingService = require("./brushes-ui/brush-setting-service");
var _boxToggle = require("./ui/components/box-toggle");
var _settingsTab = require("./ui/tool-tabs/settings-tab");
var _toolspaceScroller = require("./ui/components/toolspace-scroller");
var _gradientUi = require("./ui/tool-tabs/gradient-ui");
var _gradientTool = require("./image-operations/gradient-tool");
const KL = {
    brushes: // --- brushes ---
    (0, _brushes.brushes),
    brushesUI: (0, _brushesUi.brushesUI),
    BrushSettingService: (0, _brushSettingService.BrushSettingService),
    KlCanvas: // --- canvas ---
    (0, _klCanvas.KlCanvas),
    drawProject: (0, _drawProject.drawProject),
    WorkspaceSvgOverlay: // --- canvas ui ---
    (0, _workspaceSvgOverlay.WorkspaceSvgOverlay),
    KlCanvasWorkspace: (0, _klCanvasWorkspace.KlCanvasWorkspace),
    KlCanvasPreview: (0, _canvasPreview.KlCanvasPreview),
    filterLibStatus: // --- filters ---
    (0, _filters.filterLibStatus),
    filterLib: (0, _filters.filterLib),
    UndoRedoCatchup: // --- history ---
    (0, _undoRedoCatchup.UndoRedoCatchup),
    renderText: // --- image operations ---
    (0, _renderText.renderText),
    floodFillBits: (0, _floodFill.floodFillBits),
    ShapeTool: (0, _shapeTool.ShapeTool),
    drawShape: (0, _shapeTool.drawShape),
    GradientTool: (0, _gradientTool.GradientTool),
    drawGradient: (0, _gradientTool.drawGradient),
    PSD: // --- storage ---
    _psd,
    setDbName: (0, _indexedDb.setDbName),
    indexedDb: _indexedDb,
    ProjectStore: (0, _projectStore.ProjectStore),
    loadAgPsd: (0, _loadAgPsd.loadAgPsd),
    SaveToComputer: (0, _saveToComputer.SaveToComputer),
    calcSliderFalloffFactor: // --- ui - components ---
    (0, _sliderFalloff.calcSliderFalloffFactor),
    Checkbox: (0, _checkbox.Checkbox),
    input: (0, _input.input),
    Select: (0, _select.Select),
    ImageToggle: (0, _imageToggle.ImageToggle),
    ImageRadioList: (0, _imageRadioList.ImageRadioList),
    RadioList: (0, _radioList.RadioList),
    createPenPressureToggle: (0, _createPenPressureToggle.createPenPressureToggle),
    KlSlider: (0, _klSlider.KlSlider),
    HexColorDialog: (0, _colorSliderHexDialog.HexColorDialog),
    KlColorSlider: (0, _klColorSlider.KlColorSlider),
    KlColorSliderSmall: (0, _klColorSliderSmall.KlColorSliderSmall),
    PointSlider: (0, _pointSlider.PointSlider),
    ColorOptions: (0, _colorOptions.ColorOptions),
    Options: (0, _options.Options),
    BoxToggle: (0, _boxToggle.BoxToggle),
    StatusOverlay: (0, _statusOverlay.StatusOverlay),
    CropCopy: (0, _cropCopy.CropCopy),
    FreeTransform: (0, _freeTransform.FreeTransform),
    FreeTransformCanvas: (0, _freeTransformCanvas.FreeTransformCanvas),
    Cropper: (0, _cropper.Cropper),
    LayerPreview: (0, _layerPreview.LayerPreview),
    KlImageDropper: (0, _klImageDropper.KlImageDropper),
    OverlayToolspace: (0, _overlayToolspace.OverlayToolspace),
    ToolspaceTopRow: (0, _toolspaceTopRow.ToolspaceTopRow),
    ToolDropdown: (0, _toolDropdown.ToolDropdown),
    ToolspaceToolRow: (0, _toolspaceToolRow.ToolspaceToolRow),
    ToolspaceStabilizerRow: (0, _toolspaceStabilizerRow.ToolspaceStabilizerRow),
    TabRow: (0, _tabRow.TabRow),
    ToolspaceCollapser: (0, _toolspaceCollapser.ToolspaceCollapser),
    BrowserStorageUi: (0, _browserStorageUi.BrowserStorageUi),
    SaveReminder: (0, _saveReminder.SaveReminder),
    ToolspaceScroller: (0, _toolspaceScroller.ToolspaceScroller),
    dialogCounter: // --- ui - modals ---
    (0, _modalCount.dialogCounter),
    popup: (0, _showModal.showModal),
    Popup: (0, _dynamicModal.DynamicModal),
    clipboardDialog: (0, _clipboardDialog.clipboardDialog),
    showImportAsLayerDialog: (0, _showImportAsLayerDialog.showImportAsLayerDialog),
    newImageDialog: (0, _newImageDialog.newImageDialog),
    textToolDialog: (0, _textToolDialog.textToolDialog),
    showImportImageDialog: (0, _showImportImageDialog.showImportImageDialog),
    showIframePopup: (0, _showIframeModal.showIframeModal),
    imgurUpload: (0, _imgurUpload.imgurUpload),
    HandUi: // --- ui - tool tabs ---
    (0, _handUi.HandUi),
    FillUi: (0, _fillUi.FillUi),
    GradientUi: (0, _gradientUi.GradientUi),
    TextUi: (0, _textUi.TextUi),
    ShapeUi: (0, _shapeUi.ShapeUi),
    FileTab: (0, _fileTab.FileTab),
    FilterTab: (0, _filterTab.FilterTab),
    SettingsTab: (0, _settingsTab.SettingsTab),
    LayerManager: (0, _layerManager.LayerManager),
    klHistory: (0, _klHistory.klHistory),
    DecoyKlHistory: (0, _klHistory.DecoyKlHistory)
};
Object.keys(KL); // without this, parcel build may break this object

},{"./history/kl-history":"klzEn","./ui/modals/base/showModal":"hr9Po","./ui/modals/base/dynamic-modal":"52d4a","./ui/modals/modal-count":"lsSVM","./ui/components/checkbox":"8fYiz","./ui/components/input":"je8IE","./ui/components/select":"jmugN","./ui/components/image-toggle":"jkvyd","./ui/components/image-radio-list":"cHp0o","./ui/components/create-pen-pressure-toggle":"4cmBB","./ui/components/kl-slider":"4hcvv","./ui/components/slider-falloff":"8lnTu","./ui/modals/color-slider-hex-dialog":"es6uV","./ui/components/kl-color-slider":"9lORX","./ui/components/kl-color-slider-small":"jJnMO","./ui/components/point-slider":"3j9Hm","./ui/components/color-options":"iXzf7","./ui/components/options":"hNLP6","./ui/components/status-overlay":"ke842","./ui/components/crop-copy":"aTBXS","./ui/modals/clipboard-dialog":"9W8Vp","./ui/tool-tabs/layer-manager/layer-manager":"lykpU","./canvas-ui/workspace-svg-overlay":"kspFU","./canvas-ui/kl-canvas-workspace":"ep4xw","./canvas-ui/canvas-preview":"gRZnS","./ui/components/free-transform":"izcGJ","./ui/components/free-transform-canvas":"3quPq","./ui/components/cropper":"bajkn","./ui/components/layer-preview":"1YtXQ","./ui/modals/show-import-as-layer-dialog":"aDt10","./ui/components/kl-image-dropper":"9RVJV","./ui/components/overlay-toolspace":"hWy6k","./ui/components/toolspace-top-row":"fltn0","./ui/components/tool-dropdown":"3fI3r","./ui/components/toolspace-tool-row":"eTege","./ui/components/toolspace-stabilizer-row":"84zrw","./ui/components/tab-row":"fLnal","./ui/tool-tabs/hand-ui":"brsBa","./ui/tool-tabs/fill-ui":"5n3hF","./ui/tool-tabs/text-ui":"jaulB","./ui/tool-tabs/shape-ui":"7GG7G","./ui/modals/new-image-dialog":"5IVi4","./ui/components/toolspace-collapser":"l6lvr","./image-operations/render-text":"fEvNY","./ui/modals/text-tool-dialog/text-tool-dialog":"9SsS6","./ui/modals/show-import-image-dialog":"8CgvP","./image-operations/flood-fill":"j0xrQ","./storage/psd":"Q3aBW","./image-operations/shape-tool":"90Wty","./canvas/kl-canvas":"l78MY","./storage/indexed-db":"eCGtt","./filters/filters":"lIjDv","./brushes/brushes":"8eOZC","./brushes-ui/brushes-ui":"io8zk","./ui/modals/show-iframe-modal":"2luNL","./ui/components/radio-list":"7SCtU","./ui/components/browser-storage-ui":"9u5bD","./canvas/draw-project":"6Yf6D","./storage/project-store":"gZHsZ","./ui/tool-tabs/file-tab":"3rIr5","./ui/tool-tabs/filter-tab":"ftyCZ","./ui/modals/imgur-upload":"cZn9c","./storage/load-ag-psd":"gJgsA","./ui/components/save-reminder":"i5Pgf","./storage/save-to-computer":"axnPV","./history/undo-redo-catchup":"e5QXt","./brushes-ui/brush-setting-service":"dTdDM","./ui/components/box-toggle":"aQOIq","./ui/tool-tabs/settings-tab":"4JW40","./ui/components/toolspace-scroller":"gytag","./ui/tool-tabs/gradient-ui":"boDxv","./image-operations/gradient-tool":"jhX3B","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"klzEn":[function(require,module,exports) {
// --------- history entry types ------------------------------
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DecoyKlHistory", ()=>DecoyKlHistory);
parcelHelpers.export(exports, "KlHistory", ()=>KlHistory);
parcelHelpers.export(exports, "klHistory", ()=>klHistory);
var _base = require("../../bb/base/base");
let historyInstance = false;
class DecoyKlHistory {
    pause() {}
    addListener() {}
    push() {}
    undo() {
        return [];
    }
    redo() {
        return undefined;
    }
    getAll() {
        return [];
    }
    canRedo() {
        return false;
    }
    canUndo() {
        return false;
    }
    getState() {
        return 0;
    }
    getActionNumber() {
        return 0;
    }
}
const DO_DELETE_OLD = true;
class KlHistory {
    broadcast(p) {
        setTimeout(()=>{
            for(let i = 0; i < this.listeners.length; i++)this.listeners[i](p);
            this.state++;
        }, 1);
    }
    // ---- public ----
    constructor(){
        this.max = 20 // max number undo steps
        ;
        if (historyInstance) throw new Error("klHistory already instantiated");
        historyInstance = true;
        this.state = 0;
        this.entries = [];
        this.listeners = [];
        this.pauseStack = 0;
        this.maxState = -1;
        this.actionNumber = -1;
    }
    /**
     * Needed, because sometimes there are actions that would cause other undo steps.
     * For example a filter that does something with two layers and then merges them.
     * That should be a single undo step, and prevent merging from creating its own undo step.
     * Pause prevents creation of unintended undo steps.
     */ pause(b) {
        if (b) this.pauseStack++;
        else this.pauseStack = Math.max(0, this.pauseStack - 1);
    }
    addListener(l) {
        this.listeners.push(l);
    }
    push(newEntry) {
        if (this.pauseStack > 0) return;
        while(this.actionNumber < this.entries.length - 1)this.entries.pop();
        //taking care of actions that shouldn't cause a new undo step
        const lastEntry = this.entries[this.entries.length - 1];
        // opacity
        if (lastEntry && newEntry.tool[0] === "canvas" && lastEntry.tool[0] === "canvas" && newEntry.action === "layerOpacity" && lastEntry.action === "layerOpacity" && lastEntry.params[0] === newEntry.params[0]) {
            this.entries[this.entries.length - 1] = newEntry;
            this.state++; //still needs to increment because something changed
            return;
        }
        // layer visibility
        if (lastEntry && newEntry.tool[0] === "canvas" && lastEntry.tool[0] === "canvas" && newEntry.action === "setLayerIsVisible" && lastEntry.action === "setLayerIsVisible" && lastEntry.params[0] === newEntry.params[0] && lastEntry.params[1] != newEntry.params[1]) {
            // if last and current step toggle visibility -> that means it's the way it was before
            this.entries.pop();
            this.actionNumber--;
            this.state++; //still needs to increment because something changed
            this.broadcast(null);
            return;
        }
        // select layer
        if (newEntry.action === "focusLayer" && lastEntry && lastEntry.action === "focusLayer") {
            this.entries[this.entries.length - 1] = newEntry;
            this.state++;
            return;
        }
        this.entries[this.entries.length] = newEntry;
        this.actionNumber = this.entries.length - 1;
        const maxBefore = this.maxState;
        this.maxState = Math.max(this.maxState, this.actionNumber - this.max);
        if (maxBefore < this.maxState) {
            const item = this.entries[this.maxState];
            if (!item) throw new Error("this.dataArr[this.maxState] null");
            this.broadcast({
                bufferUpdate: item
            });
        } else this.broadcast(null);
        if (DO_DELETE_OLD && this.maxState >= 0) this.entries[this.maxState] = null; //to free some memory...imported images take a lot of space
    }
    /**
     * lowers action number, returns all entries that need to be executed
     * on trailing snapshot to represent the canvas one undo step back.
     * Empty array if it can't undo
     */ undo() {
        const result = [];
        if (!this.canUndo()) return result;
        for(let i = this.maxState + 1; i < this.actionNumber; i++)result.push((0, _base.throwIfNull)(this.entries[i]));
        this.actionNumber--;
        this.broadcast(null);
        return result;
    }
    /**
     * raises action number, returns the action to be redone
     */ redo() {
        if (!this.canRedo()) return undefined;
        this.actionNumber++;
        this.broadcast(null);
        return (0, _base.throwIfNull)(this.entries[this.actionNumber]);
    }
    getAll() {
        return [
            ...this.entries
        ];
    }
    canRedo() {
        return this.actionNumber < this.entries.length - 1;
    }
    canUndo() {
        return this.actionNumber > this.maxState;
    }
    getState() {
        return this.state;
    }
    /**
     * actionNumber - number of undo-able actions a user has done (e.g. if drawn 5 lines total -> 5)
     */ getActionNumber() {
        return this.actionNumber + 1;
    }
}
const klHistory = new KlHistory();

},{"../../bb/base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k6nNY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "insertAfter", ()=>insertAfter);
parcelHelpers.export(exports, "loadImage", ()=>loadImage);
parcelHelpers.export(exports, "asyncLoadImage", ()=>asyncLoadImage);
parcelHelpers.export(exports, "css", ()=>css);
parcelHelpers.export(exports, "setAttributes", ()=>setAttributes);
/**
 * append a list to DOM element
 */ parcelHelpers.export(exports, "append", ()=>append);
/**
 * a needs to fit into b
 */ parcelHelpers.export(exports, "fitInto", ()=>fitInto);
/**
 * center b in a
 * @param aw
 * @param ah
 * @param bw
 * @param bh
 */ parcelHelpers.export(exports, "centerWithin", ()=>centerWithin);
parcelHelpers.export(exports, "getDate", ()=>getDate);
parcelHelpers.export(exports, "gcd", ()=>gcd);
parcelHelpers.export(exports, "reduce", ()=>reduce);
parcelHelpers.export(exports, "decToFraction", ()=>decToFraction);
/**
 * blobObj isn't always a Blob, but rather an object, because Blob doesn't exist.
 * @param blobObj
 * @returns {string}
 */ parcelHelpers.export(exports, "imageBlobToUrl", ()=>imageBlobToUrl);
parcelHelpers.export(exports, "dateDayDifference", ()=>dateDayDifference);
parcelHelpers.export(exports, "copyObj", ()=>copyObj);
/**
 * triggers Web Share API - share feature on mobile devices
 * Only works if they support file sharing - e.g. Safari can't do this yet
 * only call if BB.canShareFiles() -> true
 *
 * p = {
 *     canvas: Canvas,
 *     fileName: string,
 *     title: string
 * }
 *
 * @param p
 */ parcelHelpers.export(exports, "shareCanvas", ()=>shareCanvas);
/**
 * Prevent ipad from zooming in when double tapping. iPadOS 13 bug.
 * Give it your click event
 *
 * @param clickEvent
 * @returns {boolean}
 */ parcelHelpers.export(exports, "handleClick", ()=>handleClick);
parcelHelpers.export(exports, "createSvg", ()=>createSvg);
parcelHelpers.export(exports, "throwIfNull", ()=>throwIfNull);
parcelHelpers.export(exports, "throwIfUndefined", ()=>throwIfUndefined);
parcelHelpers.export(exports, "nullToUndefined", ()=>nullToUndefined);
parcelHelpers.export(exports, "isDark", ()=>isDark);
parcelHelpers.export(exports, "addIsDarkListener", ()=>addIsDarkListener);
parcelHelpers.export(exports, "removeIsDarkListener", ()=>removeIsDarkListener);
function insertAfter(referenceNode, newNode) {
    if (referenceNode.parentNode) referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}
function loadImage(im, callback) {
    let counter = 0;
    function check() {
        if (counter === 1000) {
            alert("couldn't load");
            return;
        }
        if (im.complete) {
            counter++;
            callback();
        } else setTimeout(check, 1);
    }
    check();
}
function asyncLoadImage(src) {
    return new Promise((resolve, reject)=>{
        const img = new Image();
        img.onload = ()=>resolve(img);
        img.onerror = reject;
        img.src = src;
    });
}
function css(el, styleObj) {
    const keyArr = Object.keys(styleObj);
    let keyStr;
    const style = el.style;
    for(let i = 0; i < keyArr.length; i++){
        keyStr = keyArr[i];
        style[keyStr] = styleObj[keyStr];
        if (keyStr === "userSelect") style.webkitUserSelect = styleObj[keyStr]; // safari
    }
}
function setAttributes(el, attrObj) {
    const keyArr = Object.keys(attrObj);
    let keyStr;
    for(let i = 0; i < keyArr.length; i++){
        keyStr = keyArr[i];
        el.setAttribute(keyStr, attrObj[keyStr]);
    }
}
function append(target, els) {
    const fragment = document.createDocumentFragment();
    els.forEach((item)=>item && fragment.append(item));
    target.append(fragment);
}
function fitInto(aw, ah, bw, bh, min) {
    let width = aw * bw, height = ah * bw;
    if (width > bw) {
        height = bw / width * height;
        width = bw;
    }
    if (height > bh) {
        width = bh / height * width;
        height = bh;
    }
    if (min) {
        width = Math.max(min, width);
        height = Math.max(min, height);
    }
    return {
        width,
        height
    };
}
function centerWithin(aw, ah, bw, bh) {
    return {
        x: aw / 2 - bw / 2,
        y: ah / 2 - bh / 2
    };
}
function getDate() {
    const date = new Date();
    const year = date.getFullYear();
    const month = (date.getMonth() + 1).toString().padStart(2, "0");
    const day = date.getDate().toString().padStart(2, "0");
    const minutes = (date.getHours() * 60 + date.getMinutes()).toString(36).padStart(3, "0");
    return year + "_" + month + "_" + day + "_" + minutes + "_";
}
function gcd(a, b) {
    return b ? gcd(b, a % b) : a;
}
function reduce(numerator, denominator) {
    const g = gcd(numerator, denominator);
    return [
        numerator / g,
        denominator / g
    ];
}
function decToFraction(decimalNumber) {
    const len = decimalNumber.toString().length - 2;
    const denominator = Math.pow(10, len);
    const numerator = decimalNumber * denominator;
    return reduce(numerator, denominator);
}
function imageBlobToUrl(blobObj) {
    if (!blobObj) throw new Error("blobObj is undefined or null");
    if (window.Blob && blobObj instanceof Blob) return URL.createObjectURL(blobObj); // object url
    else if (blobObj.constructor.name === "Object") {
        const fauxBlob = blobObj;
        return "data:" + fauxBlob.type + ";" + fauxBlob.encoding + "," + fauxBlob.data; // data url
    } else throw new Error("unknown blob format");
}
function dateDayDifference(dateA, dateB) {
    dateA = new Date(dateA);
    dateB = new Date(dateB);
    dateA.setHours(0, 0, 0, 0);
    dateB.setHours(0, 0, 0, 0);
    return (dateB.getTime() - dateA.getTime()) / 86400000;
}
function copyObj(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function shareCanvas(p) {
    const mimetype = "image/png";
    const err = ()=>alert("sharing not supported");
    p.canvas.toBlob(function(blob) {
        if (!blob) {
            err();
            p.callback();
            return;
        }
        try {
            const filesArray = [
                new File([
                    blob
                ], p.fileName, {
                    type: mimetype
                })
            ];
            navigator.share({
                title: p.title,
                files: filesArray
            }).then(()=>{}).catch(()=>{
                err();
            });
        } catch (e) {
            err();
        }
        p.callback();
    }, mimetype);
}
function handleClick(clickEvent) {
    const target = clickEvent.target;
    if (!target) return false;
    if ([
        "A",
        "LABEL",
        "INPUT",
        "SUMMARY"
    ].includes(target.tagName) || target.allowClick) return true;
    clickEvent.preventDefault();
    return false;
}
function createSvg(p) {
    const result = document.createElementNS("http://www.w3.org/2000/svg", p.elementType);
    Object.entries(p).forEach(([keyStr, item])=>{
        if (keyStr === "childrenArr") item.forEach((child)=>{
            result.append(createSvg(child));
        });
        else if (keyStr !== "elementType") result.setAttribute(keyStr, item);
    });
    return result;
}
function throwIfNull(v) {
    // (disabled) eslint-disable-next-line no-null/no-null
    if (v === null) throw new Error("value is null");
    return v;
}
function throwIfUndefined(v, message = "value is undefined") {
    if (v === undefined) throw new Error(message);
    return v;
}
function nullToUndefined(v) {
    return v === null ? undefined : v;
}
const matchMediaDark = "matchMedia" in window ? window.matchMedia("(prefers-color-scheme: dark)") : false;
function isDark() {
    return matchMediaDark && matchMediaDark.matches;
}
function addIsDarkListener(func) {
    matchMediaDark && "addEventListener" in matchMediaDark && matchMediaDark.addEventListener("change", func);
}
function removeIsDarkListener(func) {
    matchMediaDark && "removeEventListener" in matchMediaDark && matchMediaDark.removeEventListener("change", func);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gkKU3":[function(require,module,exports) {
exports.interopDefault = function(a) {
    return a && a.__esModule ? a : {
        default: a
    };
};
exports.defineInteropFlag = function(a) {
    Object.defineProperty(a, "__esModule", {
        value: true
    });
};
exports.exportAll = function(source, dest) {
    Object.keys(source).forEach(function(key) {
        if (key === "default" || key === "__esModule" || dest.hasOwnProperty(key)) return;
        Object.defineProperty(dest, key, {
            enumerable: true,
            get: function() {
                return source[key];
            }
        });
    });
    return dest;
};
exports.export = function(dest, destName, get) {
    Object.defineProperty(dest, destName, {
        enumerable: true,
        get: get
    });
};

},{}],"hr9Po":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showModal", ()=>showModal);
var _modalCount = require("../modal-count");
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
var _scrollFix = require("./scroll-fix");
var _cancelSvg = require("/src/app/img/ui/cancel.svg");
var _cancelSvgDefault = parcelHelpers.interopDefault(_cancelSvg);
var _checkSvg = require("/src/app/img/ui/check.svg");
var _checkSvgDefault = parcelHelpers.interopDefault(_checkSvg);
function showModal(p) {
    (0, _modalCount.dialogCounter).increase();
    let isClosed = false;
    let ignoreBackground = !!p.ignoreBackground;
    // need this extra layer because chrome mobile otherwise scrolls the page and then glitches as the address bar goes away
    const rootRootEl = (0, _bb.BB).el({
        parent: document.body,
        css: {
            position: "absolute",
            left: "0",
            top: "0",
            right: "0",
            bottom: "0",
            overflow: "hidden"
        }
    });
    const rootEl = (0, _bb.BB).el({
        parent: rootRootEl,
        className: "kl-popup"
    });
    const scrollContent = (0, _bb.BB).el({
        parent: rootEl,
        css: {
            width: "100%",
            minHeight: "100%",
            // padding: '10px 0',
            position: "relative",
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center"
        }
    });
    const bgEl = (0, _bb.BB).el({
        parent: scrollContent,
        onClick: ()=>{
            if (ignoreBackground) return;
            close("Cancel");
        },
        css: {
            position: "absolute",
            left: "0",
            top: "0",
            zIndex: "0",
            width: "100%",
            height: "100%"
        }
    });
    const titleHeight = 40;
    const xButton = (0, _bb.BB).el({
        tagName: "button",
        className: "popup-x",
        content: `<img alt="${(0, _language.LANG)("modal-close")}" height="20" src="${(0, _cancelSvgDefault.default)}">`,
        title: (0, _language.LANG)("modal-close"),
        onClick: ()=>{
            close("Cancel");
        },
        css: {
            width: titleHeight + "px",
            height: titleHeight + "px",
            lineHeight: titleHeight + "px",
            position: "absolute",
            right: "0",
            top: "0",
            background: "none",
            boxShadow: "none"
        }
    });
    let icon = undefined;
    if (p.type) icon = (0, _bb.BB).el({
        className: {
            error: "kl-popup__icon-error",
            ok: "kl-popup__icon-ok",
            warning: "kl-popup__icon-warning",
            upload: "kl-popup__icon-upload"
        }[p.type]
    });
    const boxClasses = [
        "kl-popup-box"
    ];
    boxClasses.push("kl-popup-box--sm");
    const boxEl = (0, _bb.BB).el({
        content: [
            xButton,
            icon,
            (0, _bb.BB).el({
                content: p.message,
                css: {
                    marginRight: "15px",
                    marginBottom: p.div ? "10px" : undefined
                }
            }),
            p.div
        ],
        className: boxClasses.join(" "),
        css: p.style ? p.style : undefined
    });
    scrollContent.append((0, _bb.BB).el({
        css: {
            flex: "0.5"
        }
    }), boxEl, (0, _bb.BB).el({
        css: {
            flex: "1"
        }
    }));
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr, e, comboStr) {
            if (isClosed) return;
            if (clickOnEnterBtn && comboStr === "enter" && !(0, _bb.BB).isInputFocused()) {
                e.stopPropagation();
                setTimeout(()=>{
                    clickOnEnterBtn && clickOnEnterBtn.click();
                }, 10);
            }
            if (comboStr === "esc") {
                e.stopPropagation();
                close("Cancel");
            }
        }
    });
    // prevent ctrl scroll -> zooming page
    const wheelPrevent = (event)=>{
        if (keyListener.isPressed("ctrl")) event.preventDefault();
    };
    rootEl.addEventListener("wheel", wheelPrevent);
    rootEl.onclick = (0, _bb.BB).handleClick;
    let autoFocus;
    if (p.autoFocus) autoFocus = p.autoFocus;
    else if (p.autoFocus === false) autoFocus = undefined;
    else autoFocus = "Ok";
    const buttonRowEl = p.buttons && p.buttons.length > 0 ? (0, _bb.BB).el({
        parent: boxEl,
        css: {
            display: "flex",
            flexWrap: "wrap",
            justifyContent: "flex-end",
            marginTop: "12px",
            marginLeft: "-8px"
        }
    }) : undefined;
    let clickOnEnterBtn;
    const btnElArr = [];
    if (p.buttons) p.buttons.forEach((buttonName)=>{
        const btnClasses = [
            "kl-popup__btn"
        ];
        if (buttonName === "Ok" || p.primaries && p.primaries.includes(buttonName)) btnClasses.push("kl-button-primary");
        let iconUrl;
        let label = buttonName;
        if (buttonName === "Ok") {
            label = (0, _language.LANG)("modal-ok");
            iconUrl = (0, _checkSvgDefault.default);
        }
        if (buttonName === "Cancel") {
            label = (0, _language.LANG)("modal-cancel");
            iconUrl = (0, _cancelSvgDefault.default);
            btnClasses.push("kl-button-cancel");
        }
        let iconImg = undefined;
        if (iconUrl) iconImg = (0, _bb.BB).el({
            tagName: "img",
            custom: {
                src: iconUrl,
                height: "17"
            }
        });
        const btn = (0, _bb.BB).el({
            parent: buttonRowEl,
            tagName: "button",
            className: btnClasses.join(" "),
            content: [
                iconImg,
                (0, _bb.BB).el({
                    className: "kl-popup__btn__text",
                    content: label
                })
            ],
            onClick: ()=>{
                close(buttonName);
            }
        });
        btnElArr.push(btn);
        if (autoFocus === buttonName) {
            setTimeout(()=>{
                btn.focus();
                rootEl.scrollTo(0, 0);
            }, 10);
            setTimeout(()=>{
                // safari needs a separate timeout
                rootEl.scrollTo(0, 0);
            }, 20);
        }
        if (buttonName === p.clickOnEnter) clickOnEnterBtn = btn;
    });
    function close(value) {
        if (isClosed) return;
        isClosed = true;
        (0, _bb.BB).clearSelection();
        (0, _bb.BB).unfocusAnyInput();
        rootRootEl.remove();
        (0, _modalCount.dialogCounter).decrease();
        (0, _bb.BB).destroyEl(xButton);
        (0, _bb.BB).destroyEl(bgEl);
        keyListener.destroy();
        rootEl.removeEventListener("wheel", wheelPrevent);
        // (disabled) eslint-disable-next-line no-null/no-null
        rootEl.onclick = null;
        btnElArr.forEach((item)=>(0, _bb.BB).destroyEl(item));
        btnElArr.splice(0, btnElArr.length);
        if (p.callback) p.callback(value);
    }
    if (p.closeFunc) p.closeFunc(function() {
        close("Cancel");
    });
    return {
        setIgnoreBackground: (b)=>{
            ignoreBackground = b;
        }
    };
}

},{"../modal-count":"lsSVM","../../../../bb/bb":"dcQKo","../../../../language/language":"iiYGN","./scroll-fix":"4BgqB","/src/app/img/ui/cancel.svg":"7BZQD","/src/app/img/ui/check.svg":"ge8fi","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lsSVM":[function(require,module,exports) {
// not the best
/**
 * how many modals are open
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DialogCounter", ()=>DialogCounter);
parcelHelpers.export(exports, "dialogCounter", ()=>dialogCounter);
class DialogCounter {
    emit() {
        this.listeners.forEach((item)=>{
            item(this.count);
        });
    }
    increase(v) {
        if (v !== undefined) this.count += v;
        else this.count++;
        this.emit();
    }
    decrease(v) {
        if (v !== undefined) this.count -= v;
        else this.count--;
        this.emit();
    }
    get() {
        return this.count;
    }
    subscribe(listener) {
        this.listeners.push(listener);
    }
    constructor(){
        this.listeners = [];
        this.count = 0;
    }
}
const dialogCounter = new DialogCounter();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dcQKo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BB", ()=>BB);
var _base = require("./base/base");
var _browser = require("./base/browser");
var _keyListener = require("./input/key-listener");
var _pointerListener = require("./input/pointer-listener");
var _canvas = require("./base/canvas");
var _matrix = require("./math/matrix");
var _vec2 = require("./math/vec2");
var _line = require("./math/line");
var _color = require("./color/color");
var _ui = require("./base/ui");
var _math = require("./math/math");
var _createCanvas = require("./base/create-canvas");
var _bbLog = require("./base/bb-log");
var _localStorage = require("./base/local-storage");
var _coalescedExploder = require("./input/event-chain/coalesced-exploder");
var _nFingerTapper = require("./input/event-chain/n-finger-tapper");
var _pinchZoomer = require("./input/event-chain/pinch-zoomer");
var _doubleTapper = require("./input/event-chain/double-tapper");
var _onePointerLimiter = require("./input/event-chain/one-pointer-limiter");
var _eventChain = require("./input/event-chain/event-chain");
const BB = {
    eventUsesHighResTimeStamp: // ---- browser ----
    (0, _browser.eventUsesHighResTimeStamp),
    hasPointerEvents: (0, _browser.hasPointerEvents),
    isCssMinMaxSupported: (0, _browser.isCssMinMaxSupported),
    canShareFiles: (0, _browser.canShareFiles),
    unsetEventHandler: (0, _browser.unsetEventHandler),
    insertAfter: // ---- base ----
    (0, _base.insertAfter),
    loadImage: (0, _base.loadImage),
    css: (0, _base.css),
    setAttributes: (0, _base.setAttributes),
    append: (0, _base.append),
    fitInto: (0, _base.fitInto),
    centerWithin: (0, _base.centerWithin),
    getDate: (0, _base.getDate),
    gcd: (0, _base.gcd),
    reduce: (0, _base.reduce),
    decToFraction: (0, _base.decToFraction),
    imageBlobToUrl: (0, _base.imageBlobToUrl),
    dateDayDifference: (0, _base.dateDayDifference),
    copyObj: (0, _base.copyObj),
    shareCanvas: (0, _base.shareCanvas),
    handleClick: (0, _base.handleClick),
    createSvg: (0, _base.createSvg),
    BbLog: (0, _bbLog.BbLog),
    LocalStorage: (0, _localStorage.LocalStorage),
    throwIfNull: (0, _base.throwIfNull),
    nullToUndefined: (0, _base.nullToUndefined),
    isDark: (0, _base.isDark),
    mix: // ---- math ----
    (0, _math.mix),
    dist: (0, _math.dist),
    distSquared: (0, _math.distSquared),
    lenSquared: (0, _math.lenSquared),
    pointsToAngleRad: (0, _math.pointsToAngleRad),
    pointsToAngleDeg: (0, _math.pointsToAngleDeg),
    isInsideRect: (0, _math.isInsideRect),
    clamp: (0, _math.clamp),
    rotate: (0, _math.rotate),
    rotateAround: (0, _math.rotateAround),
    Matrix: (0, _matrix.Matrix),
    Vec2: (0, _vec2.Vec2),
    intDxy: (0, _math.intDxy),
    roundEven: (0, _math.roundEven),
    roundUneven: (0, _math.roundUneven),
    round: (0, _math.round),
    updateBounds: (0, _math.updateBounds),
    boundsInArea: (0, _math.boundsInArea),
    projectPointOnLine: // ---- line ----
    (0, _line.projectPointOnLine),
    PointLine: (0, _line.PointLine),
    BezierLine: (0, _line.BezierLine),
    SplineInterpolator: (0, _line.SplineInterpolator),
    quadraticSplineInput: (0, _line.quadraticSplineInput),
    // ---- canvas ----
    canvas: (0, _createCanvas.createCanvas),
    ctx: (0, _canvas.ctx),
    copyCanvas: (0, _canvas.copyCanvas),
    testShouldPixelate: (0, _canvas.testShouldPixelate),
    drawTransformedImageWithBounds: (0, _canvas.drawTransformedImageWithBounds),
    drawTransformedImageOnCanvas: (0, _canvas.drawTransformedImageOnCanvas),
    createCheckerCanvas: (0, _canvas.createCheckerCanvas),
    createCheckerDataUrl: (0, _canvas.createCheckerDataUrl),
    resizeCanvas: (0, _canvas.resizeCanvas),
    convertToAlphaChannelCanvas: (0, _canvas.convertToAlphaChannelCanvas),
    freeCanvas: (0, _canvas.freeCanvas),
    canvasBounds: (0, _canvas.canvasBounds),
    HSV: // ---- color ----
    (0, _color.HSV),
    RGB: (0, _color.RGB),
    CMYK: (0, _color.CMYK),
    ColorConverter: (0, _color.ColorConverter),
    testIsWhiteBestContrast: (0, _color.testIsWhiteBestContrast),
    appendTextDiv: // ---- UI ----
    (0, _ui.appendTextDiv),
    clearSelection: (0, _ui.clearSelection),
    makeUnfocusable: (0, _ui.makeUnfocusable),
    el: (0, _ui.el),
    destroyEl: (0, _ui.destroyEl),
    isInputFocused: (0, _ui.isInputFocused),
    unfocusAnyInput: (0, _ui.unfocusAnyInput),
    KeyListener: // ---- events / input ----
    (0, _keyListener.KeyListener),
    PointerListener: (0, _pointerListener.PointerListener),
    sameKeys: (0, _keyListener.sameKeys),
    EventChain: (0, _eventChain.EventChain),
    DoubleTapper: (0, _doubleTapper.DoubleTapper),
    NFingerTapper: (0, _nFingerTapper.NFingerTapper),
    PinchZoomer: (0, _pinchZoomer.PinchZoomer),
    CoalescedExploder: (0, _coalescedExploder.CoalescedExploder),
    OnePointerLimiter: (0, _onePointerLimiter.OnePointerLimiter)
};
Object.keys(BB); // without this, parcel build may break this object

},{"./base/base":"k6nNY","./base/browser":"jZRZU","./input/key-listener":"r1p1Z","./input/pointer-listener":"5fbd0","./base/canvas":"d7Vt7","./math/matrix":"k5NsM","./math/vec2":"eFVNh","./math/line":"ewgfM","./color/color":"iVNo9","./base/ui":"2nyzl","./math/math":"7w6MZ","./base/create-canvas":"4BLUK","./base/bb-log":"lSCOF","./base/local-storage":"04p5O","./input/event-chain/coalesced-exploder":"jC5wC","./input/event-chain/n-finger-tapper":"gWILP","./input/event-chain/pinch-zoomer":"T8qtt","./input/event-chain/double-tapper":"7kjBa","./input/event-chain/one-pointer-limiter":"d988z","./input/event-chain/event-chain":"gQC7e","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jZRZU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isFirefox", ()=>isFirefox);
parcelHelpers.export(exports, "eventUsesHighResTimeStamp", ()=>eventUsesHighResTimeStamp);
parcelHelpers.export(exports, "hasPointerEvents", ()=>hasPointerEvents);
parcelHelpers.export(exports, "isCssMinMaxSupported", ()=>isCssMinMaxSupported);
parcelHelpers.export(exports, "canShareFiles", ()=>canShareFiles);
parcelHelpers.export(exports, "unsetEventHandler", ()=>unsetEventHandler);
const isFirefox = navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
const eventUsesHighResTimeStamp = function() {
    const eventUsesHighResTimeStamp = new Event("").timeStamp < 3600000;
    return function() {
        return eventUsesHighResTimeStamp;
    };
}();
const hasPointerEvents = !!window.PointerEvent;
const isCssMinMaxSupported = function() {
    let result;
    function test() {
        const div = document.createElement("div");
        div.style.position = "absolute";
        div.style.top = "0";
        div.style.left = "max(0px, 25px)";
        document.body.append(div);
        setTimeout(function() {
            result = div.offsetLeft === 25;
            div.remove();
        }, 25);
    }
    if (document.body) test();
    else window.addEventListener("DOMContentLoaded", function() {
        test();
    });
    return function() {
        if (result === undefined) throw new Error("isCssMinMaxSupported not initialized");
        return result;
    };
}();
const canShareFiles = function() {
    return "share" in navigator && "canShare" in navigator;
};
function unsetEventHandler(obj, ...handlers) {
    handlers.forEach((handler)=>{
        // (disabled) eslint-disable-next-line no-null/no-null
        obj[handler] = null;
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"r1p1Z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Listens to key events in window. Makes combos easier - e.g. ctrl + z
 *
 * keyStr - see in implementation - my representation of a key. e.g. 'r' can be 'r' and 'R'
 * comboStr - string joins currently pressed keyStr with a +
 *              e.g. 'ctrl+z'
 *
 */ parcelHelpers.export(exports, "KeyListener", ()=>KeyListener);
/**
 * Test, are the same keys pressed. Order does not matter.
 */ parcelHelpers.export(exports, "sameKeys", ()=>sameKeys);
const globalKey = (()=>{
    // keyStr - our key naming system
    // key - KeyboardEvent.key
    // code - KeyboardEvent.code
    const keyStrToKeyObj = {
        "space": [
            " ",
            "Spacebar"
        ],
        "alt": [
            "Alt",
            "AltGraph"
        ],
        "shift": "Shift",
        "ctrl": "Control",
        "cmd": [
            "Meta",
            "MetaLeft",
            "MetaRight"
        ],
        "enter": "Enter",
        "esc": "Escape",
        "backspace": "Backspace",
        "delete": "Delete",
        "sqbr_open": "[",
        "sqbr_close": "]",
        "a": [
            "a",
            "A"
        ],
        "b": [
            "b",
            "B"
        ],
        "c": [
            "c",
            "C"
        ],
        "e": [
            "e",
            "E"
        ],
        "f": [
            "f",
            "F"
        ],
        "g": [
            "g",
            "G"
        ],
        "r": [
            "r",
            "R"
        ],
        "s": [
            "s",
            "S"
        ],
        "t": [
            "t",
            "T"
        ],
        "u": [
            "u",
            "U"
        ],
        "x": [
            "x",
            "X"
        ],
        "y": [
            "y",
            "Y"
        ],
        "z": [
            "z",
            "Z"
        ],
        "plus": "+",
        "minus": "-",
        "left": "ArrowLeft",
        "right": "ArrowRight",
        "up": "ArrowUp",
        "down": "ArrowDown",
        "home": "Home",
        "end": "End"
    };
    // ['space', 'alt', ... ]
    const keyStrArr = Object.keys(keyStrToKeyObj);
    // { space: false, ... }
    const isDownObj = Object.entries(keyStrToKeyObj).reduce((acc, [key])=>{
        acc[key] = false;
        return acc;
    }, {});
    // event.key to keyStr
    // { ArrowLeft: 'left', ... }
    const keyToKeyStrObj = Object.entries(keyStrToKeyObj).reduce((acc, [key, code])=>{
        if (typeof code === "string") acc[code] = key;
        else code.forEach((item)=>{
            acc[item] = key;
        });
        return acc;
    }, {});
    let comboArr = [];
    // a physical key's "key" can change as other keys get pressed. to keep track, need to also track the code
    // { KeyE: 'e', KeyF: undefined } - undefined - not down, string - the associated keyStr
    let codeIsDownObj = {};
    const listenerArr = [];
    const emitDown = function(a, b, c, d) {
        listenerArr.forEach((item)=>{
            if (!item[0]) return;
            item[0](a, b, c, d);
        });
    };
    const emitUp = function(a, b, c) {
        listenerArr.forEach((item)=>{
            if (!item[1]) return;
            item[1](a, b, c);
        });
    };
    const emitBlur = function() {
        listenerArr.forEach((item)=>{
            if (!item[2]) return;
            item[2]();
        });
    };
    function keyDown(e) {
        const key = e.key;
        const code = e.code;
        if (key in keyToKeyStrObj) {
            const keyStr = keyToKeyStrObj[key];
            if (isDownObj[keyStr]) {
                emitDown(keyStr, e, comboArr.join("+"), true);
                return;
            }
            isDownObj[keyStr] = true;
            codeIsDownObj[code] = keyStr;
            //add to combo
            comboArr.push(keyStr);
            emitDown(keyStr, e, comboArr.join("+"));
        }
    }
    function keyUp(e) {
        const code = e.code;
        const oldComboStr = comboArr.join("+");
        // because of a macOS bug: when meta key is down, keyup of other keys does not fire.
        // https://stackoverflow.com/questions/25438608/javascript-keyup-isnt-called-when-command-and-another-is-pressed
        if ([
            "Meta",
            "MetaLeft",
            "MetaRight",
            "OSLeft",
            "OSRight"
        ].includes(code)) {
            blur();
            return;
        }
        const keyStr = codeIsDownObj[code];
        if (keyStr !== undefined) {
            isDownObj[keyStr] = false;
            codeIsDownObj[code] = undefined;
            // remove from combo
            for(let i = 0; i < comboArr.length; i++)if (comboArr[i] == keyStr) {
                comboArr.splice(i, 1);
                i--;
            }
            emitUp(keyStr, e, oldComboStr);
        }
    }
    function blur() {
        const oldComboStr = comboArr.join("+");
        comboArr = [];
        codeIsDownObj = {};
        const eventArr = [];
        keyStrArr.forEach((keyStr)=>{
            if (isDownObj[keyStr]) {
                isDownObj[keyStr] = false;
                eventArr.push(keyStr);
            }
        });
        for(let i = 0; i < eventArr.length; i++)emitUp(eventArr[i], {
            preventDefault: function() {},
            stopPropagation: function() {}
        }, oldComboStr);
        emitBlur();
    }
    return {
        add: (keyListenerRef)=>{
            if (listenerArr.includes(keyListenerRef)) return;
            const first = listenerArr.length === 0;
            listenerArr.push(keyListenerRef);
            if (first) {
                document.addEventListener("keydown", keyDown);
                document.addEventListener("keyup", keyUp);
                window.addEventListener("blur", blur);
            }
        },
        remove: (keyListenerRef)=>{
            if (!listenerArr.includes(keyListenerRef)) return;
            const last = listenerArr.length === 1;
            for(let i = 0; i < listenerArr.length; i++)if (listenerArr[i] === keyListenerRef) {
                listenerArr.splice(i, 1);
                break;
            }
            if (last) {
                document.removeEventListener("keydown", keyDown);
                document.removeEventListener("keyup", keyUp);
                window.removeEventListener("blur", blur);
            }
        },
        getIsDown: ()=>isDownObj,
        getCombo: ()=>comboArr
    };
})();
class KeyListener {
    constructor(p){
        this.onDown = p.onDown;
        this.onUp = p.onUp;
        this.onBlur = p.onBlur;
        this.ref = [
            this.onDown,
            this.onUp,
            this.onBlur
        ];
        globalKey.add(this.ref);
    }
    isPressed(keyStr) {
        if (!(keyStr in globalKey.getIsDown())) throw 'key "' + keyStr + '" not found';
        return globalKey.getIsDown()[keyStr];
    }
    getComboStr() {
        return globalKey.getCombo().join("+");
    }
    comboOnlyContains(keyStrArr) {
        for(let i = 0; i < globalKey.getCombo().length; i++){
            if (!keyStrArr.includes(globalKey.getCombo()[i])) return false;
        }
        return true;
    }
    destroy() {
        globalKey.remove(this.ref);
    }
}
function sameKeys(comboAStr, comboBStr) {
    return comboAStr.split("+").sort().join("+") === comboBStr.split("+").sort().join("+");
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5fbd0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * PointerListener - for pointer events, wheel events. uses fallbacks. ideally consistent behavior across browsers.
 * Has some workarounds for browser specific bugs. As browsers evolve this constructor should get smaller.
 */ parcelHelpers.export(exports, "PointerListener", ()=>PointerListener);
var _browser = require("../base/browser");
var _wheelCleaner = require("./wheel-cleaner");
var _pressureNormalizer = require("./pressure-normalizer");
// keeping track of pointers for movement fallback
const pointerArr = [];
function addPointer(event) {
    const pointerObj = {
        pointerId: event.pointerId,
        lastPageX: null,
        lastPageY: null
    };
    pointerArr.push(pointerObj);
    if (pointerArr.length > 15) pointerArr.shift();
    return pointerObj;
}
function getPointer(event) {
    for(let i = pointerArr.length - 1; i >= 0; i--){
        if (event.pointerId === pointerArr[i].pointerId) return pointerArr[i];
    }
    return null;
}
function getButtonStr(buttons) {
    switch(buttons){
        case 1:
            return "left";
        case 2:
            return "right";
        case 4:
            return "middle";
        default:
            return undefined;
    }
}
const pressureNormalizer = new (0, _pressureNormalizer.PressureNormalizer)();
const timeStampOffset = (0, _browser.eventUsesHighResTimeStamp)() ? 0 : -performance.timing.navigationStart;
const pointerDownEvt = (0, _browser.hasPointerEvents) ? "pointerdown" : "mousedown";
const pointerMoveEvt = (0, _browser.hasPointerEvents) ? "pointermove" : "mousemove";
const pointerUpEvt = (0, _browser.hasPointerEvents) ? "pointerup" : "mouseup";
const pointerCancelEvt = (0, _browser.hasPointerEvents) ? "pointercancel" : "mousecancel";
const pointerLeaveEvt = (0, _browser.hasPointerEvents) ? "pointerleave" : "mouseleave";
const pointerEnterEvt = (0, _browser.hasPointerEvents) ? "pointerenter" : "mouseenter";
/**
 * More trustworthy pointer attributes. that behave the same across browsers.
 * returns a new object. Also attaches itself to the orig event. -> event.corrected
 */ function correctPointerEvent(event) {
    if ("corrected" in event) return event.corrected;
    function determineButtons() {
        if (event.buttons !== undefined) return event.buttons;
        /*
                button -> buttons
        none:	undefined -> 0
        left:	0 -> 1
        middle:	1 -> 4
        right:	2 -> 2
        fourth:	3 -> 8
        fifth:	4 -> 16
         */ if (event.button !== undefined) return [
            1,
            4,
            2,
            8,
            16
        ][event.button];
        return 0;
    }
    const correctedObj = {
        pointerId: event.pointerId,
        pointerType: event.pointerType,
        pageX: event.pageX,
        pageY: event.pageY,
        clientX: event.clientX,
        clientY: event.clientY,
        movementX: event.movementX,
        movementY: event.movementY,
        timeStamp: event.timeStamp + timeStampOffset,
        pressure: pressureNormalizer.normalize(event.pressure),
        buttons: determineButtons(),
        button: event.button,
        coalescedArr: [],
        eventPreventDefault: ()=>event.preventDefault(),
        eventStopPropagation: ()=>event.stopPropagation()
    };
    event.corrected = correctedObj;
    let customPressure = null;
    if ("pointerId" in event) {
        if ("pressure" in event && event.buttons !== 0 && ([
            "mouse"
        ].includes(event.pointerType) || event.pointerType === "touch" && event.pressure === 0)) {
            correctedObj.pressure = 1;
            customPressure = 1;
        }
    } else {
        correctedObj.pointerId = 0;
        correctedObj.pointerType = "mouse";
        correctedObj.pressure = event.buttons !== 0 ? 1 : 0;
        customPressure = correctedObj.pressure;
    }
    if ((0, _browser.isFirefox) && event.pointerType != "mouse" && event.type === "pointermove" && event.buttons === 0) correctedObj.buttons = 1; // todo wrong if no buttons actually pressed
    let coalescedEventArr = [];
    if ("getCoalescedEvents" in event) coalescedEventArr = event.getCoalescedEvents();
    // chrome somehow movementX not same scale as pageX. todo: only chrome?
    // so make my own
    const pointerObj = getPointer(correctedObj) || addPointer(correctedObj);
    const totalLastX = pointerObj.lastPageX;
    const totalLastY = pointerObj.lastPageY;
    for(let i = 0; i < coalescedEventArr.length; i++){
        const eventItem = coalescedEventArr[i];
        correctedObj.coalescedArr.push({
            pageX: eventItem.pageX,
            pageY: eventItem.pageY,
            clientX: eventItem.clientX,
            clientY: eventItem.clientY,
            movementX: pointerObj.lastPageX === null ? 0 : eventItem.pageX - pointerObj.lastPageX,
            movementY: pointerObj.lastPageY === null ? 0 : eventItem.pageY - pointerObj.lastPageY,
            timeStamp: eventItem.timeStamp === 0 ? correctedObj.timeStamp : eventItem.timeStamp + timeStampOffset,
            pressure: customPressure === null ? pressureNormalizer.normalize(eventItem.pressure) : customPressure
        });
        pointerObj.lastPageX = eventItem.pageX;
        pointerObj.lastPageY = eventItem.pageY;
    }
    pointerObj.lastPageX = correctedObj.pageX;
    pointerObj.lastPageY = correctedObj.pageY;
    correctedObj.movementX = totalLastX === null ? 0 : pointerObj.lastPageX - totalLastX;
    correctedObj.movementY = totalLastY === null ? 0 : pointerObj.lastPageY - totalLastY;
    return correctedObj;
}
class PointerListener {
    getDragObj(pointerId) {
        for(let i = 0; i < this.dragObjArr.length; i++){
            if (pointerId === this.dragObjArr[i].pointerId) return this.dragObjArr[i];
        }
        return null;
    }
    removeDragObj(pointerId) {
        let removedDragObj = null;
        for(let i = 0; i < this.dragPointerIdArr.length; i++)if (this.dragPointerIdArr[i] === pointerId) {
            removedDragObj = this.dragObjArr[i];
            this.dragObjArr.splice(i, 1);
            this.dragPointerIdArr.splice(i, 1);
            i--;
        }
        return removedDragObj;
    }
    /**
     * Creates a value for onPointer, from a pointer event handler.
     */ createPointerOutEvent(typeStr, correctedEvent, custom) {
        const bounds = this.targetElement.getBoundingClientRect();
        const result = {
            type: typeStr,
            pointerId: correctedEvent.pointerId,
            pointerType: correctedEvent.pointerType,
            pageX: correctedEvent.pageX,
            pageY: correctedEvent.pageY,
            clientX: correctedEvent.clientX,
            clientY: correctedEvent.clientY,
            relX: correctedEvent.clientX - bounds.left + this.targetElement.scrollLeft,
            relY: correctedEvent.clientY - bounds.top + this.targetElement.scrollTop,
            dX: correctedEvent.movementX,
            dY: correctedEvent.movementY,
            time: correctedEvent.timeStamp,
            eventPreventDefault: correctedEvent.eventPreventDefault,
            eventStopPropagation: correctedEvent.eventStopPropagation,
            ...custom
        };
        if (typeStr === "pointermove") {
            result.coalescedArr = [];
            if (correctedEvent.coalescedArr.length > 1) {
                let coalescedItem;
                for(let i = 0; i < correctedEvent.coalescedArr.length; i++){
                    coalescedItem = correctedEvent.coalescedArr[i];
                    result.coalescedArr.push({
                        pageX: coalescedItem.pageX,
                        pageY: coalescedItem.pageY,
                        clientX: coalescedItem.clientX,
                        clientY: coalescedItem.clientY,
                        relX: coalescedItem.clientX - bounds.left + this.targetElement.scrollLeft,
                        relY: coalescedItem.clientY - bounds.top + this.targetElement.scrollTop,
                        dX: coalescedItem.movementX,
                        dY: coalescedItem.movementY,
                        time: coalescedItem.timeStamp
                    });
                }
            }
        }
        return result;
    }
    setupDocumentListeners() {
        this.windowOnPointerMove && document.addEventListener(pointerMoveEvt, this.windowOnPointerMove);
        this.windowOnPointerUp && document.addEventListener(pointerUpEvt, this.windowOnPointerUp);
        this.windowOnPointerLeave && document.addEventListener(pointerCancelEvt, this.windowOnPointerLeave);
        this.windowOnPointerLeave && document.addEventListener(pointerLeaveEvt, this.windowOnPointerLeave);
    }
    destroyDocumentListeners() {
        this.windowOnPointerMove && document.removeEventListener(pointerMoveEvt, this.windowOnPointerMove);
        this.windowOnPointerUp && document.removeEventListener(pointerUpEvt, this.windowOnPointerUp);
        this.windowOnPointerLeave && document.removeEventListener(pointerCancelEvt, this.windowOnPointerLeave);
        this.windowOnPointerLeave && document.removeEventListener(pointerLeaveEvt, this.windowOnPointerLeave);
    }
    // ---- public ----
    constructor(p){
        this.isDestroyed = false;
        this.isOverCounter = 0;
        // pointers that are pressing a button
        this.dragObjArr = [];
        this.dragPointerIdArr = [];
        // chrome input glitch workaround
        this.lastPointerType = null;
        this.didSkip = false;
        this.targetElement = p.target;
        this.onPointerCallback = p.onPointer;
        this.onWheelCallback = p.onWheel;
        this.onEnterLeaveCallback = p.onEnterLeave;
        this.maxPointers = Math.max(1, p.maxPointers || 1);
        this.wheelCleaner = new (0, _wheelCleaner.WheelCleaner)((cleanerEvent)=>{
            if (this.isDestroyed || !this.onWheelCallback) return;
            const bounds = this.targetElement.getBoundingClientRect();
            const whlEvent = {
                ...cleanerEvent,
                relX: cleanerEvent.clientX - bounds.left + this.targetElement.scrollLeft,
                relY: cleanerEvent.clientY - bounds.top + this.targetElement.scrollTop
            };
            this.onWheelCallback(whlEvent);
        });
        if (this.onPointerCallback) {
            this.onPointerMove = (event)=>{
                const correctedEvent = correctPointerEvent(event);
                const tempLastPointerType = this.lastPointerType;
                this.lastPointerType = correctedEvent.pointerType;
                if (this.dragPointerIdArr.includes(correctedEvent.pointerId) || this.dragPointerIdArr.length === this.maxPointers || correctedEvent.pointerType === "touch") {
                    this.didSkip = false;
                    return;
                }
                // chrome input glitch workaround - throws in a random mouse event with the wrong position when using a stylus
                if (!this.didSkip && correctedEvent.pointerType === "mouse" && tempLastPointerType === "pen") {
                    this.didSkip = true;
                    return;
                }
                this.didSkip = false;
                const outEvent = this.createPointerOutEvent("pointermove", correctedEvent);
                this.onPointerCallback && this.onPointerCallback(outEvent);
            };
            this.onPointerDown = (event, onSkipGlobal)=>{
                //BB.throwOut('pointerdown ' + event.pointerId + ' | ' + dragPointerIdArr.length);
                const correctedEvent = correctPointerEvent(event);
                ////console.log('debug: ' + event.pointerId + ' pointerdown');
                if (this.dragPointerIdArr.includes(correctedEvent.pointerId) || this.dragPointerIdArr.length === this.maxPointers || ![
                    1,
                    2,
                    4
                ].includes(correctedEvent.buttons)) //BB.throwOut('pointerdown ignored');
                return;
                //set up global listeners
                if (this.dragObjArr.length === 0 && !onSkipGlobal) this.setupDocumentListeners();
                const dragObj = {
                    pointerId: correctedEvent.pointerId,
                    pointerType: correctedEvent.pointerType,
                    downPageX: correctedEvent.pageX,
                    downPageY: correctedEvent.pageY,
                    buttons: correctedEvent.buttons,
                    lastPageX: correctedEvent.pageX,
                    lastPageY: correctedEvent.pageY,
                    lastTimeStamp: correctedEvent.timeStamp
                };
                this.dragObjArr.push(dragObj);
                this.dragPointerIdArr.push(correctedEvent.pointerId);
                const outEvent = this.createPointerOutEvent("pointerdown", correctedEvent, {
                    downPageX: correctedEvent.pageX,
                    downPageY: correctedEvent.pageY,
                    button: getButtonStr(correctedEvent.buttons),
                    pressure: correctedEvent.pressure
                });
                this.onPointerCallback && this.onPointerCallback(outEvent);
            };
            this.windowOnPointerMove = (event)=>{
                //BB.throwOut('pointermove ' + event.pointerId);
                const correctedEvent = correctPointerEvent(event);
                ////console.log('debug: ' + event.pointerId + ' GLOBALpointermove');
                if (!this.dragPointerIdArr.includes(correctedEvent.pointerId)) return;
                const dragObj = this.getDragObj(correctedEvent.pointerId);
                if (!dragObj) // todo need to handle this!
                return;
                //if pointer changes button its pressing -> turn into pointerup
                if (correctedEvent.buttons !== dragObj.buttons) {
                    //pointer up
                    //remove listener
                    if (this.dragObjArr.length === 1) this.destroyDocumentListeners();
                    this.removeDragObj(correctedEvent.pointerId);
                    const outEvent = this.createPointerOutEvent("pointerup", correctedEvent, {
                        downPageX: dragObj.downPageX,
                        downPageY: dragObj.downPageY
                    });
                    this.onPointerCallback && this.onPointerCallback(outEvent);
                    return;
                }
                // ipad likes to do this
                if (correctedEvent.pointerType === "pen" && correctedEvent.pageX === dragObj.lastPageX && correctedEvent.pageY === dragObj.lastPageY && correctedEvent.timeStamp === dragObj.lastTimeStamp) //ignore
                return;
                const outEvent = this.createPointerOutEvent("pointermove", correctedEvent, {
                    downPageX: dragObj.downPageX,
                    downPageY: dragObj.downPageY,
                    button: getButtonStr(correctedEvent.buttons),
                    pressure: correctedEvent.pressure
                });
                dragObj.lastPageX = correctedEvent.pageX;
                dragObj.lastPageY = correctedEvent.pageY;
                dragObj.lastTimeStamp = correctedEvent.timeStamp;
                this.onPointerCallback && this.onPointerCallback(outEvent);
            };
            this.windowOnPointerUp = (event)=>{
                //BB.throwOut('pointerup ' + event.pointerId);
                const correctedEvent = correctPointerEvent(event);
                ////console.log('debug: ' + event.pointerId + ' GLOBALpointerup');
                if (!this.dragPointerIdArr.includes(correctedEvent.pointerId)) return;
                //remove listener
                if (this.dragObjArr.length === 1) this.destroyDocumentListeners();
                const dragObj = this.removeDragObj(correctedEvent.pointerId);
                if (!dragObj) // todo need to handle this!
                return;
                const outEvent = this.createPointerOutEvent("pointerup", correctedEvent, {
                    downPageX: dragObj.downPageX,
                    downPageY: dragObj.downPageY
                });
                this.onPointerCallback && this.onPointerCallback(outEvent);
            };
            this.windowOnPointerLeave = (event)=>{
                //BB.throwOut('pointerleave ' + event.pointerId);
                const correctedEvent = correctPointerEvent(event);
                ////console.log('debug: ' + event.pointerId + ' onGlobalPointerLeave', event);
                if (!this.dragPointerIdArr.includes(correctedEvent.pointerId)) return;
                //remove listener
                if (this.dragObjArr.length === 1) this.destroyDocumentListeners();
                const dragObj = this.removeDragObj(correctedEvent.pointerId);
                if (!dragObj) // todo need to handle this!
                return;
                const outEvent = this.createPointerOutEvent("pointerup", correctedEvent, {
                    downPageX: dragObj.downPageX,
                    downPageY: dragObj.downPageY
                });
                this.onPointerCallback && this.onPointerCallback(outEvent);
            };
            this.targetElement.addEventListener(pointerMoveEvt, this.onPointerMove);
            this.targetElement.addEventListener(pointerDownEvt, this.onPointerDown);
            if (!(0, _browser.hasPointerEvents)) {
                const touchToFakePointer = (touch, touchEvent, isDown)=>{
                    return {
                        pointerId: touch.identifier,
                        pointerType: "touch",
                        pageX: touch.pageX,
                        pageY: touch.pageY,
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        button: isDown ? 0 : undefined,
                        buttons: isDown ? 1 : 0,
                        timeStamp: touchEvent.timeStamp,
                        target: touchEvent.target,
                        pressure: isDown ? 1 : 0,
                        preventDefault: ()=>touchEvent.preventDefault(),
                        stopPropagation: ()=>touchEvent.stopPropagation()
                    };
                };
                const handleTouch = (e, type)=>{
                    for(let i = 0; i < e.changedTouches.length; i++){
                        const touch = e.changedTouches[i];
                        const fakePointer = touchToFakePointer(touch, e, [
                            "start",
                            "move"
                        ].includes(type));
                        if (type === "start") this.onPointerDown(fakePointer, false);
                        else if (type === "move") this.windowOnPointerMove(fakePointer);
                        else if (type === "end") this.windowOnPointerUp(fakePointer);
                        else this.windowOnPointerLeave(fakePointer);
                    }
                };
                this.onTouchStart = (e)=>{
                    e.preventDefault();
                    handleTouch(e, "start");
                };
                this.onTouchMove = (e)=>{
                    handleTouch(e, "move");
                };
                this.onTouchEnd = (e)=>{
                    handleTouch(e, "end");
                };
                this.onTouchCancel = (e)=>{
                    handleTouch(e, "cancel");
                };
                this.targetElement.addEventListener("touchstart", this.onTouchStart);
                this.targetElement.addEventListener("touchmove", this.onTouchMove);
                this.targetElement.addEventListener("touchend", this.onTouchEnd);
                this.targetElement.addEventListener("touchcancel", this.onTouchCancel);
            }
        }
        if (this.onWheelCallback) {
            this.onWheel = (e)=>{
                this.wheelCleaner.process(e);
            };
            this.targetElement.addEventListener("wheel", this.onWheel);
        }
        if (this.onEnterLeaveCallback) {
            this.onPointerEnter = ()=>{
                this.isOverCounter++;
                this.onEnterLeaveCallback && this.onEnterLeaveCallback(true);
            };
            this.onPointerLeave = ()=>{
                this.isOverCounter--;
                this.onEnterLeaveCallback && this.onEnterLeaveCallback(false);
            };
            this.targetElement.addEventListener(pointerEnterEvt, this.onPointerEnter);
            this.targetElement.addEventListener(pointerLeaveEvt, this.onPointerLeave);
        }
        if (p.fixScribble) {
            //ipad scribble workaround https://developer.apple.com/forums/thread/662874
            this.onTouchMoveScribbleFix = (e)=>e.preventDefault();
            this.targetElement.addEventListener("touchmove", this.onTouchMoveScribbleFix);
        }
    }
    destroy() {
        if (this.isDestroyed) return;
        this.isDestroyed = true;
        this.onPointerEnter && this.targetElement.removeEventListener(pointerEnterEvt, this.onPointerEnter);
        this.onPointerLeave && this.targetElement.removeEventListener(pointerLeaveEvt, this.onPointerLeave);
        this.onPointerMove && this.targetElement.removeEventListener(pointerMoveEvt, this.onPointerMove);
        this.onPointerDown && this.targetElement.removeEventListener(pointerDownEvt, this.onPointerDown);
        this.onWheel && this.targetElement.removeEventListener("wheel", this.onWheel);
        this.destroyDocumentListeners();
        this.onTouchMoveScribbleFix && document.removeEventListener("touchmove", this.onTouchMoveScribbleFix);
        this.onTouchStart && this.targetElement.removeEventListener("touchstart", this.onTouchStart);
        this.onTouchMove && this.targetElement.removeEventListener("touchmove", this.onTouchMove);
        this.onTouchEnd && this.targetElement.removeEventListener("touchend", this.onTouchEnd);
        this.onTouchCancel && this.targetElement.removeEventListener("touchcancel", this.onTouchCancel);
    }
}

},{"../base/browser":"jZRZU","./wheel-cleaner":"a0xk7","./pressure-normalizer":"3bYRY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a0xk7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Filters wheel events. removes swipe scrolling and pinch scrolling that trackpads do. (as best as it can)
 * Normalizes regular scrolls.
 *
 * Why:
 * - trackpad scrolling is different from old school mouse scrolling
 * - but there is no way to learn from the browser if it's trackpad scrolling
 * - browsers don't even give access to the raw swiping or pinching movement, but some abstraction on top, making the scrolling
 *      continue an arbitrary amount, at an arbitrary scale
 * - each browser does this differently. So you can't offer a consistent/controlled experience
 *
 * - also trackpads are painful to draw with. So supporting a trackpad-based workflow makes not much sense.
 */ parcelHelpers.export(exports, "WheelCleaner", ()=>WheelCleaner);
const SEQUENCE_TIMEOUT_MS = 200;
class WheelCleaner {
    emit(delta) {
        if (this.position === null || this.sequenceUnit === null) return;
        this.callback({
            deltaY: Math.round(delta / this.sequenceUnit),
            pageX: this.position.pageX,
            pageY: this.position.pageY,
            clientX: this.position.clientX,
            clientY: this.position.clientY
        });
    }
    endSequence() {
        if (this.toEmitDelta !== null) {
            this.emit(this.toEmitDelta);
            this.toEmitDelta = null;
        }
        if (this.sequenceUnit !== null && !this.knownUnitArr.includes(this.sequenceUnit)) this.knownUnitArr.push(this.sequenceUnit);
        this.sequenceLength = 0;
        this.sequenceUnit = null;
    }
    // ---- public ----
    constructor(callback){
        this.callback = callback;
        this.knownUnitArr = [
            100
        ];
        this.sequenceLength = 0;
        this.sequenceUnit = null;
        this.toEmitDelta = null;
        this.position = null;
    }
    process(event) {
        this.position = {
            pageX: event.pageX,
            pageY: event.pageY,
            clientX: event.clientX,
            clientY: event.clientY
        };
        if (this.endSequenceTimeout) clearTimeout(this.endSequenceTimeout);
        this.endSequenceTimeout = setTimeout(()=>this.endSequence(), SEQUENCE_TIMEOUT_MS);
        //prep delta
        let delta = event.deltaY;
        if ("deltaMode" in event && event.deltaMode === 1) delta *= 100 / 3;
        const absDelta = Math.abs(delta);
        //sequence begins
        if (this.sequenceLength === 0) {
            this.sequenceLength++;
            if (absDelta < 50) //dirty - probably a swipe scroll or pinch scroll on trackpad
            return;
            this.sequenceUnit = absDelta;
            if (this.knownUnitArr.includes(this.sequenceUnit)) //we know this unit - emit right away
            this.emit(delta);
            else //unknown unit - wait until next event or sequence end, to have more certainty that it's clean
            this.toEmitDelta = delta;
            return;
        }
        if (this.sequenceUnit === null) {
            //previously determined dirty sequence
            this.toEmitDelta = null;
            return;
        }
        //sequence continues
        if (absDelta === 0) //ignore zero scroll
        return;
        if (absDelta === this.sequenceUnit || absDelta / this.sequenceUnit % 1 < 0.0001 // a multiple
        ) ;
        else if (this.sequenceUnit / absDelta % 1 < 0.0001) //unit was actually a multiple - update it
        this.sequenceUnit = absDelta;
        else if (absDelta !== this.sequenceUnit) {
            //not clean - delta is varying - probably a swipe scroll or pinch scroll on trackpad
            this.sequenceUnit = null;
            this.toEmitDelta = null;
            return;
        }
        if (this.toEmitDelta !== null) {
            this.emit(this.toEmitDelta);
            this.toEmitDelta = null;
        }
        this.emit(delta);
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3bYRY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * different devices/browsers have different pressure curves
 * pressure normalize attempts to achieve similar mapping
 *
 * pressure range [0, 1]
 */ parcelHelpers.export(exports, "PressureNormalizer", ()=>PressureNormalizer);
var _math = require("../math/math");
class PressureNormalizer {
    // ---- public ----
    normalize(pressure) {
        if (pressure === 0 || pressure === 1) return pressure;
        if (this.count < 60) {
            if (this.count === 0 || this.count === null) this.avgPressure = pressure;
            else this.avgPressure = (0, _math.mix)(pressure, this.avgPressure, 0.95);
            this.count++;
        } else if (!this.normalizeIsComplete) {
            this.normalizeIsComplete = true;
            //BB.throwOut('avg pressure decision!' + this.avgPressure);
            if (this.avgPressure < 0.13) this.normalizeFactor = 2.3;
        }
        return Math.pow(pressure, 1 / this.normalizeFactor);
    }
    constructor(){
        this.count = 0;
        this.avgPressure = 0 // float [0, 1]
        ;
        this.normalizeIsComplete = false;
        this.normalizeFactor = 1;
    }
}

},{"../math/math":"7w6MZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7w6MZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mix", ()=>mix);
parcelHelpers.export(exports, "dist", ()=>dist);
parcelHelpers.export(exports, "distSquared", ()=>distSquared);
parcelHelpers.export(exports, "lenSquared", ()=>lenSquared);
parcelHelpers.export(exports, "pointsToAngleRad", ()=>pointsToAngleRad);
parcelHelpers.export(exports, "pointsToAngleDeg", ()=>pointsToAngleDeg);
parcelHelpers.export(exports, "isInsideRect", ()=>isInsideRect);
parcelHelpers.export(exports, "clamp", ()=>clamp);
parcelHelpers.export(exports, "rotate", ()=>rotate);
parcelHelpers.export(exports, "rotateAround", ()=>rotateAround);
parcelHelpers.export(exports, "intDxy", ()=>intDxy);
/**
 * return closest even number
 * @param f
 */ parcelHelpers.export(exports, "roundEven", ()=>roundEven);
/**
 * return closest uneven number
 * @param f
 */ parcelHelpers.export(exports, "roundUneven", ()=>roundUneven);
/**
 * round number to certain precision.
 * round(1.2345, 2) = 1.23
 * round(1.2345, 0) = 0
 * round(123, -1) = 120
 *
 * @param f
 * @param digits
 */ parcelHelpers.export(exports, "round", ()=>round);
/**
 * update target so it includes bounds
 * @param target
 * @param bounds
 */ parcelHelpers.export(exports, "updateBounds", ()=>updateBounds);
/**
 * determine overlap of bounds with width&height
 */ parcelHelpers.export(exports, "boundsInArea", ()=>boundsInArea);
function mix(a, b, f) {
    return a * (1 - f) + b * f;
}
function dist(ax, ay, bx, by) {
    return Math.sqrt(Math.pow(ax - bx, 2) + Math.pow(ay - by, 2));
}
function distSquared(ax, ay, bx, by) {
    // faster because no square-root
    return Math.pow(ax - bx, 2) + Math.pow(ay - by, 2);
}
function lenSquared(x, y) {
    // faster because no square-root
    return x * x + y * y;
}
function pointsToAngleRad(p1, p2) {
    return Math.atan2(p2.y - p1.y, p2.x - p1.x);
}
function pointsToAngleDeg(p1, p2) {
    return pointsToAngleRad(p1, p2) * 180 / Math.PI;
}
function isInsideRect(p, rect) {
    return rect.x <= p.x && p.x <= rect.x + rect.width && rect.y <= p.y && p.y <= rect.y + rect.height;
}
function clamp(num, min, max) {
    return num < min ? min : num > max ? max : num;
}
function rotate(x, y, deg) {
    const theta = deg * (Math.PI / 180);
    const cs = Math.cos(theta);
    const sn = Math.sin(theta);
    return {
        x: x * cs - y * sn,
        y: x * sn + y * cs
    };
}
function rotateAround(center, point, deg) {
    const rot = rotate(point.x - center.x, point.y - center.y, deg);
    rot.x += center.x;
    rot.y += center.y;
    return rot;
}
function intDxy(remainder, fDx, fDy) {
    remainder.x += fDx;
    remainder.y += fDy;
    const dX = Math.round(remainder.x);
    const dY = Math.round(remainder.y);
    remainder.x -= dX;
    remainder.y -= dY;
    return {
        dX,
        dY
    };
}
function roundEven(f) {
    if (f % 1 === 0) {
        if (f % 2 === 0) return f;
        return f + 1;
    }
    const above = Math.ceil(f);
    const below = Math.floor(f);
    if (above % 2 === 0) return above;
    else return below;
}
function roundUneven(f) {
    if (f % 1 === 0) {
        if (f % 2 === 0) return f + 1;
        return f;
    }
    const above = Math.ceil(f);
    const below = Math.floor(f);
    if (above % 2 === 1) return above;
    else return below;
}
function round(f, digits) {
    const digitMult = Math.pow(10, digits);
    return Math.round(f /* + Number.EPSILON*/  * digitMult) / digitMult;
}
function updateBounds(target, bounds) {
    if (!bounds && !target) throw new Error("at least one param needs to be defined");
    if (!bounds) return target;
    if (!target) target = {
        x1: bounds.x1,
        y1: bounds.y1,
        x2: bounds.x2,
        y2: bounds.y2
    };
    else {
        target.x1 = Math.min(target.x1, bounds.x1);
        target.y1 = Math.min(target.y1, bounds.y1);
        target.x2 = Math.max(target.x2, bounds.x2);
        target.y2 = Math.max(target.y2, bounds.y2);
    }
    return target;
}
function boundsInArea(bounds, width, height) {
    if (!bounds) return undefined;
    const x1 = Math.max(0, bounds.x1);
    const y1 = Math.max(0, bounds.y1);
    const x2 = Math.min(width - 1, bounds.x2);
    const y2 = Math.min(height - 1, bounds.y2);
    if (x1 > x2 || y1 > y2) return undefined;
    return {
        x1,
        y1,
        x2,
        y2
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d7Vt7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "copyCanvas", ()=>copyCanvas);
parcelHelpers.export(exports, "ctx", ()=>ctx);
/**
 * Determine if we should disable imageSmoothing for transformation.
 * ImageSmoothing can make images blurry even when they're in the original scale and aligned with the pixelgrid.
 */ parcelHelpers.export(exports, "testShouldPixelate", ()=>testShouldPixelate);
/**
 * @param destCtx - the canvas that will be drawn on
 * @param transformImage - image that will be drawn on canvas
 * @param transform - {x, y, width, height, angle} - x and y are center of transformImage
 * @param bounds object - optional {x, y, width, height} - crop of transformImage in transformImage image space
 * @param pixelated
 */ parcelHelpers.export(exports, "drawTransformedImageWithBounds", ()=>drawTransformedImageWithBounds);
/**
 * all transformations are optional
 * center is the point around which will be scaled and rotated
 *
 * @param baseCanvas canvas - the canvas that will be drawn on
 * @param transformImage image|canvas - image that will be drawn on canvas
 * @param transformObj {center: {x, y}, scale: {x, y}, translate: {x, y}, angleDegree}
 */ parcelHelpers.export(exports, "drawTransformedImageOnCanvas", ()=>drawTransformedImageOnCanvas);
parcelHelpers.export(exports, "createCheckerCanvas", ()=>createCheckerCanvas);
parcelHelpers.export(exports, "createCheckerDataUrl", ()=>createCheckerDataUrl);
/**
 * smooth resize image
 * @param canvas canvas - will be resized (modified)
 * @param w
 * @param h
 * @param tmp1 canvas - optional, provide to save resources
 * @param tmp2 canvas - optional, provide to save resources
 */ parcelHelpers.export(exports, "resizeCanvas", ()=>resizeCanvas);
/**
 * puts naive greyscale version of image into alpha channel.
 * only writes a, doesn't write rgb
 * @param canvas
 */ parcelHelpers.export(exports, "convertToAlphaChannelCanvas", ()=>convertToAlphaChannelCanvas);
/**
 * Sometimes garbage collection is too slow, and canvases use up too much memory,
 * or in the worst case there is a hard to fix memory leak.
 * This function manually makes the canvas use as little memory as possible.
 */ parcelHelpers.export(exports, "freeCanvas", ()=>freeCanvas);
/**
 * Determine bounding box that describes all pixels which are not fully transparent.
 * Returns null if empty.
 *
 * @param context
 */ parcelHelpers.export(exports, "canvasBounds", ()=>canvasBounds);
var _createCanvas = require("./create-canvas");
var _base = require("./base");
function copyCanvas(canvas) {
    const resultCanvas = (0, _createCanvas.createCanvas)(canvas.width, canvas.height);
    const ctx = resultCanvas.getContext("2d");
    if (!ctx) throw new Error("2d context not supported or canvas already initialized");
    ctx.drawImage(canvas, 0, 0);
    return resultCanvas;
}
function ctx(canvas, options) {
    const ctx = canvas.getContext("2d", options);
    if (!ctx) throw new Error("couldn't get 2d context");
    return ctx;
}
function testShouldPixelate(transform, scaleX, scaleY) {
    if (![
        1,
        -1
    ].includes(scaleX) || ![
        1,
        -1
    ].includes(scaleY) || transform.width % 1 !== 0 || transform.height % 1 !== 0 || Math.abs(transform.angleDeg) % 90 !== 0) return false;
    const whSwapped = Math.abs(transform.angleDeg - 90) % 180 === 0;
    const width = whSwapped ? transform.height : transform.width;
    const height = whSwapped ? transform.width : transform.height;
    return (Math.abs(width) % 2 === 0 && transform.x % 1 === 0 || Math.abs(width) % 2 === 1 && transform.x % 1 === 0.5) && (Math.abs(height) % 2 === 0 && transform.y % 1 === 0 || Math.abs(height) % 2 === 1 && transform.y % 1 === 0.5);
}
function drawTransformedImageWithBounds(destCtx, transformImage, transform, bounds, pixelated) {
    if (!bounds) bounds = {
        x: 0,
        y: 0,
        width: transformImage.width,
        height: transformImage.height
    };
    destCtx.save();
    if (pixelated) destCtx.imageSmoothingEnabled = false;
    else {
        destCtx.imageSmoothingEnabled = true;
        destCtx.imageSmoothingQuality = "high";
    }
    destCtx.translate(transform.x, transform.y);
    destCtx.rotate(transform.angleDeg / 180 * Math.PI);
    destCtx.scale(transform.width > 0 ? 1 : -1, transform.height > 0 ? 1 : -1);
    destCtx.drawImage(transformImage, bounds.x, bounds.y, bounds.width, bounds.height, -Math.abs(transform.width) / 2, -Math.abs(transform.height) / 2, Math.abs(transform.width), Math.abs(transform.height));
    destCtx.restore();
}
function drawTransformedImageOnCanvas(baseCanvas, transformImage, transformObj) {
    transformObj = (0, _base.copyObj)(transformObj);
    if (!transformObj.center) transformObj.center = {
        x: transformImage.width / 2,
        y: transformImage.height / 2
    };
    if (!transformObj.scale) transformObj.scale = {
        x: 1,
        y: 1
    };
    if (!transformObj.angleDegree) transformObj.angleDegree = 0;
    if (!transformObj.translate) transformObj.translate = {
        x: 0,
        y: 0
    };
    const ctx = baseCanvas.getContext("2d");
    if (!ctx) throw new Error("2d context not supported or canvas already initialized");
    ctx.save();
    if (Math.abs(transformObj.scale.x - 1) > 0.000001 || Math.abs(transformObj.scale.y - 1) > 0.000001 || Math.abs(transformObj.angleDegree % 90) > 0.000001) {
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";
    } else ctx.imageSmoothingEnabled = false;
    ctx.translate(transformObj.translate.x, transformObj.translate.y);
    ctx.translate(transformObj.center.x, transformObj.center.y);
    ctx.rotate(transformObj.angleDegree / 180 * Math.PI);
    ctx.scale(transformObj.scale.x, transformObj.scale.y);
    ctx.translate(-transformObj.center.x, -transformObj.center.y);
    ctx.drawImage(transformImage, 0, 0, transformImage.width, transformImage.height);
    ctx.restore();
}
const createCheckerCanvas = function(size, isDark) {
    const canvas = (0, _createCanvas.createCanvas)();
    let ctx;
    if (size < 1) {
        canvas.width = 1;
        canvas.height = 1;
        ctx = canvas.getContext("2d");
        if (!ctx) throw new Error("2d context not supported or canvas already initialized");
        ctx.fillStyle = "rgb(128, 128, 128)";
        ctx.fillRect(0, 0, 1, 1);
    } else if (size > 200) {
        canvas.width = 401;
        canvas.height = 401;
    } else {
        canvas.width = size * 2;
        canvas.height = size * 2;
        ctx = canvas.getContext("2d");
        if (!ctx) throw new Error("2d context not supported or canvas already initialized");
        ctx.fillStyle = isDark ? "rgb(90, 90, 90)" : "rgb(255, 255, 255)";
        ctx.fillRect(0, 0, size * 2, size * 2);
        ctx.fillStyle = isDark ? "rgb(63, 63, 63)" : "rgb(200, 200, 200)";
        ctx.fillRect(0, 0, size, size);
        ctx.fillRect(size, size, size * 2, size * 2);
    }
    return canvas;
};
const createCheckerDataUrl = function() {
    const cache = {
        "8l": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAMElEQVQ4T2M8ceLEfwY8wNzcHJ80A+OoAcMiDP7//483HZw8eRJ/Ohg1gIFx6IcBAIhJUqnarXQ1AAAAAElFTkSuQmCC",
        "4l": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAYAAADED76LAAAAJ0lEQVQoU2M8ceLEfwYkYG5ujsxlYKSDgv///6O44eTJk6huoL0CAGsOKVVu8UYvAAAAAElFTkSuQmCC"
    };
    return function(size, callback, isDark) {
        const modeStr = isDark ? "d" : "l";
        function create(size) {
            size = parseInt("" + size);
            if (cache["" + size + modeStr]) return cache["" + size + modeStr];
            const canvas = createCheckerCanvas(size, isDark);
            const result = canvas.toDataURL("image/png");
            cache["" + size + modeStr] = result;
            return result;
        }
        if (callback) setTimeout(function() {
            callback(create(size));
        }, 1);
        else return create(size);
    };
}();
function resizeCanvas(canvas, w, h, tmp1, tmp2) {
    //determine base 2 exponents of old and new size
    function getBase2Obj(oldW, oldH, newW, newH) {
        const result = {
            oldWidthEx: Math.round(Math.log2(oldW)),
            oldHeightEx: Math.round(Math.log2(oldH)),
            newWidthEx: Math.ceil(Math.log2(newW)),
            newHeightEx: Math.ceil(Math.log2(newH))
        };
        result.oldWidthEx = Math.max(result.oldWidthEx, result.newWidthEx);
        result.oldHeightEx = Math.max(result.oldHeightEx, result.newHeightEx);
        return result;
    }
    if (!w || !h || w === canvas.width && h === canvas.height) return;
    w = Math.max(w, 1);
    h = Math.max(h, 1);
    if (w <= canvas.width && h <= canvas.height) {
        tmp1 = !tmp1 ? (0, _createCanvas.createCanvas)() : tmp1;
        tmp2 = !tmp2 ? (0, _createCanvas.createCanvas)() : tmp2;
        const base2 = getBase2Obj(canvas.width, canvas.height, w, h);
        //initially scale to a base of 2. unless new size is too close to old. e.g. sizing from 900 to 600
        tmp2.width = base2.oldWidthEx > base2.newWidthEx ? Math.pow(2, base2.oldWidthEx) : w;
        tmp2.height = base2.oldHeightEx > base2.newHeightEx ? Math.pow(2, base2.oldHeightEx) : h;
        tmp1.getContext("2d").save();
        tmp2.getContext("2d").save();
        let ew, eh;
        let buffer1 = tmp1, buffer2 = tmp2;
        ew = base2.oldWidthEx;
        eh = base2.oldHeightEx;
        let bufferCtx = buffer2.getContext("2d");
        bufferCtx.imageSmoothingEnabled = true;
        bufferCtx.imageSmoothingQuality = "high";
        bufferCtx.globalCompositeOperation = "copy";
        bufferCtx.drawImage(canvas, 0, 0, buffer2.width, buffer2.height);
        let currentWidth = buffer2.width;
        let currentHeight = buffer2.height;
        //stepwise half the size
        for(; ew > base2.newWidthEx || eh > base2.newHeightEx; ew--, eh--){
            bufferCtx = buffer1.getContext("2d");
            bufferCtx.imageSmoothingEnabled = true;
            bufferCtx.imageSmoothingQuality = "high";
            bufferCtx.globalCompositeOperation = "copy";
            const newWidth = ew > base2.newWidthEx ? currentWidth / 2 : currentWidth;
            const newHeight = eh > base2.newHeightEx ? currentHeight / 2 : currentHeight;
            //buffer also needs to be properly sized, unfortunately
            buffer1.width = newWidth;
            buffer1.height = newHeight;
            bufferCtx.drawImage(buffer2, 0, 0, currentWidth, currentHeight, 0, 0, newWidth, newHeight);
            currentWidth = newWidth;
            currentHeight = newHeight;
            //swap
            const tmp = buffer1;
            buffer1 = buffer2;
            buffer2 = tmp;
        }
        //when no longer can be halved, bring to target size
        canvas.width = w;
        canvas.height = h;
        const canvasCtx = canvas.getContext("2d");
        canvasCtx.save();
        canvasCtx.imageSmoothingEnabled = true;
        canvasCtx.imageSmoothingQuality = "high";
        canvasCtx.drawImage(buffer2, 0, 0, currentWidth, currentHeight, 0, 0, w, h);
        canvasCtx.restore();
        tmp1.getContext("2d").restore();
        tmp2.getContext("2d").restore();
    } else if (w >= canvas.width && h >= canvas.height) {
        tmp1 = !tmp1 ? (0, _createCanvas.createCanvas)() : tmp1;
        tmp1.width = w;
        tmp1.height = h;
        const tmp1Ctx = tmp1.getContext("2d");
        tmp1Ctx.save();
        tmp1Ctx.imageSmoothingEnabled = true;
        tmp1Ctx.imageSmoothingQuality = "high";
        tmp1Ctx.drawImage(canvas, 0, 0, w, h);
        tmp1Ctx.restore();
        canvas.width = w;
        canvas.height = h;
        canvas.getContext("2d").drawImage(tmp1, 0, 0);
    } else {
        resizeCanvas(canvas, w, canvas.height, tmp1, tmp2);
        resizeCanvas(canvas, w, h, tmp1, tmp2);
    }
}
function convertToAlphaChannelCanvas(canvas) {
    const imdat = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
    for(let i = 0; i < imdat.data.length; i += 4){
        if (imdat.data[i + 3] === 0) continue;
        imdat.data[i + 3] = (imdat.data[i] + imdat.data[i + 1] + imdat.data[i + 2]) / 3 * (imdat.data[i + 3] / 255);
    }
    canvas.getContext("2d").putImageData(imdat, 0, 0);
}
function freeCanvas(canvas) {
    canvas.width = 1;
    canvas.height = 1;
    canvas.remove();
}
function canvasBounds(context) {
    const boundsObj = {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    };
    {
        const tempBounds = {
            x1: undefined,
            y1: undefined,
            x2: undefined,
            y2: undefined
        };
        const imdat = context.getImageData(0, 0, context.canvas.width, context.canvas.height);
        if (imdat.data[3] > 0 && imdat.data[imdat.data.length - 1] > 0) {
            tempBounds.x1 = 0;
            tempBounds.y1 = 0;
            tempBounds.x2 = context.canvas.width - 1;
            tempBounds.y2 = context.canvas.height - 1;
        } else {
            for(let i = 3; i < imdat.data.length; i += 4)if (imdat.data[i] > 0) {
                const x = (i - 3) / 4 % context.canvas.width;
                const y = Math.floor((i - 3) / 4 / context.canvas.width);
                if (tempBounds.x1 === undefined || tempBounds.x1 > x) tempBounds.x1 = x;
                if (tempBounds.y1 === undefined) tempBounds.y1 = y;
                if (tempBounds.x2 === undefined || tempBounds.x2 < x) tempBounds.x2 = x;
                if (tempBounds.y2 === undefined || tempBounds.y2 < y) tempBounds.y2 = y;
            }
        }
        if (tempBounds.x1 === undefined || tempBounds.y1 === undefined || tempBounds.x2 === undefined || tempBounds.y2 === undefined) return undefined;
        boundsObj.x = tempBounds.x1;
        boundsObj.y = tempBounds.y1;
        boundsObj.width = tempBounds.x2 - tempBounds.x1 + 1;
        boundsObj.height = tempBounds.y2 - tempBounds.y1 + 1;
    }
    return boundsObj;
}

},{"./create-canvas":"4BLUK","./base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4BLUK":[function(require,module,exports) {
/*window['canvases'] = [];

window['printCanvases'] = () => {
    let total = 0;

    console.log(window['canvases'].map(item => {
        total += item.width * item.height;
        return {w: item.width, h: item.height};
    }));

    console.log('total: ' + (total * 4 / 1000 / 1000) + 'mb');
};*/ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createCanvas", ()=>createCanvas);
function createCanvas(w, h) {
    const result = document.createElement("canvas");
    if (w && h) {
        result.width = w;
        result.height = h;
    }
    // window['canvases'].push(result);
    return result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k5NsM":[function(require,module,exports) {
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Matrix_math_for_the_web
// not optimized
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Matrix", ()=>Matrix);
function getIdentity() {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
// point • matrix
function multiplyMatrixAndPoint(matrix, point) {
    return [
        point[0] * matrix[0] + point[1] * matrix[4] + point[2] * matrix[8] + point[3] * matrix[12],
        point[0] * matrix[1] + point[1] * matrix[5] + point[2] * matrix[9] + point[3] * matrix[13],
        point[0] * matrix[2] + point[1] * matrix[6] + point[2] * matrix[10] + point[3] * matrix[14],
        point[0] * matrix[3] + point[1] * matrix[7] + point[2] * matrix[11] + point[3] * matrix[15]
    ];
}
//matrixB • matrixA
function multiplyMatrices(matrixA, matrixB) {
    // Slice the second matrix up into rows
    const row0 = [
        matrixB[0],
        matrixB[1],
        matrixB[2],
        matrixB[3]
    ];
    const row1 = [
        matrixB[4],
        matrixB[5],
        matrixB[6],
        matrixB[7]
    ];
    const row2 = [
        matrixB[8],
        matrixB[9],
        matrixB[10],
        matrixB[11]
    ];
    const row3 = [
        matrixB[12],
        matrixB[13],
        matrixB[14],
        matrixB[15]
    ];
    // Multiply each row by matrixA
    const result0 = multiplyMatrixAndPoint(matrixA, row0);
    const result1 = multiplyMatrixAndPoint(matrixA, row1);
    const result2 = multiplyMatrixAndPoint(matrixA, row2);
    const result3 = multiplyMatrixAndPoint(matrixA, row3);
    // Turn the result rows back into a single matrix
    return [
        result0[0],
        result0[1],
        result0[2],
        result0[3],
        result1[0],
        result1[1],
        result1[2],
        result1[3],
        result2[0],
        result2[1],
        result2[2],
        result2[3],
        result3[0],
        result3[1],
        result3[2],
        result3[3]
    ];
}
function createTranslationMatrix(x, y) {
    return [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        x,
        y,
        0,
        1
    ];
}
function createRotationMatrix(angleRad) {
    //let angleRad = angleDeg / 360 * 2 * Math.PI;
    return [
        Math.cos(-angleRad),
        -Math.sin(-angleRad),
        0,
        0,
        Math.sin(-angleRad),
        Math.cos(-angleRad),
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
function createScaleMatrix(f) {
    return [
        f,
        0,
        0,
        0,
        0,
        f,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ];
}
const Matrix = Object.freeze({
    getIdentity,
    multiplyMatrixAndPoint,
    multiplyMatrices,
    createTranslationMatrix,
    createRotationMatrix,
    createScaleMatrix
});

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eFVNh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Vec2", ()=>Vec2);
const Vec2 = {
    add: function(p1, p2) {
        return {
            x: p1.x + p2.x,
            y: p1.y + p2.y
        };
    },
    sub: function(p1, p2) {
        return {
            x: p1.x - p2.x,
            y: p1.y - p2.y
        };
    },
    nor: function(p) {
        const len = Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2));
        return {
            x: p.x / len,
            y: p.y / len
        };
    },
    len: function(p) {
        return Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2));
    },
    dist: function(p1, p2) {
        return Vec2.len(Vec2.sub(p1, p2));
    },
    mul: function(p, s) {
        return {
            x: p.x * s,
            y: p.y * s
        };
    },
    angle: function(p1, p2) {
        return Math.atan2(p2.y - p1.y, p2.x - p1.x);
    },
    dot: function(a, b) {
        const aArr = [
            a.x,
            a.y
        ];
        const bArr = [
            b.x,
            b.y
        ];
        return aArr.map((x, i)=>aArr[i] * bArr[i]).reduce((m, n)=>m + n);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ewgfM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "projectPointOnLine", ()=>projectPointOnLine);
/**
 * Operations on a line made up of points
 */ parcelHelpers.export(exports, "PointLine", ()=>PointLine);
/**
 * Each instance is one line made up of bezier interpolated segments.
 * You feed it points. It calculates control points on its own, and the resulting curve.
 */ parcelHelpers.export(exports, "BezierLine", ()=>BezierLine);
/**
 * from SplineInterpolator.cs in the Paint.NET source code
 */ parcelHelpers.export(exports, "SplineInterpolator", ()=>SplineInterpolator);
/**
 * input for a spline, following curve of quadratic function x^2 [0 - 1]
 * returns [[0, startVal], ..., [1, endVal]]
 * @param startVal
 * @param endVal
 * @param stepSize
 */ parcelHelpers.export(exports, "quadraticSplineInput", ()=>quadraticSplineInput);
var _vec2 = require("./vec2");
var _math = require("./math");
var _base = require("../base/base");
const projectPointOnLine = function(lineStart, lineEnd, p) {
    let x, y;
    if (lineStart.x === lineEnd.x) {
        x = lineStart.x;
        y = p.y;
        return {
            x: x,
            y: y
        };
    }
    const m = (lineEnd.y - lineStart.y) / (lineEnd.x - lineStart.x);
    const b = lineStart.y - m * lineStart.x;
    x = (m * p.y + p.x - m * b) / (m * m + 1);
    y = (m * m * p.y + m * p.x + b) / (m * m + 1);
    return {
        x: x,
        y: y
    };
};
class PointLine {
    // ---- public ----
    constructor(p){
        this.segmentArr = [];
        for(let i = 0; i < p.points.length; i++)((i)=>{
            let length = 0;
            if (i < p.points.length - 1) length = (0, _math.dist)(p.points[i].x, p.points[i].y, p.points[i + 1].x, p.points[i + 1].y);
            this.segmentArr[i] = {
                x: p.points[i].x,
                y: p.points[i].y,
                length: length
            };
        })(i);
    }
    // ---- interface ----
    /**
     * returns point when traveling *dist* along the line, > 0
     * @param dist
     */ getAtDist(dist) {
        let remainder = Math.min(this.getLength(), dist);
        let i = 0;
        for(; remainder > this.segmentArr[i].length && i < this.segmentArr.length - 2; i++)remainder -= this.segmentArr[i].length;
        const fac = Math.min(1, Math.max(0, remainder / this.segmentArr[i].length));
        return {
            x: this.segmentArr[i].x * (1 - fac) + this.segmentArr[i + 1].x * fac,
            y: this.segmentArr[i].y * (1 - fac) + this.segmentArr[i + 1].y * fac
        };
    }
    /**
     * total length of line
     */ getLength() {
        let result = 0;
        for(let i = 0; i < this.segmentArr.length - 1; i++)result += this.segmentArr[i].length;
        return result;
    }
}
class BezierLine {
    /**
     * creates bezier curve from control points
     * @param p1 - control point 1 {x: float, y: float}
     * @param p2 - control point 2 {x: float, y: float}
     * @param p3 - control point 3 {x: float, y: float}
     * @param p4 - control point 4 {x: float, y: float}
     * @param resolution - int
     * @returns bezier curve made up of points {x: float, y: float}
     */ getBezierPoints(p1, p2, p3, p4, resolution) {
        const curvePoints = [];
        let t;
        for(let i = 0; i <= resolution; i++){
            t = i / resolution;
            curvePoints[curvePoints.length] = {
                x: Math.pow(1 - t, 3) * p1.x + 3 * Math.pow(1 - t, 2) * t * p2.x + 3 * (1 - t) * Math.pow(t, 2) * p3.x + Math.pow(t, 3) * p4.x,
                y: Math.pow(1 - t, 3) * p1.y + 3 * Math.pow(1 - t, 2) * t * p2.y + 3 * (1 - t) * Math.pow(t, 2) * p3.y + Math.pow(t, 3) * p4.y
            };
        }
        return curvePoints;
    }
    // ---- public ----
    constructor(){
        this.lastDot = 0;
        this.pointArr = [];
    }
    // ---- interface ----
    /**
     * Add new point to line. "Drawn" line will go until the previous point.
     *
     * @param x - coord of new point
     * @param y
     * @param spacing - space between each step
     * @param callback - calls for each step
     * @param controlsCallback - calls that callback with the bezier control points
     */ add(x, y, spacing, callback, controlsCallback) {
        if (this.lastPoint && x === this.lastPoint.x && y === this.lastPoint.y) return;
        this.lastPoint = {
            x,
            y
        };
        this.pointArr[this.pointArr.length] = {
            x,
            y,
            spacing
        };
        //calculate directions
        if (this.pointArr.length === 1) {
            this.lastSpacing = spacing;
            return;
        } else if (this.pointArr.length === 2) {
            this.pointArr[0].dir = (0, _vec2.Vec2).nor((0, _vec2.Vec2).sub(this.pointArr[1], this.pointArr[0]));
            this.lastDot = spacing;
            this.lastSpacing = spacing;
            return;
        } else {
            const pointM1 = this.pointArr[this.pointArr.length - 1];
            const pointM2 = this.pointArr[this.pointArr.length - 2];
            const pointM3 = this.pointArr[this.pointArr.length - 3];
            pointM2.dir = (0, _vec2.Vec2).nor((0, _vec2.Vec2).sub(pointM1, pointM3));
            if (isNaN(pointM2.dir.x) || isNaN(pointM2.dir.y)) //when xy -3 == -1
            pointM2.dir = (0, _base.copyObj)(pointM3.dir);
        }
        //get bezier curve
        const a = this.pointArr[this.pointArr.length - 3];
        const b = this.pointArr[this.pointArr.length - 2];
        const p1 = a;
        const p2 = (0, _vec2.Vec2).add(a, (0, _vec2.Vec2).mul(a.dir, (0, _vec2.Vec2).dist(a, b) / 4));
        const p3 = (0, _vec2.Vec2).sub(b, (0, _vec2.Vec2).mul(b.dir, (0, _vec2.Vec2).dist(a, b) / 4));
        const p4 = b;
        let pointLine;
        if (callback) {
            const curvePoints = this.getBezierPoints(p1, p2, p3, p4, 20);
            pointLine = new PointLine({
                points: curvePoints
            });
        } else pointLine = new PointLine({
            points: [
                p1,
                p4
            ]
        });
        //iterate over curve with spacing and callback
        const len = pointLine.getLength();
        let tempSpacing = (0, _math.mix)(this.lastSpacing, spacing, (0, _math.clamp)(this.lastDot / len, 0, 1));
        let d = this.lastDot;
        for(; d <= len; d += tempSpacing){
            tempSpacing = (0, _math.mix)(this.lastSpacing, spacing, (0, _math.clamp)(d / len, 0, 1));
            const point = pointLine.getAtDist(d);
            const angle = this.lastCallbackPoint ? (0, _math.pointsToAngleDeg)(this.lastCallbackPoint, point) : undefined;
            if (callback) callback({
                x: point.x,
                y: point.y,
                t: d / len,
                angle: angle,
                dAngle: this.lastCallbackPoint ? angle - this.lastAngle : 0
            });
            this.lastCallbackPoint = point;
            this.lastAngle = angle;
        }
        if (callback) this.lastDot = d - len;
        else {
            this.lastDot = 0;
            controlsCallback && controlsCallback({
                p1: p1,
                p2: p2,
                p3: p3,
                p4: p4
            });
        }
        this.lastSpacing = spacing;
    }
    addFinal(spacing, callback, controlsCallback) {
        if (this.pointArr.length < 2) return;
        const p1 = this.pointArr[this.pointArr.length - 2];
        const p2 = this.pointArr[this.pointArr.length - 1];
        const newP = (0, _vec2.Vec2).add(p2, (0, _vec2.Vec2).sub(p2, p1));
        this.add(newP.x, newP.y, spacing, callback, controlsCallback);
    }
}
class SplineInterpolator {
    // ---- public ----
    constructor(points){
        const n = points.length;
        this.xa = [];
        this.ya = [];
        this.u = [];
        this.y2 = [];
        let i;
        this.first = points[0][0];
        this.last = points[points.length - 1][0];
        points.sort(function(a, b) {
            return a[0] - b[0];
        });
        for(i = 0; i < n; i++){
            this.xa.push(points[i][0]);
            this.ya.push(points[i][1]);
        }
        this.u[0] = 0;
        this.y2[0] = 0;
        for(i = 1; i < n - 1; ++i){
            // This is the decomposition loop of the tridiagonal algorithm.
            // y2 and u are used for temporary storage of the decomposed factors.
            const wx = this.xa[i + 1] - this.xa[i - 1];
            const sig = (this.xa[i] - this.xa[i - 1]) / wx;
            const p = sig * this.y2[i - 1] + 2.0;
            this.y2[i] = (sig - 1.0) / p;
            const ddydx = (this.ya[i + 1] - this.ya[i]) / (this.xa[i + 1] - this.xa[i]) - (this.ya[i] - this.ya[i - 1]) / (this.xa[i] - this.xa[i - 1]);
            this.u[i] = (6.0 * ddydx / wx - sig * this.u[i - 1]) / p;
        }
        this.y2[n - 1] = 0;
        // This is the backsubstitution loop of the tridiagonal algorithm
        for(i = n - 2; i >= 0; --i)this.y2[i] = this.y2[i] * this.y2[i + 1] + this.u[i];
    }
    // ---- interface ----
    getFirstX() {
        return this.first;
    }
    getLastX() {
        return this.last;
    }
    interpolate(x) {
        const n = this.ya.length;
        let klo = 0;
        let khi = n - 1;
        // We will find the right place in the table by means of
        // bisection. This is optimal if sequential calls to this
        // routine are at random values of x. If sequential calls
        // are in order, and closely spaced, one would do better
        // to store previous values of klo and khi.
        while(khi - klo > 1){
            const k = khi + klo >> 1;
            if (this.xa[k] > x) khi = k;
            else klo = k;
        }
        const h = this.xa[khi] - this.xa[klo];
        const a = (this.xa[khi] - x) / h;
        const b = (x - this.xa[klo]) / h;
        // Cubic spline polynomial is now evaluated.
        return a * this.ya[klo] + b * this.ya[khi] + ((a * a * a - a) * this.y2[klo] + (b * b * b - b) * this.y2[khi]) * (h * h) / 6.0;
    }
    /**
     * find x to y. simply by stepping through. suboptimal, so don't call often.
     * searches in x 0-1 range
     */ findX(y, resolution) {
        let x;
        let dist;
        for(let i = 0; i <= resolution; i++){
            const tempX = i / resolution;
            const tempY = this.interpolate(tempX);
            if (x === undefined) {
                x = tempX;
                dist = Math.abs(tempY - y);
                continue;
            }
            const tempDist = Math.abs(tempY - y);
            if (tempDist < dist) {
                x = tempX;
                dist = tempDist;
            } else break;
        }
        return x;
    }
}
function quadraticSplineInput(startVal, endVal, stepSize) {
    function round(v, dec) {
        return Math.round(v * Math.pow(10, dec)) / Math.pow(10, dec);
    }
    const resultArr = [];
    for(let i = 0; i <= 1; i += stepSize)resultArr.push([
        round(i, 4),
        round(startVal + Math.pow(i, 2) * (endVal - startVal), 4)
    ]);
    return resultArr;
}

},{"./vec2":"eFVNh","./math":"7w6MZ","../base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iVNo9":[function(require,module,exports) {
// based on js color conversion http://www.webtoolkit.info/
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "HSV", ()=>HSV);
parcelHelpers.export(exports, "RGB", ()=>RGB);
parcelHelpers.export(exports, "CMYK", ()=>CMYK);
parcelHelpers.export(exports, "ColorConverter", ()=>ColorConverter);
parcelHelpers.export(exports, "testIsWhiteBestContrast", ()=>testIsWhiteBestContrast);
class HSV {
    constructor(h, s, v){
        this.h = Math.max(0, Math.min(360, h));
        this.s = Math.max(0.001, Math.min(100, s)); //bug when 0
        this.v = Math.max(0, Math.min(100, v));
    }
}
class RGB {
    constructor(r, g, b){
        this.r = Math.max(0, Math.min(255, r));
        this.g = Math.max(0, Math.min(255, g));
        this.b = Math.max(0, Math.min(255, b));
    }
}
class CMYK {
    constructor(c, m, y, k){
        this.c = Math.max(0, Math.min(100, c));
        this.m = Math.max(0, Math.min(100, m));
        this.y = Math.max(0, Math.min(100, y));
        this.k = Math.max(0, Math.min(100, k));
    }
}
const ColorConverter = {
    _RGBtoHSV: function(RGB) {
        const result = new HSV(0, 0, 0);
        const r = RGB.r / 255;
        const g = RGB.g / 255;
        const b = RGB.b / 255;
        const minVal = Math.min(r, g, b);
        const maxVal = Math.max(r, g, b);
        const delta = maxVal - minVal;
        result.v = maxVal;
        if (delta == 0) {
            result.h = 0;
            result.s = 0;
        } else {
            result.s = delta / maxVal;
            const del_R = ((maxVal - r) / 6 + delta / 2) / delta;
            const del_G = ((maxVal - g) / 6 + delta / 2) / delta;
            const del_B = ((maxVal - b) / 6 + delta / 2) / delta;
            if (r == maxVal) result.h = del_B - del_G;
            else if (g == maxVal) result.h = 1 / 3 + del_R - del_B;
            else if (b == maxVal) result.h = 2 / 3 + del_G - del_R;
            if (result.h < 0) result.h += 1;
            if (result.h > 1) result.h -= 1;
        }
        result.h = Math.round(result.h * 360);
        result.s = Math.round(result.s * 100);
        result.v = Math.round(result.v * 100);
        return result;
    },
    _HSVtoRGB: function(HSV) {
        const result = new RGB(0, 0, 0);
        let var_h, var_i, var_1, var_2, var_3, var_r, var_g, var_b;
        const h = HSV.h / 360 % 1;
        const s = HSV.s / 100;
        const v = HSV.v / 100;
        if (s == 0) {
            result.r = v * 255;
            result.g = v * 255;
            result.b = v * 255;
        } else {
            var_h = h * 6;
            var_i = Math.floor(var_h);
            var_1 = v * (1 - s);
            var_2 = v * (1 - s * (var_h - var_i));
            var_3 = v * (1 - s * (1 - (var_h - var_i)));
            if (var_i == 0) {
                var_r = v;
                var_g = var_3;
                var_b = var_1;
            } else if (var_i == 1) {
                var_r = var_2;
                var_g = v;
                var_b = var_1;
            } else if (var_i == 2) {
                var_r = var_1;
                var_g = v;
                var_b = var_3;
            } else if (var_i == 3) {
                var_r = var_1;
                var_g = var_2;
                var_b = v;
            } else if (var_i == 4) {
                var_r = var_3;
                var_g = var_1;
                var_b = v;
            } else {
                var_r = v;
                var_g = var_1;
                var_b = var_2;
            }
            result.r = var_r * 255;
            result.g = var_g * 255;
            result.b = var_b * 255;
            result.r = Math.round(result.r);
            result.g = Math.round(result.g);
            result.b = Math.round(result.b);
        }
        return result;
    },
    _CMYKtoRGB: function(CMYK) {
        const result = new RGB(0, 0, 0);
        const c = CMYK.c / 100;
        const m = CMYK.m / 100;
        const y = CMYK.y / 100;
        const k = CMYK.k / 100;
        result.r = 1 - Math.min(1, c * (1 - k) + k);
        result.g = 1 - Math.min(1, m * (1 - k) + k);
        result.b = 1 - Math.min(1, y * (1 - k) + k);
        result.r = Math.round(result.r * 255);
        result.g = Math.round(result.g * 255);
        result.b = Math.round(result.b * 255);
        return result;
    },
    _RGBtoCMYK: function(RGB) {
        const result = new CMYK(0, 0, 0, 0);
        const r = RGB.r / 255;
        const g = RGB.g / 255;
        const b = RGB.b / 255;
        result.k = Math.min(1 - r, 1 - g, 1 - b);
        result.c = (1 - r - result.k) / (1 - result.k);
        result.m = (1 - g - result.k) / (1 - result.k);
        result.y = (1 - b - result.k) / (1 - result.k);
        result.c = Math.round(result.c * 100);
        result.m = Math.round(result.m * 100);
        result.y = Math.round(result.y * 100);
        result.k = Math.round(result.k * 100);
        return result;
    },
    toRGB: function(o) {
        if (o instanceof RGB) return o;
        if (o instanceof HSV) return this._HSVtoRGB(o);
        if (o instanceof CMYK) return this._CMYKtoRGB(o);
        throw new Error("unknown type");
    },
    toHSV: function(o) {
        if (o instanceof HSV) return o;
        if (o instanceof RGB) return this._RGBtoHSV(o);
        if (o instanceof CMYK) return this._RGBtoHSV(this._CMYKtoRGB(o));
        throw new Error("unknown type");
    },
    toCMYK: function(o) {
        if (o instanceof CMYK) return o;
        if (o instanceof RGB) return this._RGBtoCMYK(o);
        if (o instanceof HSV) return this._RGBtoCMYK(this._HSVtoRGB(o));
        throw new Error("unknown type");
    },
    toHexString: function(o) {
        if (o instanceof RGB || "r" in o && "g" in o && "b" in o) {
            let ha = parseInt("" + o.r).toString(16);
            let hb = parseInt("" + o.g).toString(16);
            let hc = parseInt("" + o.b).toString(16);
            if (ha.length == 1) ha = "0" + ha;
            if (hb.length == 1) hb = "0" + hb;
            if (hc.length == 1) hc = "0" + hc;
            return ha + hb + hc;
        }
        return "#000";
    },
    toRgbStr: function(rgbObj) {
        return "rgb(" + Math.round(rgbObj.r) + ", " + Math.round(rgbObj.g) + ", " + Math.round(rgbObj.b) + ")";
    },
    toRgbaStr: function(rgbaObj) {
        return "rgba(" + Math.round(rgbaObj.r) + ", " + Math.round(rgbaObj.g) + ", " + Math.round(rgbaObj.b) + ", " + rgbaObj.a + ")";
    },
    hexToRGB: function(hexStr) {
        hexStr = hexStr.trim();
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hexStr = hexStr.replace(shorthandRegex, function(m, r, g, b) {
            return r + r + g + g + b + b;
        });
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hexStr);
        return result ? new RGB(parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16)) : undefined;
    }
};
function testIsWhiteBestContrast(rgbObj) {
    return rgbObj.r * 0.299 + rgbObj.g * 0.587 + rgbObj.b * 0.114 < 125;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2nyzl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "appendTextDiv", ()=>appendTextDiv);
/**
 * Is an input element focused.
 * Set attribute "data-ignore-focus" to "true" if its focus should be ignored.
 *
 * @param getAll - check all, even those with "data-ignore-focus" = "true"
 */ parcelHelpers.export(exports, "isInputFocused", ()=>isInputFocused);
parcelHelpers.export(exports, "unfocusAnyInput", ()=>unfocusAnyInput);
/**
 * clears text selection in window
 */ parcelHelpers.export(exports, "clearSelection", ()=>clearSelection);
parcelHelpers.export(exports, "makeUnfocusable", ()=>makeUnfocusable);
// window['els'] = els;
/**
 *
 * Create DOM element - div by default
 * params = {
 * 	    parent: someOtherDiv,
 * 	    css: {
 * 		    width: "500px",
 * 		    backgroundColor: "#fff"
 * 	    },
 * 	    content: "test", //or  content: [divA, divB, divC]   or content: someDiv
 * 	    className: "bla",
 *      id: "bla"
 * }
 *
 *  If onClick or onChange is used, then BB.destroyEl MUST be called
 *  to prevent a memory leak.
 *
 * @param params
 */ parcelHelpers.export(exports, "el", ()=>el);
/**
 * removes event listeners for Elements created via el()
 * @param el
 */ parcelHelpers.export(exports, "destroyEl", ()=>destroyEl);
var _base = require("./base");
var _bb = require("../bb");
function appendTextDiv(target, text) {
    const div = document.createElement("div");
    div.innerHTML = text;
    target.append(div);
    return div;
}
function isInputFocused(getAll = false) {
    const result = !!document.activeElement && [
        "INPUT",
        "TEXTAREA",
        "SELECT"
    ].includes(document.activeElement.tagName);
    if (getAll) return result;
    else return result && !document.activeElement?.getAttribute("data-ignore-focus");
}
function unfocusAnyInput() {
    if (isInputFocused(true)) {
        /*
            Unfocus anything that is focused.

            If an Input is focused in Firefox, and it gets detached from the DOM via a Node
            that isn't its direct parent, then Firefox will keep anything attached to this
            Input in memory. It will not be garbage collected until a new Input is focused.

            Workaround: Temporarily create an input, focus it, detach it.
             */ const focusEl = (0, _bb.BB).el({
            parent: document.body,
            tagName: "input",
            css: {
                opacity: "0",
                width: "0",
                height: "0"
            }
        });
        setTimeout(()=>{
            focusEl.select();
            focusEl.focus();
            focusEl.remove();
        }, 10);
    }
}
function clearSelection() {
    if (window.getSelection) {
        const sel = window.getSelection();
        if (sel) {
            if (sel.empty) sel.empty();
            else if (sel.removeAllRanges) sel.removeAllRanges();
        }
    }
}
const makeUnfocusable = function() {
    function preventFocus(event) {
        event.preventDefault();
        let didFocusRelated = false;
        if (event.relatedTarget) try {
            event.relatedTarget.focus();
            didFocusRelated = true;
        } catch (e) {
            console.error("failed to focus");
        }
        if (!didFocusRelated) event.currentTarget.blur();
    }
    return function(el) {
        el.setAttribute("tabindex", "-1");
        el.addEventListener("focus", preventFocus);
    };
}();
const els = [];
function el(params) {
    if (!params) return document.createElement("div");
    const result = document.createElement(params.tagName ? params.tagName : "div");
    params.css && (0, _base.css)(result, params.css);
    if (params.content) {
        if (typeof params.content === "string") result.innerHTML = params.content;
        else if (Array.isArray(params.content)) (0, _bb.BB).append(result, params.content);
        else result.append(params.content);
    }
    if (params.textContent) result.textContent = params.textContent;
    if (params.className) result.className = params.className;
    if (params.id) result.id = params.id;
    if (params.parent) params.parent.append(result);
    if ("title" in params && params.title !== undefined) result.title = params.title;
    const listeners = [];
    if (params.onClick !== undefined) {
        result.addEventListener("click", params.onClick);
        !params.noRef && listeners.push([
            "click",
            params.onClick
        ]);
    }
    if (params.onChange !== undefined) {
        result.addEventListener("change", params.onChange);
        !params.noRef && listeners.push([
            "change",
            params.onChange
        ]);
    }
    if (listeners.length > 0) els.push({
        el: result,
        listeners
    });
    if ("custom" in params && params.custom) {
        const customKeyArr = Object.keys(params.custom);
        for(let i = 0; i < customKeyArr.length; i++)result.setAttribute(customKeyArr[i], params.custom[customKeyArr[i]]);
    }
    return result;
}
function destroyEl(el) {
    if (!el) return;
    for(let i = 0; i < els.length; i++){
        const item = els[i];
        if (item.el === el) {
            item.listeners.forEach((item)=>{
                el.removeEventListener(item[0], item[1]);
            });
            els.splice(i, 1);
            return;
        }
    }
    // not found
    return;
}

},{"./base":"k6nNY","../bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lSCOF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BbLog", ()=>BbLog);
class BbLog {
    static #_ = (()=>{
        this.listeners = [];
    })();
    constructor(){}
    static subscribe(listener) {
        if (BbLog.listeners.includes(listener)) return;
        BbLog.listeners.push(listener);
    }
    static unsubscribe(listener) {
        for(let i = 0; i < BbLog.listeners.length; i++)if (listener === BbLog.listeners[i]) {
            BbLog.listeners.splice(i, 1);
            return;
        }
    }
    static emit(msg) {
        BbLog.listeners.forEach((item)=>{
            item(msg);
        });
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"04p5O":[function(require,module,exports) {
/**
 * LocalStorage wrapper that does not throw exceptions.
 * If cookies disabled in Safari localStorage interactions throw exception "insecure operation"
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LocalStorage", ()=>LocalStorage);
class LocalStorage {
    static getItem(key) {
        // (disabled) eslint-disable-next-line no-null/no-null
        let result = null;
        try {
            result = localStorage.getItem(key);
        } catch (e) {
            this.error = e;
        }
        return result;
    }
    static setItem(key, value) {
        try {
            localStorage.setItem(key, value);
        } catch (e) {
            this.error = e;
        }
    }
    static removeItem(key) {
        try {
            localStorage.removeItem(key);
        } catch (e) {
            this.error = e;
        }
    }
    static getError() {
        return this.error;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jC5wC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A ChainElement. Splits up coalesced events into their own pointermove events. Otherwise regular pass through.
 *
 * in: IPointerEvent
 * out: IPointerEvent with property isCoalesced: boolean
 *
 * todo: eventPreventDefault and eventStopPropagation are broken events w coalesced events. (because of json parse json stringify)
 * but how could that even work?
 */ parcelHelpers.export(exports, "CoalescedExploder", ()=>CoalescedExploder);
var _base = require("../../base/base");
class CoalescedExploder {
    // ---- public ----
    setChainOut(func) {
        this.chainOut = func;
    }
    chainIn(event) {
        if (event.type === "pointermove") {
            if (event.coalescedArr && event.coalescedArr.length > 0) for(let i = 0; i < event.coalescedArr.length; i++){
                const eventCopy = (0, _base.copyObj)(event);
                if (i === 0) eventCopy.coalescedArr = [];
                const coalescedItem = event.coalescedArr[i];
                eventCopy.pageX = coalescedItem.pageX;
                eventCopy.pageY = coalescedItem.pageY;
                eventCopy.relX = coalescedItem.relX;
                eventCopy.relY = coalescedItem.relY;
                eventCopy.dX = coalescedItem.dX;
                eventCopy.dY = coalescedItem.dY;
                eventCopy.time = coalescedItem.time;
                if (i < event.coalescedArr.length - 1) eventCopy.isCoalesced = true;
                this.chainOut && this.chainOut(eventCopy);
            }
            else return event;
        } else return event;
        return null;
    }
}

},{"../../base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gWILP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A ChainElement. Detects a single tap with N 'touch' pointers
 *
 * in IPointerEvent
 * out IPointerEvent
 */ parcelHelpers.export(exports, "NFingerTapper", ()=>NFingerTapper);
var _math = require("../../math/math");
class NFingerTapper {
    failGesture() {
        if (this.eventQueueArr.length === 0) return;
        this.timeoutObj.firstLastDownTimeout && clearTimeout(this.timeoutObj.firstLastDownTimeout);
        this.timeoutObj.tapTimeout && clearTimeout(this.timeoutObj.tapTimeout);
        for(let i = 0; i < this.eventQueueArr.length; i++)this.chainOut && this.chainOut(this.eventQueueArr[i]);
        this.eventQueueArr = [];
        this.fingerArr = [];
    }
    success() {
        this.timeoutObj.firstLastDownTimeout && clearTimeout(this.timeoutObj.firstLastDownTimeout);
        this.timeoutObj.tapTimeout && clearTimeout(this.timeoutObj.tapTimeout);
        this.eventQueueArr = []; // events get swallowed
        this.fingerArr = [];
        this.onTap();
    }
    setupTimeout(timeoutStr, timeMS) {
        const diff = timeMS - this.nowTime;
        //console.log(fingers + ': ' + timeoutStr + ' diff', diff);
        if (diff <= 0) return false;
        this.timeoutObj[timeoutStr] = setTimeout(()=>this.failGesture(), diff);
        return true;
    }
    processEvent(event) {
        const tempLastEventTime = this.lastEventTime;
        this.lastEventTime = event.time;
        if (event.type === "pointerdown") this.pointersDownIdArr.push(event.pointerId);
        else if (event.type === "pointerup") {
            for(let i = 0; i < this.pointersDownIdArr.length; i++)if (this.pointersDownIdArr[i] === event.pointerId) {
                this.pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        if (event.pointerType !== "touch") {
            if (this.fingerArr.length > 0) this.failGesture();
            return;
        }
        this.nowTime = performance.now();
        if (event.type === "pointerdown") {
            //console.log('down');
            if (this.fingerArr.length + 1 !== this.pointersDownIdArr.length) {
                this.failGesture();
                return;
            }
            if (this.fingerArr.length === this.fingers) {
                //console.log(fingers + ': too many fingers down -> fail');
                this.failGesture();
                return;
            }
            if (this.fingerArr.length > 0 && event.time - this.maxFirstLastFingerDownMs > this.fingerArr[0].downTimeMs) {
                //console.log(fingers + ': took too long to touch with all fingers -> fail');
                this.failGesture();
                return;
            }
            if (this.fingerArr.length === 0 && event.time - this.minSilenceBeforeDurationMs < tempLastEventTime) {
                //console.log(fingers + ': not enough silence before -> fail');
                this.failGesture();
                return;
            }
            if (this.fingerArr.length === 0) {
                this.firstDownTime = event.time;
                if (!this.setupTimeout("firstLastDownTimeout", event.time + this.maxFirstLastFingerDownMs) || !this.setupTimeout("tapTimeout", event.time + this.maxTapMs)) {
                    this.failGesture();
                    return;
                }
            }
            this.fingerArr.push({
                pointerId: event.pointerId,
                downTimeMs: event.time,
                downPageX: event.pageX,
                downPageY: event.pageY
            });
            return;
        }
        if (event.type === "pointermove") {
            if (this.fingerArr.length === 0) //not in a gesture -> ignore
            return;
            let fingerObj = null;
            for(let i = 0; i < this.fingerArr.length; i++)if (this.fingerArr[i].pointerId === event.pointerId) {
                fingerObj = this.fingerArr[i];
                break;
            }
            if (fingerObj === null) {
                this.failGesture();
                return;
            }
            if (event.time - this.maxTapMs > this.firstDownTime) {
                //console.log(fingers + ': tap took too long -> fail');
                this.failGesture();
                return;
            }
            const distance = (0, _math.dist)(event.pageX, event.pageY, fingerObj.downPageX, fingerObj.downPageY);
            if (distance > this.maxPressedDistancePx) {
                //console.log(fingers + ': a finger moved too much -> fail', distance);
                this.failGesture();
                return;
            }
        }
        if (event.type === "pointerup") {
            if (this.fingerArr.length === 0) //not in a gesture -> ignore
            return;
            //console.log('up', event.pageX, event.pageY);
            if (this.fingerArr.length !== this.fingers) {
                //console.log(fingers + ': not enough fingers -> fail');
                this.failGesture();
                return;
            }
            let fingerObj = null;
            let i = 0;
            for(; i < this.fingerArr.length; i++)if (this.fingerArr[i].pointerId === event.pointerId) {
                fingerObj = this.fingerArr[i];
                break;
            }
            if (fingerObj === null) //do nothing
            return;
            if (event.time - this.maxTapMs > this.firstDownTime) {
                //console.log(fingers + ': tap took too long -> fail');
                this.failGesture();
                return;
            }
            const distance = (0, _math.dist)(event.pageX, event.pageY, fingerObj.downPageX, fingerObj.downPageY);
            if (distance > this.maxPressedDistancePx) {
                //console.log(fingers + ': b finger moved too much -> fail', distance, event.pageX, event.pageY);
                //console.log(fingerArr);
                this.failGesture();
                return;
            }
            fingerObj.isUp = true;
            let allAreUp = true;
            for(let i = 0; i < this.fingerArr.length; i++)if (!this.fingerArr[i].isUp) {
                allAreUp = false;
                break;
            }
            //console.log('fingerArr', fingerArr);
            if (allAreUp) {
                this.success();
                return true;
            }
        }
    }
    // ---- public ----
    constructor(p){
        this.minSilenceBeforeDurationMs = 50;
        this.maxTapMs = 500;
        this.maxFirstLastFingerDownMs = 250;
        this.maxPressedDistancePx = 12 //5 + fingers * 5;
        ;
        this.fingerArr = [];
        this.eventQueueArr = [];
        this.firstDownTime = 0;
        this.lastEventTime = 0;
        this.nowTime = performance.now();
        this.pointersDownIdArr = [];
        this.timeoutObj = {
            firstLastDownTimeout: null,
            tapTimeout: null
        };
        this.fingers = p.fingers;
        this.onTap = p.onTap;
    }
    chainIn(event) {
        const result = this.processEvent(event);
        //console.log(fingerArr.length);
        if (result === true) //tap success -> event gets swallowed
        return null;
        if (this.fingerArr.length === 0) return event;
        else this.eventQueueArr.push(event);
        return null;
    }
    setChainOut(func) {
        this.chainOut = func;
    }
}

},{"../../math/math":"7w6MZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"T8qtt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A ChainElement. Detects a pinch zooming (2 touch pointers). If one finger lifts, then will use the remaining.
 * Further pointers are ignored, but their events get swallowed during the pinching.
 * pinching ends when ALL pointers are lifted.
 * Events passed through if no pinching.
 *
 * in IPointerEvent
 * out IPointerEvent
 */ parcelHelpers.export(exports, "PinchZoomer", ()=>PinchZoomer);
var _math = require("../../math/math");
class PinchZoomer {
    end() {
        this.gestureObj = null;
        this.eventQueueArr = [];
    }
    fail(doSwallow) {
        if (!this.gestureObj) return;
        this.timeoutObj.secondFingerTimeout && clearTimeout(this.timeoutObj.secondFingerTimeout);
        if (!doSwallow) for(let i = 0; i < this.eventQueueArr.length; i++)this.chainOut && this.chainOut(this.eventQueueArr[i]);
        this.end();
    }
    setupFailTimeout(timeMS) {
        const diff = timeMS - this.nowTime;
        if (diff <= 0) return false;
        this.timeoutObj.secondFingerTimeout = setTimeout(()=>this.fail(), diff);
        return true;
    }
    processEvent(event) {
        if (event.type === "pointerdown") this.pointersDownIdArr.push(event.pointerId);
        else if (event.type === "pointerup") {
            for(let i = 0; i < this.pointersDownIdArr.length; i++)if (this.pointersDownIdArr[i] === event.pointerId) {
                this.pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        //pass through scenarios
        if (!this.gestureObj && (event.pointerType !== "touch" || // wrong pointer type
        event.type === "pointermove" && this.pointersDownIdArr.length > 0 || // failed before
        this.pointersDownIdArr.length > 1 || // failed before
        event.type === "pointerup" // failed before
        )) return;
        this.nowTime = performance.now();
        //pointer down
        if (event.type === "pointerdown") {
            if (this.gestureObj) {
                if (event.pointerType === "touch") {
                    this.gestureObj.touchPointerArr.push({
                        pointerId: event.pointerId,
                        relX: event.relX,
                        relY: event.relY
                    });
                    if (this.gestureObj.isInProgress) this.continuePinch(this.gestureObj, {
                        type: "down",
                        index: this.gestureObj.touchPointerArr.length - 1
                    });
                    else {
                        this.timeoutObj.secondFingerTimeout && clearTimeout(this.timeoutObj.secondFingerTimeout);
                        this.gestureObj.isInProgress = true;
                        this.beginPinch(this.gestureObj);
                    }
                    return;
                } else {
                    if (this.gestureObj.isInProgress) this.gestureObj.otherPointerIdArr.push(event.pointerId);
                    else this.fail();
                    return;
                }
            } else {
                // first finger down - can only be touch if no gestureObj
                this.gestureObj = {
                    touchPointerArr: [
                        {
                            pointerId: event.pointerId,
                            relX: event.relX,
                            relY: event.relY,
                            downRelX: event.relX,
                            downRelY: event.relY
                        }
                    ],
                    otherPointerIdArr: [],
                    isInProgress: false
                };
                if (!this.setupFailTimeout(event.time + this.untilSecondFingerDurationMs)) {
                    this.fail();
                    return;
                }
                return;
            }
        }
        // should not happen. something went wrong
        if (!this.gestureObj) {
            // throw? would make it less robust
            this.fail();
            return;
        }
        //pointer move
        if (event.type === "pointermove" && event.pointerType === "touch") {
            //gesture object should always exist here
            let touchPointerObj = null;
            let i = 0;
            for(; i < this.gestureObj.touchPointerArr.length; i++)if (event.pointerId === this.gestureObj.touchPointerArr[i].pointerId) {
                touchPointerObj = this.gestureObj.touchPointerArr[i];
                break;
            }
            //null should not be possible. something went wrong
            if (!touchPointerObj) {
                // throw? would make it less robust
                this.fail();
                return;
            }
            touchPointerObj.relX = event.relX;
            touchPointerObj.relY = event.relY;
            if (!this.gestureObj.isInProgress) {
                // should not happen. something went wrong
                if (!("downRelX" in touchPointerObj && touchPointerObj.downRelX !== undefined) || !("downRelY" in touchPointerObj && touchPointerObj.downRelY !== undefined)) {
                    this.fail();
                    return;
                }
                const distance = (0, _math.dist)(touchPointerObj.downRelX, touchPointerObj.downRelY, touchPointerObj.relX, touchPointerObj.relY);
                if (distance > this.firstFingerMaxDistancePx) {
                    this.fail();
                    return;
                }
            } else if (i < 2) this.continuePinch(this.gestureObj, {
                type: "move",
                index: i
            });
            return;
        }
        //pointer up
        if (event.type === "pointerup") {
            //gesture object should always exist here
            if (event.pointerType === "touch") {
                let i = 0;
                for(; i < this.gestureObj.touchPointerArr.length; i++)if (this.gestureObj.touchPointerArr[i].pointerId === event.pointerId) {
                    this.gestureObj.touchPointerArr.splice(i, 1);
                    break;
                }
                if (this.gestureObj.touchPointerArr.length > 0) this.continuePinch(this.gestureObj, {
                    type: "up",
                    index: i
                });
            } else {
                for(let i = 0; i < this.gestureObj.otherPointerIdArr.length; i++)if (this.gestureObj.otherPointerIdArr[i] === event.pointerId) {
                    this.gestureObj.otherPointerIdArr.splice(i, 1);
                    break;
                }
            }
            //all fingers lifted?
            if (this.gestureObj.touchPointerArr.length === 0 && this.gestureObj.otherPointerIdArr.length === 0) {
                if (this.gestureObj.isInProgress) {
                    this.end();
                    this.endPinch();
                } else this.fail();
                return;
            }
        }
    }
    beginPinch(gestureObj) {
        for(let i = 0; i < gestureObj.touchPointerArr.length; i++){
            const pointerObj = gestureObj.touchPointerArr[i];
            this.pincherArr.push({
                pointerId: pointerObj.pointerId,
                relX: pointerObj.relX,
                relY: pointerObj.relY,
                downRelX: pointerObj.relX,
                downRelY: pointerObj.relY
            });
        }
        const event = {
            type: "move",
            // temp
            downRelX: 0,
            downRelY: 0,
            relX: 0,
            relY: 0,
            angleRad: 0,
            scale: 1
        };
        if (this.pincherArr.length === 1) {
            event.relX = this.pincherArr[0].downRelX;
            event.relY = this.pincherArr[0].downRelY;
        } else {
            event.relX = 0.5 * (this.pincherArr[0].downRelX + this.pincherArr[1].downRelX);
            event.relY = 0.5 * (this.pincherArr[0].downRelY + this.pincherArr[1].downRelY);
        }
        event.downRelX = event.relX;
        event.downRelY = event.relY;
        this.onPinch(event);
    }
    //actionObj = {type: 'down'|'move'|'up', index: number}
    continuePinch(gestureObj, actionObj) {
        if (actionObj.index > 1) return;
        if (actionObj.type === "move") {
            let event;
            this.pincherArr[actionObj.index].relX = gestureObj.touchPointerArr[actionObj.index].relX;
            this.pincherArr[actionObj.index].relY = gestureObj.touchPointerArr[actionObj.index].relY;
            if (this.pincherArr.length === 1) event = {
                type: "move",
                downRelX: this.pincherArr[0].downRelX,
                downRelY: this.pincherArr[0].downRelY,
                relX: this.pincherArr[0].relX,
                relY: this.pincherArr[0].relY,
                angleRad: 0,
                scale: 1
            };
            else {
                const startDist = (0, _math.dist)(this.pincherArr[0].downRelX, this.pincherArr[0].downRelY, this.pincherArr[1].downRelX, this.pincherArr[1].downRelY);
                const distance = (0, _math.dist)(this.pincherArr[0].relX, this.pincherArr[0].relY, this.pincherArr[1].relX, this.pincherArr[1].relY);
                const startAngle = (0, _math.pointsToAngleRad)({
                    x: this.pincherArr[0].downRelX,
                    y: this.pincherArr[0].downRelY
                }, {
                    x: this.pincherArr[1].downRelX,
                    y: this.pincherArr[1].downRelY
                });
                const angle = (0, _math.pointsToAngleRad)({
                    x: this.pincherArr[0].relX,
                    y: this.pincherArr[0].relY
                }, {
                    x: this.pincherArr[1].relX,
                    y: this.pincherArr[1].relY
                });
                event = {
                    type: "move",
                    downRelX: 0.5 * (this.pincherArr[0].downRelX + this.pincherArr[1].downRelX),
                    downRelY: 0.5 * (this.pincherArr[0].downRelY + this.pincherArr[1].downRelY),
                    relX: 0.5 * (this.pincherArr[0].relX + this.pincherArr[1].relX),
                    relY: 0.5 * (this.pincherArr[0].relY + this.pincherArr[1].relY),
                    angleRad: angle - startAngle,
                    scale: distance / startDist
                };
            }
            this.onPinch(event);
        } else if (actionObj.type === "down" || actionObj.type === "up") {
            this.endPinch();
            this.beginPinch(gestureObj);
        }
    }
    endPinch() {
        this.pincherArr = [];
        this.onPinch({
            type: "end"
        });
    }
    // ---- public ----
    constructor(p){
        this.firstFingerMaxDistancePx = 10;
        this.untilSecondFingerDurationMs = 250;
        this.pointersDownIdArr = [];
        this.gestureObj = null;
        this.eventQueueArr = [];
        this.nowTime = performance.now();
        this.timeoutObj = {
            secondFingerTimeout: null
        };
        this.pincherArr = [];
        this.onPinch = p.onPinch;
    }
    chainIn(event) {
        this.processEvent(event);
        if (this.gestureObj) {
            if (!this.gestureObj.isInProgress) this.eventQueueArr.push(event);
        } else return event;
        return null;
    }
    setChainOut(func) {
        this.chainOut = func;
    }
}

},{"../../math/math":"7w6MZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7kjBa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A ChainElement. Detects double taps.
 *
 * in IPointerEvent
 * out IPointerEvent
 */ parcelHelpers.export(exports, "DoubleTapper", ()=>DoubleTapper);
var _math = require("../../math/math");
class DoubleTapper {
    // double tap achieved
    success() {
        this.timeoutObj.fail = null;
        this.timeoutObj.success = null;
        this.eventQueueArr = []; // events get swallowed
        const lastSequenceItem = this.sequenceArr[this.sequenceArr.length - 1];
        this.sequenceArr = [];
        if ("pageX" in lastSequenceItem) this.onDoubleTap({
            pageX: lastSequenceItem.pageX,
            pageY: lastSequenceItem.pageY,
            relX: lastSequenceItem.relX,
            relY: lastSequenceItem.relY
        });
    }
    // returns false if time already up. otherwise sets up timeout
    setupTimeout(timeoutStr, targetFunc, timeMS, noComparison) {
        const diff = timeMS - this.nowTime;
        // console.log(fingers + ': ' + timeoutStr + ' diff', diff);
        if (diff <= 0 && !noComparison) return false;
        this.timeoutObj[timeoutStr] = setTimeout(targetFunc, Math.max(0, diff));
        return true;
    }
    /**
     * @param event object - a pointer event from BB.PointerListener
     */ processEvent(event) {
        if (event.type === "pointerdown") this.pointersDownIdArr.push(event.pointerId);
        else if (event.type === "pointerup") {
            for(let i = 0; i < this.pointersDownIdArr.length; i++)if (this.pointersDownIdArr[i] === event.pointerId) {
                this.pointersDownIdArr.splice(i, 1);
                break;
            }
        }
        if (!this.allowedPointerTypeArr.includes(event.pointerType)) {
            //console.log('wrong input type -> fail');
            this.gestureFailed();
            return;
        }
        this.nowTime = performance.now();
        const lastSequenceItem = this.sequenceArr.length > 0 ? this.sequenceArr[this.sequenceArr.length - 1] : null;
        if (event.type === "pointerup") this.lastUpTime = event.time;
        if (event.type === "pointerdown") {
            if (this.pointersDownIdArr.length > 1) {
                //console.log('more than one pointer down -> fail');
                this.gestureFailed();
                return;
            }
            if (this.timeoutObj.success !== null) {
                //console.log('silence-after not achieved -> fail');
                this.gestureFailed();
                return;
            }
            if (this.sequenceArr.length === 0 && this.nowTime - this.lastUpTime < this.minSilenceBeforeDurationMs) {
                //console.log('silence before not achieved -> fail');
                this.gestureFailed();
                return;
            }
            if (event.button && !this.allowedButtonArr.includes(event.button)) {
                //console.log('wrong button -> fail', event.button, allowedButtonArr);
                this.gestureFailed();
                return;
            }
            if (lastSequenceItem && "isDown" in lastSequenceItem && lastSequenceItem.isDown || this.sequenceArr.length > 2) {
                //console.log('jumbled -> fail');
                this.gestureFailed();
                return;
            }
            if (lastSequenceItem && "position" in lastSequenceItem) {
                const distance = (0, _math.dist)(lastSequenceItem.position[0], lastSequenceItem.position[1], event.pageX, event.pageY);
                if (distance > this.maxInbetweenDistancePx) {
                    //console.log('maxInbetweenDistancePx -> reset');
                    this.gestureFailed();
                    if ("time" in lastSequenceItem && this.nowTime - lastSequenceItem.time < this.minSilenceBeforeDurationMs) return;
                }
            }
            this.sequenceArr.push({
                isDown: true,
                time: this.nowTime,
                position: [
                    event.pageX,
                    event.pageY
                ],
                pointerId: event.pointerId
            });
            //maxUntilSecondDown
            if (this.sequenceArr.length > 1) this.timeoutObj.maxUntilSecondDown && clearTimeout(this.timeoutObj.maxUntilSecondDown);
            else if (!this.setupTimeout("maxUntilSecondDown", ()=>this.gestureFailed(), event.time + this.maxUntilSecondDownDurationMs)) {
                //console.log('event.time + maxPressedDurationMs -> fail');
                this.gestureFailed();
                return;
            }
            this.timeoutObj.fail && clearTimeout(this.timeoutObj.fail);
            if (!this.setupTimeout("fail", ()=>this.gestureFailed(), event.time + this.maxPressedDurationMs)) {
                //console.log('event.time + maxPressedDurationMs -> fail');
                this.gestureFailed();
                return;
            }
        }
        if (lastSequenceItem && event.type === "pointermove" && "pointerId" in lastSequenceItem && lastSequenceItem.pointerId === event.pointerId) {
            /*if (lastSequenceItem.pointerId !== event.pointerId) { //another pointer mixing in -> fail
                console.log('another pointer mixing in -> fail');
                this.fail();
                return;
            }*/ const distance = (0, _math.dist)(lastSequenceItem.position[0], lastSequenceItem.position[1], event.pageX, event.pageY);
            if (distance > this.maxPressedDistancePx) {
                //console.log('maxPressedDistancePx -> fail');
                this.gestureFailed();
                return;
            }
        }
        if (lastSequenceItem && event.type === "pointerup") {
            if ("pointerId" in lastSequenceItem && lastSequenceItem.pointerId !== event.pointerId) {
                this.gestureFailed();
                return;
            }
            if ("time" in lastSequenceItem && this.nowTime >= lastSequenceItem.time + this.maxPressedDurationMs) {
                this.gestureFailed();
                return;
            }
            this.timeoutObj.fail && clearTimeout(this.timeoutObj.fail);
            if (this.sequenceArr.length < 3) {
                if (!this.setupTimeout("fail", ()=>this.gestureFailed(), event.time + this.maxUpToUpDurationMs)) {
                    this.gestureFailed();
                    return;
                }
                this.sequenceArr = [
                    lastSequenceItem,
                    {
                        isUp: true,
                        time: this.nowTime,
                        position: [
                            event.pageX,
                            event.pageY
                        ]
                    }
                ];
                return;
            }
            if ("time" in this.sequenceArr[1] && this.nowTime < this.sequenceArr[1].time + this.maxUpToUpDurationMs) {
                // double tap almost success
                // only needs silence
                this.sequenceArr.push({
                    pageX: event.pageX,
                    pageY: event.pageY,
                    relX: event.relX,
                    relY: event.relY
                });
                if (!this.setupTimeout("success", ()=>this.success(), event.time + this.minSilenceAfterMs, true)) this.gestureFailed();
            } else this.gestureFailed();
        }
    }
    // ---- public ----
    constructor(p){
        this.allowedPointerTypeArr = [
            "touch",
            "mouse",
            "pen"
        ];
        this.allowedButtonArr = [
            "left"
        ];
        this.minSilenceBeforeDurationMs = 400;
        this.maxPressedDurationMs = 300;
        this.maxPressedDistancePx = 10;
        this.maxInbetweenDistancePx = 19;
        this.maxUpToUpDurationMs = 500;
        this.maxUntilSecondDownDurationMs = 300;
        this.minSilenceAfterMs = 250;
        this.sequenceArr = [];
        this.pointersDownIdArr = [];
        this.lastUpTime = 0;
        this.nowTime = 0;
        this.eventQueueArr = [];
        this.timeoutObj = {
            fail: null,
            maxUntilSecondDown: null,
            success: null
        };
        this.onDoubleTap = p.onDoubleTap;
        if (p.isInstant) {
            this.minSilenceBeforeDurationMs = 0;
            this.minSilenceAfterMs = 0;
        }
        this.gestureFailed = ()=>{
            if (this.sequenceArr.length === 0) return;
            this.timeoutObj.fail && clearTimeout(this.timeoutObj.fail);
            this.timeoutObj.maxUntilSecondDown && clearTimeout(this.timeoutObj.maxUntilSecondDown);
            this.timeoutObj.success && clearTimeout(this.timeoutObj.success);
            this.timeoutObj.fail = null;
            this.timeoutObj.maxUntilSecondDown = null;
            this.timeoutObj.success = null;
            if (this.chainOut) for(let i = 0; i < this.eventQueueArr.length; i++)this.chainOut(this.eventQueueArr[i]);
            this.eventQueueArr = [];
            this.sequenceArr = [];
        };
    }
    chainIn(event) {
        this.processEvent(event);
        if (this.sequenceArr.length === 0) {
            this.gestureFailed();
            return event;
        }
        // events might become a double tap -> queue
        this.eventQueueArr.push(event);
        return null;
    }
    setChainOut(func) {
        this.chainOut = func;
    }
    setAllowedPointerTypeArr(arr) {
        this.allowedPointerTypeArr = [
            ...arr
        ];
    }
    setAllowedButtonArr(arr) {
        this.allowedButtonArr = [
            ...arr
        ];
    }
}

},{"../../math/math":"7w6MZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"d988z":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * only lets through events from one pointer at a time.
 *
 * in IPointerEvent
 * out IPointerEvent
 */ parcelHelpers.export(exports, "OnePointerLimiter", ()=>OnePointerLimiter);
class OnePointerLimiter {
    // ---- public ----
    chainIn(event) {
        if (this.ignorePointerIdArr.includes(event.pointerId)) {
            if (event.type === "pointerup") {
                for(let i = 0; i < this.ignorePointerIdArr.length; i++)if (this.ignorePointerIdArr[i] === event.pointerId) {
                    this.ignorePointerIdArr.splice(i, 1);
                    break;
                }
            }
            return null;
        }
        if (this.downPointerId === null) {
            if (event.type === "pointerdown") this.downPointerId = event.pointerId;
            return event;
        } else {
            if (event.pointerId !== this.downPointerId) {
                if (event.type === "pointerdown") this.ignorePointerIdArr.push(event.pointerId);
                return null;
            }
            if (event.type === "pointerup") this.downPointerId = null;
            return event;
        }
    }
    setChainOut(func) {
        this.chainOut = func;
    }
    constructor(){
        this.downPointerId = null;
        this.ignorePointerIdArr = [];
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gQC7e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * for chaining event processing. useful for gestures (double tap, pinch zoom, max pointer filter).
 * each element in the chain might hold back the events, swallow them, transform them, or create new ones
 */ parcelHelpers.export(exports, "EventChain", ()=>EventChain);
class EventChain {
    continueChain(i, event) {
        for(; i < this.chainArr.length; i++){
            event = this.chainArr[i].chainIn(event);
            if (event === null) return null;
        }
        this.chainOut && this.chainOut(event);
        return null;
    }
    // ---- public ----
    constructor(p){
        this.chainArr = p.chainArr;
        for(let i = 0; i < this.chainArr.length; i++)((i)=>{
            this.chainArr[i].setChainOut((event)=>{
                this.continueChain(i + 1, event);
            });
        })(i);
    }
    /**
     * feed an event into the chain
     */ chainIn(event) {
        return this.continueChain(0, event);
    }
    /**
     * func will be called when event has passed through the chain
     */ setChainOut(func) {
        this.chainOut = func;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iiYGN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LS_LANGUAGE_KEY", ()=>LS_LANGUAGE_KEY);
parcelHelpers.export(exports, "getLanguage", ()=>getLanguage);
parcelHelpers.export(exports, "languageStrings", ()=>languageStrings);
parcelHelpers.export(exports, "LANG", ()=>LANG);
parcelHelpers.export(exports, "initLANG", ()=>initLANG);
var _languages = require("../../languages/languages");
const LS_LANGUAGE_KEY = "klecks-language";
class LanguageStrings {
    // --- public ----
    constructor(){
        this.listeners = [];
        // need to use setLanguage for a different language
        this.data = {
            ...(0, _languages.english)
        };
        this.code = "en";
    }
    async setLanguage(langCode) {
        if (langCode === "en") this.data = {
            ...(0, _languages.english)
        };
        else this.data = {
            ...(0, _languages.english),
            ...await (0, _languages.loadLanguage)(langCode)
        };
        this.code = langCode;
        document.documentElement.setAttribute("lang", langCode);
        this.listeners.forEach((item)=>{
            item();
        });
    }
    get(code) {
        if (!(code in this.data)) throw new Error("translation code doesn't exist: " + code);
        return this.data[code];
    }
    getLanguage() {
        return (0, _languages.languages).find((item)=>{
            return item.code === this.code;
        });
    }
    getAutoLanguage() {
        const autoCode = getLanguage(false);
        return (0, _languages.languages).find((item)=>{
            return item.code === autoCode;
        });
    }
    getCode() {
        return this.code;
    }
    // get notified on language change
    subscribe(subscriber) {
        if (this.listeners.includes(subscriber)) return;
        this.listeners.push(subscriber);
    }
    unsubscribe(subscriber) {
        for(let i = 0; i < this.listeners.length; i++)if (subscriber === this.listeners[i]) {
            this.listeners.splice(i, 1);
            return;
        }
    }
}
function getLanguage(useLocalStorage) {
    let result = "en";
    const langs = []; // from highest to lowest priority
    const navLangs = navigator.languages ? navigator.languages : [
        navigator.language
    ];
    navLangs.forEach((item)=>{
        const split = item.split("-");
        langs.push(item);
        if (split.length === 2) langs.push(split[0]);
    });
    if (useLocalStorage) try {
        const item = localStorage.getItem(LS_LANGUAGE_KEY);
        if (item) langs.unshift(item);
    } catch (e) {
    // likely cookies disabled in Safari
    }
    console.log(langs);
    console.log((0, _languages.languages));
    for(let i = 0; i < langs.length; i++){
        const lang = langs[i];
        const found = (0, _languages.languages).find((item)=>{
            return item.code.toLowerCase() === lang.toLowerCase();
        });
        if (found) {
            result = found.code;
            break;
        }
    }
    return result;
}
const activeLanguageCode = getLanguage(true);
const languageStrings = new LanguageStrings();
const LANG = (code, replace)=>{
    if (replace) {
        let result = languageStrings.get(code);
        const keyArr = Object.keys(replace);
        keyArr.forEach((key)=>{
            result = result.replace(`{${key}}`, replace[key]);
        });
        return result;
    } else return languageStrings.get(code);
};
const initLANG = ()=>languageStrings.setLanguage(activeLanguageCode);

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../../languages/languages":"5K1G7"}],"5K1G7":[function(require,module,exports) {
// generated from src/languages. "npm run lang:build" to update
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "english", ()=>english);
parcelHelpers.export(exports, "languages", ()=>languages);
parcelHelpers.export(exports, "loadLanguage", ()=>loadLanguage);
var _enJson = require("./en.json");
var _enJsonDefault = parcelHelpers.interopDefault(_enJson);
const english = (0, _enJsonDefault.default);
const languages = [
    {
        code: "en",
        name: "English"
    },
    {
        code: "de",
        name: "Deutsch"
    },
    {
        code: "en-GB",
        name: "English"
    },
    {
        code: "en-US",
        name: "English"
    },
    {
        code: "en-ZA",
        name: "English"
    },
    {
        code: "en",
        name: "English"
    },
    {
        code: "fr",
        name: "Fran\xe7ais"
    },
    {
        code: "ja",
        name: "日本語"
    },
    {
        code: "ko",
        name: "한국어"
    },
    {
        code: "ru",
        name: "русский"
    },
    {
        code: "zh-CN",
        name: "简体中文"
    },
    {
        code: "zh-TW",
        name: "繁體中文"
    }
];
const loadLanguage = async (code)=>{
    if (code === "en") return english;
    else if (code === "de") return await require("f059653332475fd3");
    else if (code === "en-GB") return await require("df6b4cdfc4dcce80");
    else if (code === "en-US") return await require("f7c9f048f9bb48bf");
    else if (code === "en-ZA") return await require("daf3ea4ea761b161");
    else if (code === "en") return await require("d4de79e08d2ce6a4");
    else if (code === "fr") return await require("cfa52edf344ca1ef");
    else if (code === "ja") return await require("814394c8adce581b");
    else if (code === "ko") return await require("315931c731a980dc");
    else if (code === "ru") return await require("a8720c333f72a760");
    else if (code === "zh-CN") return await require("8d2d53e9ba060849");
    else if (code === "zh-TW") return await require("ca68ac3f0df3555b");
    throw new Error("unknown language code");
};
 // {x}min

},{"./en.json":"81RpX","f059653332475fd3":"7xY9y","df6b4cdfc4dcce80":"kFklA","f7c9f048f9bb48bf":"d0aNE","daf3ea4ea761b161":"kz7MD","d4de79e08d2ce6a4":"3Us8O","cfa52edf344ca1ef":"6u3v8","814394c8adce581b":"jY7Yl","315931c731a980dc":"cJHhi","a8720c333f72a760":"iakxK","8d2d53e9ba060849":"kkQnx","ca68ac3f0df3555b":"gJTRh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"81RpX":[function(require,module,exports) {
module.exports = JSON.parse('{"switch-ui-left-right":"Switch left/right UI","toggle-show-tools":"Show/Hide Tools","scroll":"Scroll","donate":"Donate","home":"Home","modal-new-tab":"Open in new tab","tab-edit":"Edit","tab-file":"File","tool-brush":"Brush","tool-paint-bucket":"Paint Bucket","tool-gradient":"Gradient","tool-shape":"Shape","tool-text":"Text","tool-hand":"Hand Tool","tool-zoom":"Zoom","undo":"Undo","redo":"Redo","brush-pen":"Pen","brush-blend":"Blend","brush-sketchy":"Sketchy","brush-pixel":"Pixel","brush-chemy":"Chemy","brush-smudge":"Smudge","brush-size":"Size","brush-blending":"Blending","brush-toggle-pressure":"Toggle Pressure Sensitivity","brush-pen-circle":"Circle","brush-pen-chalk":"Chalk","brush-pen-calligraphy":"Calligraphy","brush-pen-square":"Square","brush-sketchy-scale":"Scale","brush-pixel-dither":"Dither","brush-chemy-fill":"Fill","brush-chemy-stroke":"Stroke","brush-chemy-mirror-x":"Horizontal Symmetry","brush-chemy-mirror-y":"Vertical Symmetry","brush-chemy-gradient":"Gradient","brush-eraser-transparent-bg":"Transparent Background","stabilizer":"Stabilizer","stabilizer-title":"Stroke Stabilizer","eyedropper":"Eyedropper","secondary-color":"Secondary Color","manual-color-input":"Manual Color Input","mci-hex":"Hex","mci-copy":"Copy","modal-ok":"Ok","modal-cancel":"Cancel","modal-close":"Close","layers-active-layer":"Active Layer","layers-layer":"Layer","layers-copy":"copy","layers-blending":"Blending","layers-new":"New Layer","layers-remove":"Remove Layer","layers-duplicate":"Duplicate Layer","layers-merge":"Merge with layer below","layers-merge-all":"Merge all","layers-rename":"Rename","layers-active-layer-visible":"Active layer is visible","layers-active-layer-hidden":"Active layer is hidden","layers-visibility-toggle":"Layer Visibility","layers-blend-normal":"normal","layers-blend-darken":"darken","layers-blend-multiply":"multiply","layers-blend-color-burn":"color burn","layers-blend-lighten":"lighten","layers-blend-screen":"screen","layers-blend-color-dodge":"color dodge","layers-blend-overlay":"overlay","layers-blend-soft-light":"soft light","layers-blend-hard-light":"hard light","layers-blend-difference":"difference","layers-blend-exclusion":"exclusion","layers-blend-hue":"hue","layers-blend-saturation":"saturation","layers-blend-color":"color","layers-blend-luminosity":"luminosity","layers-rename-title":"Rename Layer","layers-rename-name":"Name","layers-rename-clear":"Clear Name","layers-rename-sketch":"Sketch","layers-rename-colors":"Colors","layers-rename-shading":"Shading","layers-rename-lines":"Lines","layers-rename-effects":"Effects","layers-rename-foreground":"Foreground","layers-merge-modal-title":"Merge/Mix Layers","layers-merge-description":"Merges the selected layer with the one underneath. Select the mix mode:","file-no-autosave":"No autosave, no cloud storage","file-new":"New","file-import":"Import","file-save":"Save","file-format":"File Format","file-copy":"Copy","file-copy-title":"Copy To Clipboard","file-share":"Share","file-storage":"Browser Storage","file-storage-thumb-title":"Restores when reopening page","file-storage-about":"About Browser Storage","file-storage-cant-access":"Can\'t access","file-storage-empty":"Empty","file-storage-store":"Store","file-storage-clear":"Clear","file-storage-storing":"Storing","file-storage-overwrite":"Overwrite","file-storage-min-ago":"{x}min ago","file-storage-hours-ago":"{x}h ago","file-storage-days-ago":"{x}d ago","file-storage-month-ago":"> 1month ago","file-storage-restored":"Restored from Browser Storage","file-storage-stored":"Stored to Browser Storage","file-storage-failed":"Failed to store to Browser Storage","file-storage-failed-1":"Failed to store. Possible causes:","file-storage-failed-2":"Out of disk space","file-storage-failed-3":"Storage disabled in incognito tab","file-storage-failed-4":"Browser doesn\'t support storage","file-storage-failed-clear":"Failed to clear.","file-upload":"Upload","cleared-layer":"Cleared layer","filled":"Filled","new-title":"New Image","new-current":"Current","new-fit":"Fit","new-oversize":"Oversize","new-square":"Square","new-landscape":"Landscape","new-portrait":"Portrait","new-screen":"Screen","new-video":"Video","new-din-paper":"DIN Paper","new-px":"px","new-ratio":"Ratio","upload-title":"Upload to Imgur","upload-link-notice":"Anyone with the link to your uploaded image will be able to view it.","upload-name":"Title","upload-title-untitled":"Untitled","upload-caption":"Caption","upload-submit":"Upload","upload-uploading":"Uploading...","upload-success":"Upload Successful","upload-failed":"Upload failed.","upload-delete":"To delete your image from Imgur visit:","cropcopy-title-copy":"Copy To Clipboard","cropcopy-title-crop":"Crop","cropcopy-click-hold":"Right-click or press hold to copy.","cropcopy-btn-copy":"To Clipboard","cropcopy-copied":"Copied.","cropcopy-btn-crop":"Apply Crop","crop-drag-to-crop":"Drag to crop","filter-crop-extend":"Crop/Extend","filter-flip":"Flip","filter-perspective":"Perspective","filter-resize":"Resize","filter-rotate":"Rotate","filter-transform":"Transform","filter-bright-contrast":"Bright/Contrast","filter-curves":"Curves","filter-hue-sat":"Hue/Saturation","filter-invert":"Invert","filter-tilt-shift":"Tilt Shift","filter-to-alpha":"To Alpha","filter-triangle-blur":"Triangle Blur","filter-unsharp-mask":"Unsharp Mask","filter-crop-title":"Crop / Extend","filter-crop-description":"Crop or extend the image.","filter-crop-left":"Left","filter-crop-right":"Right","filter-crop-top":"Top","filter-crop-bottom":"Bottom","filter-crop-rule-thirds":"Rule of Thirds","filter-crop-fill":"Fill","filter-flip-title":"Flip","filter-flip-description":"Flips layer or whole image.","filter-flip-horizontal":"Horizontal","filter-flip-vertical":"Vertical","filter-flip-image":"Flip Image","filter-flip-layer":"Flip Layer","filter-perspective-title":"Perspective","filter-perspective-description":"Transforms the selected layer.","filter-resize-title":"Resize","filter-resize-description":"Resizes the image.","filter-rotate-title":"Rotate","filter-rotate-description":"Rotates the image.","filter-transform-empty":"Layer is empty.","filter-transform-title":"Transform","filter-transform-description":"Transforms selected layer. Hold Shift for additional behavior.","filter-transform-rotation":"Rotation","filter-transform-flip":"Flip","filter-transform-center":"Center","filter-transform-constrain":"Constrain","filter-transform-snap":"Snap","filter-transform-snap-title":"Snap Rotation And Position","filter-bright-contrast-title":"Brightness / Contrast","filter-bright-contrast-description":"Change brightness and contrast for the selected layer.","filter-bright-contrast-brightness":"Brightness","filter-bright-contrast-contrast":"Contrast","filter-curves-title":"Curves","filter-curves-description":"Apply curves on the selected layer.","filter-curves-all":"All","filter-hue-sat-title":"Hue / Saturation","filter-hue-sat-description":"Change hue and saturation for the selected layer.","filter-hue-sat-hue":"Hue","filter-hue-sat-saturation":"Saturation","filter-applied":"applied","filter-tilt-shift-title":"Tilt Shift","filter-tilt-shift-description":"Applies tilt shift on the selected layer.","filter-tilt-shift-blur":"Blur Radius","filter-tilt-shift-gradient":"Gradient Radius","filter-to-alpha-title":"To Alpha","filter-to-alpha-description":"Generates alpha channel for selected layer from:","filter-to-alpha-inverted-lum":"Inverted Luminance","filter-to-alpha-lum":"Luminance","filter-to-alpha-replace":"Replace RGB","filter-triangle-blur-title":"Triangle Blur","filter-triangle-blur-description":"Applies triangle blur on the selected layer.","filter-unsharp-mask-title":"Unsharp Mask","filter-unsharp-mask-description":"Sharpens the selected layer by scaling pixels away from the average of their neighbors.","filter-unsharp-mask-strength":"Strength","filter-grid":"Grid","filter-grid-description":"Draws grid on selected layer.","filter-noise":"Noise","filter-noise-description":"Adds noise to selected layer.","filter-noise-scale":"Scale","filter-noise-alpha":"Alpha","filter-pattern":"Pattern","filter-pattern-description":"Generates pattern on selected layer. Drag the preview for further controls.","filter-distort":"Distort","filter-distort-description":"Distorts the selected layer.","filter-distort-phase":"Phase","filter-distort-stepsize":"Step Size","filter-distort-sync-xy":"Sync XY","filter-vanish-point":"Vanish Point","filter-vanish-point-title":"Vanishing Point","filter-vanish-point-description":"Adds vanishing point to selected layer. Drag preview to move.","filter-vanish-point-lines":"Lines","import-opening":"Opening file...","import-title":"Import Image","import-too-large":"Image too large, will be downscaled.","import-btn-as-layer":"As Layer","import-btn-as-image":"As Image","import-as-layer-title":"Import Image as New Layer","import-as-layer-description":"Adjust the position of the imported image.","import-as-layer-limit-reached":"Layer limit reached. Image will be placed on existing layer.","import-as-layer-fit":"Fit","import-flatten":"Flatten image","import-unsupported-file":"Unsupported file type. See Help for supported types.","import-broken-file":"Couldn\'t load image. File might be corrupted.","import-psd-unsupported":"Unsupported features. PSD had to be flattened.","import-psd-limited-support":"PSD support is limited. Flattened will more likely look correct.","import-psd-too-large":"Image exceeds maximum dimensions of {x} x {x} pixels. Unable to import.","import-psd-size":"Image size","hand-reset":"Reset","hand-fit":"Fit","bucket-tolerance":"Tolerance","bucket-sample":"Sample","bucket-sample-title":"Which layers to sample color from","bucket-sample-all":"All","bucket-sample-active":"Active","bucket-sample-above":"Above","bucket-grow":"Grow","bucket-grow-title":"Grow filled area (in pixels)","bucket-contiguous":"Contiguous","bucket-contiguous-title":"Only fill connected areas","gradient-linear":"Linear","gradient-linear-mirror":"Linear-Mirror","gradient-radial":"Radial","shape-stroke":"Stroke","shape-fill":"Fill","shape-rect":"Rectangle","shape-ellipse":"Ellipse","shape-line":"Line","shape-line-width":"Line Width","shape-outwards":"Outwards","shape-fixed":"Fixed 1:1","text-instruction":"Click canvas to place text","text-title":"Add Text","text-text":"Text","text-font":"Font","text-placeholder":"Your text","text-color":"Color","text-size":"Size","text-line-height":"Line Height","text-letter-spacing":"Letter Spacing","text-left":"Left","text-center":"Center","text-right":"Right","text-italic":"Italic","text-bold":"Bold","save-reminder-title":"Unsaved Work","save-reminder-text":"Image was not saved in {a} minutes{b}. Save now to prevent eventual loss.","save-reminder-save-psd":"Save As PSD","save-reminder-psd-layers":"PSD will remember all layers.","backup-drawing":"You can backup your drawing.","submit":"Submit","submit-title":"Submit Drawing","submit-prompt":"Submit drawing?","submit-submitting":"Submitting","embed-init-loading":"Loading app","embed-init-waiting":"Waiting for image","unsaved":"Unsaved","help":"Help","tab-settings":"Settings","settings-language":"Language","settings-language-reload":"Will update after reloading.","settings-theme":"Theme","settings-save-reminder-label":"Save Reminder","settings-save-reminder-disabled":"disabled","settings-save-reminder-confirm-title":"Turn off Save Reminder?","settings-save-reminder-confirm-a":"There is no autosave and browser tabs don\'t last forever. If you don\'t periodically save you will likely lose work.","settings-save-reminder-confirm-b":"Disable at your own risk?","settings-save-reminder-confirm-disable":"Disable","theme-dark":"Dark","theme-light":"Light","terms-of-service":"Terms of Service","licenses":"Licenses","source-code":"Source Code","auto":"auto","zoom-in":"Zoom In","zoom-out":"Zoom Out","radius":"Radius","constrain-proportions":"Constrain Proportions","width":"Width","height":"Height","opacity":"Opacity","red":"Red","green":"Green","blue":"Blue","eraser":"Eraser","center":"Center","layers":"Layers","background":"Background","scaling-algorithm":"Scaling Algorithm","algorithm-smooth":"Smooth","algorithm-pixelated":"Pixelated","preview":"Preview","angle-snap":"Snap","angle-snap-title":"45\xb0 Angle Snapping","lock-alpha":"Lock Alpha","lock-alpha-title":"Locks layer\'s alpha channel","reverse":"Reverse","compare-before":"Before","compare-after":"After","loading":"Loading","more":"More","x-minutes":"{x}min"}');

},{}],"7xY9y":[function(require,module,exports) {
module.exports = require("791195e188f108dc")(require("b978505f8c81376c").getBundleURL("d3gnI") + "de.bc2c59f6.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("gPCVN"));

},{"791195e188f108dc":"61B45","b978505f8c81376c":"lgJ39"}],"61B45":[function(require,module,exports) {
"use strict";
var cacheLoader = require("ca2a84f7fa4a3bb0");
module.exports = cacheLoader(function(bundle) {
    return new Promise(function(resolve, reject) {
        // Don't insert the same script twice (e.g. if it was already in the HTML)
        var existingScripts = document.getElementsByTagName("script");
        if ([].concat(existingScripts).some(function isCurrentBundle(script) {
            return script.src === bundle;
        })) {
            resolve();
            return;
        }
        var preloadLink = document.createElement("link");
        preloadLink.href = bundle;
        preloadLink.rel = "preload";
        preloadLink.as = "script";
        document.head.appendChild(preloadLink);
        var script = document.createElement("script");
        script.async = true;
        script.type = "text/javascript";
        script.src = bundle;
        script.onerror = function(e) {
            var error = new TypeError("Failed to fetch dynamically imported module: ".concat(bundle, ". Error: ").concat(e.message));
            script.onerror = script.onload = null;
            script.remove();
            reject(error);
        };
        script.onload = function() {
            script.onerror = script.onload = null;
            resolve();
        };
        document.getElementsByTagName("head")[0].appendChild(script);
    });
});

},{"ca2a84f7fa4a3bb0":"j49pS"}],"j49pS":[function(require,module,exports) {
"use strict";
var cachedBundles = {};
var cachedPreloads = {};
var cachedPrefetches = {};
function getCache(type) {
    switch(type){
        case "preload":
            return cachedPreloads;
        case "prefetch":
            return cachedPrefetches;
        default:
            return cachedBundles;
    }
}
module.exports = function(loader, type) {
    return function(bundle) {
        var cache = getCache(type);
        if (cache[bundle]) return cache[bundle];
        return cache[bundle] = loader.apply(null, arguments).catch(function(e) {
            delete cache[bundle];
            throw e;
        });
    };
};

},{}],"lgJ39":[function(require,module,exports) {
"use strict";
var bundleURL = {};
function getBundleURLCached(id) {
    var value = bundleURL[id];
    if (!value) {
        value = getBundleURL();
        bundleURL[id] = value;
    }
    return value;
}
function getBundleURL() {
    try {
        throw new Error();
    } catch (err) {
        var matches = ("" + err.stack).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^)\n]+/g);
        if (matches) // The first two stack frames will be this function and getBundleURLCached.
        // Use the 3rd one, which will be a runtime in the original bundle.
        return getBaseURL(matches[2]);
    }
    return "/";
}
function getBaseURL(url) {
    return ("" + url).replace(/^((?:https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/.+)\/[^/]+$/, "$1") + "/";
}
// TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.
function getOrigin(url) {
    var matches = ("" + url).match(/(https?|file|ftp|(chrome|moz|safari-web)-extension):\/\/[^/]+/);
    if (!matches) throw new Error("Origin not found");
    return matches[0];
}
exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;

},{}],"kFklA":[function(require,module,exports) {
module.exports = require("2a9e874f3f8f7b63")(require("f1695427e515bfc5").getBundleURL("d3gnI") + "en-GB.85d49c98.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("emVYF"));

},{"2a9e874f3f8f7b63":"61B45","f1695427e515bfc5":"lgJ39"}],"d0aNE":[function(require,module,exports) {
module.exports = require("996ad69f54599729")(require("851a76aaaf30670a").getBundleURL("d3gnI") + "en-US.07bd633b.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("jTga9"));

},{"996ad69f54599729":"61B45","851a76aaaf30670a":"lgJ39"}],"kz7MD":[function(require,module,exports) {
module.exports = require("ca8756a9cf2e640d")(require("9e8f1127652050ee").getBundleURL("d3gnI") + "en-ZA.dd3d37bd.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("h3213"));

},{"ca8756a9cf2e640d":"61B45","9e8f1127652050ee":"lgJ39"}],"3Us8O":[function(require,module,exports) {
module.exports = Promise.resolve(module.bundle.root("81RpX"));

},{}],"6u3v8":[function(require,module,exports) {
module.exports = require("beb5a7e376bd8a7a")(require("6e948dedbc5361a6").getBundleURL("d3gnI") + "fr.a0f80bea.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("c23OD"));

},{"beb5a7e376bd8a7a":"61B45","6e948dedbc5361a6":"lgJ39"}],"jY7Yl":[function(require,module,exports) {
module.exports = require("67e723cffb7c7f5d")(require("bbf717039f996cb1").getBundleURL("d3gnI") + "ja.e641fff7.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("hU4y7"));

},{"67e723cffb7c7f5d":"61B45","bbf717039f996cb1":"lgJ39"}],"cJHhi":[function(require,module,exports) {
module.exports = require("fd12c8ed6da8ad6c")(require("deca57648059285a").getBundleURL("d3gnI") + "ko.f5088a9d.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("6hVnH"));

},{"fd12c8ed6da8ad6c":"61B45","deca57648059285a":"lgJ39"}],"iakxK":[function(require,module,exports) {
module.exports = require("86f2ced352936e0e")(require("cee00ac117ae64b7").getBundleURL("d3gnI") + "ru.8c8bd043.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("itgWX"));

},{"86f2ced352936e0e":"61B45","cee00ac117ae64b7":"lgJ39"}],"kkQnx":[function(require,module,exports) {
module.exports = require("4be9cb4d70adc84f")(require("d3f130ef0d36f859").getBundleURL("d3gnI") + "zh-CN.21b77a10.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("iRXNP"));

},{"4be9cb4d70adc84f":"61B45","d3f130ef0d36f859":"lgJ39"}],"gJTRh":[function(require,module,exports) {
module.exports = require("5d3ef4901982537e")(require("8e705a6b0d7d1ef0").getBundleURL("d3gnI") + "zh-TW.dfa4013e.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("1YTLX"));

},{"5d3ef4901982537e":"61B45","8e705a6b0d7d1ef0":"lgJ39"}],"4BgqB":[function(require,module,exports) {
window.onscroll = (e)=>{
    e.preventDefault();
};

},{}],"7BZQD":[function(require,module,exports) {
module.exports = require("6858f0487398f1fd").getBundleURL("d3gnI") + "cancel.db668be7.svg" + "?" + Date.now();

},{"6858f0487398f1fd":"lgJ39"}],"ge8fi":[function(require,module,exports) {
module.exports = require("f97789d6f074c853").getBundleURL("d3gnI") + "check.f11a324e.svg" + "?" + Date.now();

},{"f97789d6f074c853":"lgJ39"}],"52d4a":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * popup that fill whole height, with some padding.
 * currently only used for iframe popups.
 */ parcelHelpers.export(exports, "DynamicModal", ()=>DynamicModal);
var _modalCount = require("../modal-count");
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
var _scrollFix = require("./scroll-fix");
var _cancelSvg = require("/src/app/img/ui/cancel.svg");
var _cancelSvgDefault = parcelHelpers.interopDefault(_cancelSvg);
class DynamicModal {
    // ---- public ----
    constructor(p){
        (0, _modalCount.dialogCounter).increase();
        this.onClose = p.onClose;
        this.parent = document.body;
        this.rootEl = (0, _bb.BB).el({
            parent: this.parent,
            className: "g-root kl-d-modal-root",
            css: {
                position: "fixed",
                left: "0",
                top: "0",
                bottom: "0",
                right: "0",
                overflow: "auto",
                animationName: "consoleIn",
                animationDuration: "0.3s",
                animationTimingFunction: "ease-out"
            },
            onClick: (0, _bb.BB).handleClick
        });
        //background element registering clicks
        this.bgEl = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                position: "absolute",
                left: "0",
                top: "0",
                bottom: "0",
                right: "0"
            },
            onClick: ()=>this.close()
        });
        //the actual popup box
        const popupEl = (0, _bb.BB).el({
            parent: this.rootEl,
            className: "kl-d-modal",
            css: {
                position: "absolute",
                width: (0, _bb.BB).isCssMinMaxSupported() ? "min(calc(100% - 40px), " + (p.width ? p.width : 400) + "px)" : (p.width ? p.width : 400) + "px",
                height: "calc(100% - 40px)",
                borderRadius: "10px",
                overflow: "hidden"
            }
        });
        //x and y position via script. flex not powerful enough imo
        this.updatePos = ()=>{
            const elW = popupEl.offsetWidth;
            const elH = popupEl.offsetHeight;
            (0, _bb.BB).css(popupEl, {
                left: Math.max(0, (window.innerWidth - elW) / 2) + "px",
                top: Math.max(20, (window.innerHeight - elH) / 2 - elH * 0.20) + "px"
            });
        };
        this.updatePos();
        window.addEventListener("resize", this.updatePos);
        //title row in popup
        const titleHeight = 40;
        const titleEl = (0, _bb.BB).el({
            parent: popupEl,
            css: {
                height: titleHeight + "px",
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                paddingLeft: titleHeight / 2 + "px"
            }
        });
        if (p.title) titleEl.append(p.title);
        this.xButton = (0, _bb.BB).el({
            parent: titleEl,
            tagName: "button",
            className: "popup-x",
            content: `<img alt="${(0, _language.LANG)("modal-close")}" height="20" src="${(0, _cancelSvgDefault.default)}">`,
            title: (0, _language.LANG)("modal-close"),
            onClick: ()=>this.close(),
            css: {
                width: titleHeight + "px",
                height: titleHeight + "px",
                lineHeight: titleHeight + "px",
                background: "none",
                boxShadow: "none"
            },
            custom: {
                tabindex: "0"
            }
        });
        const contentEl = (0, _bb.BB).el({
            parent: popupEl,
            css: {
                height: "calc(100% - " + titleHeight + "px)"
            }
        });
        if (p.content) contentEl.append(p.content);
        this.keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr, e)=>{
                if (keyStr === "esc") {
                    e.stopPropagation();
                    this.close();
                }
            }
        });
    }
    // ---- interface ----
    close() {
        (0, _modalCount.dialogCounter).decrease();
        (0, _bb.BB).destroyEl(this.rootEl);
        this.rootEl.remove();
        window.removeEventListener("resize", this.updatePos);
        this.keyListener.destroy();
        (0, _bb.BB).destroyEl(this.xButton);
        (0, _bb.BB).destroyEl(this.bgEl);
        this.onClose && this.onClose();
    }
}

},{"../modal-count":"lsSVM","../../../../bb/bb":"dcQKo","../../../../language/language":"iiYGN","./scroll-fix":"4BgqB","/src/app/img/ui/cancel.svg":"7BZQD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8fYiz":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Checkbox - with label
 */ parcelHelpers.export(exports, "Checkbox", ()=>Checkbox);
var _bb = require("../../../bb/bb");
class Checkbox {
    // --- public ---
    constructor(params){
        this.doHighlight = !!params.doHighlight;
        this.element = (0, _bb.BB).el({
            className: "kl-checkbox"
        });
        const innerEl = (0, _bb.BB).el({
            parent: this.element,
            tagName: "label",
            className: "kl-checkbox__inner",
            css: {
                display: "flex"
            }
        });
        this.check = (0, _bb.BB).el({
            parent: innerEl,
            tagName: "input",
            css: {
                margin: "0 5px 0 0"
            },
            custom: {
                type: "checkbox"
            }
        });
        this.check.checked = !!params.init;
        if (this.doHighlight && this.check.checked) this.element.classList.add("kl-checkbox--highlight");
        if (!params.allowTab) this.check.tabIndex = -1;
        if (params.title) innerEl.title = params.title;
        const label = (0, _bb.BB).el({
            parent: innerEl,
            content: params.label,
            css: {}
        });
        label.allowClick = true;
        this.check.onchange = ()=>{
            if (this.doHighlight) this.element.classList.toggle("kl-checkbox--highlight", this.check.checked);
            params.callback && params.callback(this.check.checked);
            setTimeout(()=>{
                this.check.blur();
            }, 0);
        };
        if (params.css) (0, _bb.BB).css(this.element, params.css);
    }
    getValue() {
        return this.check.checked;
    }
    setValue(b) {
        this.check.checked = !!b;
        if (this.doHighlight) this.element.classList.toggle("kl-checkbox--highlight", this.check.checked);
    }
    getElement() {
        return this.element;
    }
    destroy() {
        this.check.onchange = null;
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"je8IE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Input", ()=>Input);
parcelHelpers.export(exports, "input", ()=>input);
var _bb = require("../../../bb/bb");
class Input {
    // ---- public ----
    constructor(p){
        this.keyListener = {
            destroy: ()=>{}
        };
        this.rootEl = (0, _bb.BB).el({
            tagName: "label",
            content: p.label,
            css: {
                display: "flex",
                alignItems: "center",
                gap: "5px"
            }
        });
        this.input = (0, _bb.BB).el({
            tagName: "input",
            parent: this.rootEl,
            title: p.title
        });
        this.input.type;
        this.type = p.type ?? "text";
        try {
            this.input.type = this.type;
        } catch (e) {
        // ie can't deal with number
        }
        const stepSize = p.step ?? 1;
        if (this.type === "number") {
            if (p.min !== undefined) this.input.min = "" + p.min;
            if (p.max !== undefined) this.input.max = "" + p.max;
            if (p.step !== undefined) this.input.step = "" + stepSize;
        }
        this.input.value = "" + p.init;
        let lastValidValue = this.input.value;
        /**
         * return true if not changed
         */ const handleChange = ()=>{
            const oldVal = lastValidValue;
            let newValue = this.input.value;
            if (p.doResetIfInvalid) {
                let didChange = false;
                if (newValue === "") {
                    newValue = lastValidValue;
                    didChange = true;
                }
                if (p.min !== undefined && parseFloat(newValue) < p.min) {
                    newValue = "" + p.min;
                    didChange = true;
                }
                if (p.max !== undefined && parseFloat(newValue) > p.max) {
                    newValue = "" + p.max;
                    didChange = true;
                }
                if (didChange) this.input.value = "" + newValue;
            }
            lastValidValue = newValue;
            return oldVal !== newValue;
        };
        if (p.onChange) {
            const onChange = p.onChange;
            this.input.onchange = ()=>{
                handleChange() && onChange(this.input.value);
            };
        }
        if (p.css) (0, _bb.BB).css(this.input, p.css);
        if (p.doScrollWithoutFocus && p.type === "number" && p.onChange) {
            const onChange = p.onChange;
            this.keyListener = new (0, _bb.BB).KeyListener({});
            this.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.input,
                onWheel: (e)=>{
                    /*if (document.hasFocus()) { // what was the point of this?
                        return;
                    }*/ const fac = this.keyListener.isPressed("shift") ? 4 : 1;
                    this.input.value = "" + (parseFloat(this.input.value) - e.deltaY * stepSize * fac);
                    handleChange() && onChange(this.input.value);
                }
            });
        }
    }
    getElement() {
        return this.rootEl;
    }
    getValue() {
        return this.input.value;
    }
    setValue(v) {
        this.input.value = "" + v;
    }
    destroy() {
        this.pointerListener && this.pointerListener.destroy();
        this.keyListener.destroy();
    }
}
const input = function(params) {
    const result = document.createElement("input");
    if (params.type) try {
        result.type = params.type;
    } catch (e) {
    /* empty */ // ie can't deal with number
    }
    else result.type = "text";
    if (params.min !== undefined) result.min = "" + params.min;
    if (params.max !== undefined) result.max = "" + params.max;
    result.value = "" + params.init;
    if (params.callback) result.onchange = function() {
        params.callback(result.value);
    };
    if (params.css) (0, _bb.BB).css(result, params.css);
    return result;
};

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jmugN":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A select dropdown
 */ parcelHelpers.export(exports, "Select", ()=>Select);
var _bb = require("../../../bb/bb");
class Select {
    // --- public ---
    constructor(p){
        this.optionArr = [];
        this.selectEl = (0, _bb.BB).el({
            tagName: "select",
            title: p.title,
            className: "kl-select",
            css: {
                cursor: "pointer",
                fontSize: "15px",
                padding: "3px"
            }
        });
        if (p.css) (0, _bb.BB).css(this.selectEl, p.css);
        const isFocusable = p.isFocusable;
        if (!isFocusable) this.selectEl.tabIndex = -1;
        this.setOptionArr(p.optionArr);
        if (p.onChange) this.onChange = p.onChange;
        this.changeListener = ()=>{
            if (!isFocusable) this.selectEl.blur();
            this.onChange && this.onChange(this.getValue());
        };
        this.selectEl.addEventListener("change", this.changeListener);
        this.selectEl.value = p.initValue !== undefined ? p.initValue : "";
    }
    setValue(val) {
        this.selectEl.value = val === undefined ? "" : val;
    }
    getValue() {
        return this.selectEl.value;
    }
    setDeltaValue(delta) {
        let index = 0;
        for(let i = 0; i < this.optionArr.length; i++){
            const option = this.optionArr[i];
            if (option.item && "" + option.item[0] === this.selectEl.value) {
                index = i;
                break;
            }
        }
        index = Math.max(0, Math.min(this.optionArr.length - 1, index + delta));
        const option = this.optionArr[index];
        this.selectEl.value = option.item ? option.item[0] : "";
        this.onChange && this.onChange(this.getValue());
    }
    getElement() {
        return this.selectEl;
    }
    updateLabel(id, label) {
        this.optionArr.forEach((option)=>{
            if (option.item && option.item[0] === id && option.el) {
                option.item[1] = label;
                option.el.textContent = option.item[1];
            }
        });
    }
    setOptionArr(optionArr) {
        this.optionArr = [];
        this.selectEl.innerHTML = "";
        for(let i = 0; i < optionArr.length; i++){
            const item = optionArr[i];
            if (!item) {
                this.optionArr.push({
                    item
                });
                continue;
            }
            const el = document.createElement("option");
            el.value = item[0];
            el.textContent = item[1];
            if (item[2]) (0, _bb.BB).css(el, item[2].css);
            this.optionArr.push({
                item,
                el
            });
            this.selectEl.append(el);
        }
    }
    destroy() {
        this.selectEl.removeEventListener("change", this.changeListener);
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jkvyd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Toggle button with an image
 */ parcelHelpers.export(exports, "ImageToggle", ()=>ImageToggle);
var _bb = require("../../../bb/bb");
class ImageToggle {
    update() {
        this.rootEl.classList.toggle("image-toggle-active", this.isActive);
    }
    // --- public ---
    constructor(p){
        this.isActive = !!p.initValue;
        this.rootEl = (0, _bb.BB).el({
            className: "image-toggle",
            title: p.title,
            content: (0, _bb.BB).el({
                className: "image-toggle__im" + (p.darkInvert ? " dark-invert" : ""),
                css: {
                    backgroundImage: "url('" + p.image + "')"
                }
            }),
            onClick: (e)=>{
                e.preventDefault();
                if (p.isRadio && this.isActive) return;
                this.isActive = !this.isActive;
                this.update();
                p.onChange(this.isActive);
            }
        });
        this.update();
    }
    // --- interface ---
    setValue(b) {
        this.isActive = !!b;
        this.update();
    }
    getElement() {
        return this.rootEl;
    }
    getValue() {
        return this.isActive;
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.rootEl);
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cHp0o":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Radio input group. each one has an image
 */ parcelHelpers.export(exports, "ImageRadioList", ()=>ImageRadioList);
var _bb = require("../../../bb/bb");
var _imageToggle = require("./image-toggle");
class ImageRadioList {
    // --- public ---
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            className: "image-radio-wrapper",
            css: {
                display: "flex"
            }
        });
        this.optionArr = [];
        const select = (index, id)=>{
            this.activeIndex = index;
            for(let i = 0; i < this.optionArr.length; i++)this.optionArr[i].radioEl.setValue(i === this.activeIndex);
            p.onChange(id);
        };
        let initialIndex;
        const createOption = (index, o)=>{
            if (o.id === p.initId) initialIndex = index;
            const radioEl = new (0, _imageToggle.ImageToggle)({
                image: o.image,
                title: o.title,
                initValue: o.id === p.initId,
                isRadio: true,
                onChange: ()=>{
                    select(index, o.id);
                },
                darkInvert: o.darkInvert
            });
            this.rootEl.append(radioEl.getElement());
            return {
                id: o.id,
                radioEl
            };
        };
        for(let i = 0; i < p.optionArr.length; i++)this.optionArr.push(createOption(i, p.optionArr[i]));
        if (initialIndex === undefined) throw new Error("initId not in optionArr");
        this.activeIndex = initialIndex;
    }
    // --- interface ---
    getElement() {
        return this.rootEl;
    }
    getValue() {
        return this.optionArr[this.activeIndex].id;
    }
    destroy() {
        this.optionArr.forEach((item)=>{
            item.radioEl.destroy();
        });
    }
}

},{"../../../bb/bb":"dcQKo","./image-toggle":"jkvyd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4cmBB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createPenPressureToggle", ()=>createPenPressureToggle);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _brushPressureSvg = require("/src/app/img/ui/brush-pressure.svg");
var _brushPressureSvgDefault = parcelHelpers.interopDefault(_brushPressureSvg);
var _boxToggle = require("./box-toggle");
const createPenPressureToggle = function(isChecked, changeCallback) {
    const toggleEl = new (0, _boxToggle.BoxToggle)({
        label: (0, _bb.BB).el({
            className: "dark-invert",
            css: {
                width: "17px",
                height: "17px",
                backgroundImage: 'url("' + (0, _brushPressureSvgDefault.default) + '")',
                backgroundSize: "contain",
                backgroundRepeat: "no-repeat",
                margin: "1px",
                borderRadius: "3px"
            }
        }),
        title: (0, _language.LANG)("brush-toggle-pressure"),
        init: isChecked,
        onChange: (b)=>{
            changeCallback(b);
        }
    });
    return toggleEl.getElement();
};

},{"../../../bb/bb":"dcQKo","../../../language/language":"iiYGN","/src/app/img/ui/brush-pressure.svg":"cshKv","./box-toggle":"aQOIq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cshKv":[function(require,module,exports) {
module.exports = require("4fb633c73dece8de").getBundleURL("d3gnI") + "brush-pressure.ff13f4ad.svg" + "?" + Date.now();

},{"4fb633c73dece8de":"lgJ39"}],"aQOIq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BoxToggle", ()=>BoxToggle);
var _bb = require("../../../bb/bb");
class BoxToggle {
    update() {
        this.el.classList.toggle("kl-box-toggle--active", this.value);
    }
    // --- public ---
    constructor(p){
        this.value = !!p.init;
        this.el = (0, _bb.BB).el({
            content: p.label,
            title: p.title,
            className: typeof p.label === "string" ? "kl-box-toggle" : "kl-box-toggle kl-box-toggle--custom-el",
            onClick: ()=>{
                this.value = !this.value;
                this.update();
                p.onChange(this.value);
            },
            css: {
                cursor: "pointer"
            }
        });
        if (typeof p.label !== "string") (0, _bb.BB).css(p.label, {
            display: "block",
            pointerEvents: "none"
        });
        this.update();
    }
    getValue() {
        return this.value;
    }
    setValue(b) {
        this.value = !!b;
        this.update();
    }
    getElement() {
        return this.el;
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.el);
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4hcvv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Horizontal slider, can be changed by dragging anywhere on it. Has a label & value.
 * e.g. used for brush size
 *
 * left mouse button - set absolute value
 * right mouse button - change relative value
 * drag mouse vertically away - precision mode
 * double-click/tap slider - manual input mode
 *
 * Values can be spline interpolated
 * On change callback can be debounced
 *
 */ parcelHelpers.export(exports, "KlSlider", ()=>KlSlider);
var _bb = require("../../../bb/bb");
var _sliderFalloff = require("./slider-falloff");
var _language = require("../../../language/language");
var _klSliderManualInput = require("./kl-slider-manual-input");
class KlSlider {
    valueToSliderValue(value) {
        if (this.useSpline && this.splineInterpolator) return this.splineInterpolator.findX(value, Math.floor(this.resolution)) || 0;
        return (value - this.min) / (this.max - this.min);
    }
    sliderValueToValue(sliderValue) {
        let result = this.min + sliderValue * (this.max - this.min);
        if (this.useSpline && this.splineInterpolator) result = this.splineInterpolator.interpolate(sliderValue) || 0;
        return result;
    }
    updateLabel() {
        let displayValue = this.valueToDisplayValue(this.value);
        displayValue = this.formatFunc ? this.formatFunc(displayValue) : Math.round(displayValue);
        displayValue = displayValue.toLocaleString((0, _language.languageStrings).getCode());
        const unit = this.unit !== undefined ? this.unit : "";
        this.textEl.innerHTML = this.label + '&nbsp;&nbsp;<span style="font-weight:bold">' + displayValue + unit + "</span>";
        const sliderValue = this.valueToSliderValue(this.value);
        this.control.style.width = sliderValue * this.elementWidth + "px";
    }
    emit(isFinal) {
        if (!isFinal && this.isChangeOnFinal) return;
        if (isFinal || !this.eventResMs) {
            this.onChange(this.value);
            if (this.emitInterval) {
                clearInterval(this.emitInterval);
                this.emitInterval = undefined;
            }
            return;
        }
        if (this.emitInterval) this.emitValue = this.value;
        else {
            this.onChange(this.value);
            this.emitInterval = setInterval(()=>{
                if (this.emitValue === undefined) {
                    clearInterval(this.emitInterval);
                    this.emitInterval = undefined;
                } else {
                    this.onChange(this.emitValue);
                    this.emitValue = undefined;
                }
            }, this.eventResMs);
        }
    }
    updateEnable() {
        this.sliderWrapperEl.classList.toggle("slider-wrapper--disabled", !this.isEnabled);
        (0, _bb.BB).css(this.sliderWrapperEl, {
            opacity: this.isEnabled ? "" : "0.5",
            pointerEvents: this.isEnabled ? "" : "none"
        });
        if (this.manualInput) this.manualInput.setIsEnabled(this.isEnabled);
    }
    showManualInput() {
        this.manualInput = new (0, _klSliderManualInput.KlSliderManualInput)(this.valueToDisplayValue(this.value), this.valueToDisplayValue(this.min), this.valueToDisplayValue(this.max), this.sliderWrapperEl.getBoundingClientRect(), (val)=>{
            val = this.displayValueToValue(val);
            this.setValue((0, _bb.BB).clamp(val, this.min, this.max));
            this.onChange(this.value);
        }, ()=>{
            (0, _bb.BB).css(this.sliderWrapperEl, {
                display: ""
            });
            if (this.manualInput) {
                this.manualInput.getElement().remove();
                this.manualInput.destroy();
            }
            this.manualInput = undefined;
        }, this.manualInputRoundDigits && this.manualInputRoundDigits > 0 ? this.manualInputRoundDigits : 0);
        this.manualInput.setIsEnabled(this.isEnabled);
        this.rootEl.append(this.manualInput.getElement());
        setTimeout(()=>{
            this.manualInput && this.manualInput.focus();
        });
        (0, _bb.BB).css(this.sliderWrapperEl, {
            display: "none"
        });
    }
    // --- public ---
    constructor(p){
        this.isEnabled = p.isEnabled !== false;
        this.manualInputRoundDigits = p.manualInputRoundDigits;
        this.useSpline = !!p.curve;
        if (!p.label) throw new Error("KlSlider missing params");
        if (p.min != 0 && p.max != 0 && p.value != 0) {
            if (!p.min || !p.max || !p.value) throw new Error("KlSlider broken params");
        }
        if (p.min >= p.max) throw new Error("KlSlider broken params");
        this.min = p.min;
        this.max = p.max;
        this.value = (0, _bb.BB).clamp(p.value, this.min, this.max);
        this.elementWidth = p.width;
        this.elementHeight = p.height;
        this.resolution = p.resolution ? p.resolution : this.elementWidth * 2;
        this.onChange = p.onChange ? p.onChange : ()=>{};
        if (!p.toValue !== !p.toDisplayValue) throw new Error("both or neither have to be set, toValue and toDisplayValue");
        this.displayValueToValue = p.toValue ? p.toValue : (displayValue)=>displayValue;
        this.valueToDisplayValue = p.toDisplayValue ? p.toDisplayValue : (value)=>value;
        this.isChangeOnFinal = !!p.isChangeOnFinal;
        this.formatFunc = p.formatFunc;
        this.eventResMs = p.eventResMs;
        this.unit = p.unit;
        if (this.useSpline) {
            if (!p.curve) throw new Error("curve needs to be set if useSpline true");
            const curveArr = p.curve === "quadratic" ? (0, _bb.BB).quadraticSplineInput(this.min, this.max, 0.1) : p.curve;
            this.splineInterpolator = new (0, _bb.BB).SplineInterpolator(curveArr);
        }
        this.rootEl = (0, _bb.BB).el({
            css: {
                display: "flex"
            }
        });
        this.sliderWrapperEl = (0, _bb.BB).el({
            parent: this.rootEl,
            className: "slider-wrapper",
            css: {
                overflow: "hidden",
                position: "relative",
                width: this.elementWidth + "px",
                height: this.elementHeight + "px",
                userSelect: "none"
            }
        });
        this.rootEl.oncontextmenu = function() {
            return false;
        };
        this.label = p.label;
        const labelFontSize = this.elementHeight - 14;
        this.textEl = (0, _bb.BB).el({
            content: this.label,
            css: {
                position: "absolute",
                display: "flex",
                alignItems: "center",
                marginLeft: "7px",
                height: "100%",
                fontSize: labelFontSize + "px",
                pointerEvents: "none"
            }
        });
        this.control = (0, _bb.BB).el({
            className: "slider-inner",
            css: {
                position: "absolute",
                left: "0",
                top: "0",
                width: this.valueToSliderValue(this.value) * this.elementWidth + "px",
                height: this.elementHeight + "px"
            }
        });
        const controlInner = document.createElement("div");
        this.sliderWrapperEl.append(this.control, this.textEl);
        this.control.append(controlInner);
        this.updateEnable();
        const doubleTapper = new (0, _bb.BB).DoubleTapper({
            onDoubleTap: ()=>{
                this.showManualInput();
            }
        });
        doubleTapper.setAllowedButtonArr([
            "left",
            "right"
        ]);
        const eventChain = new (0, _bb.BB).EventChain({
            chainArr: [
                doubleTapper
            ]
        });
        let virtualVal;
        const onPointer = (event)=>{
            event.eventPreventDefault();
            if (!this.isEnabled) return;
            if (event.type === "pointerdown") {
                // unfocus manual slider input
                (0, _bb.BB).unfocusAnyInput();
                this.sliderWrapperEl.className = "slider-wrapper slider-wrapper--active";
                if (event.button === "left") {
                    let sliderValue = event.relX / this.elementWidth;
                    sliderValue = Math.max(0, Math.min(1, sliderValue));
                    this.value = this.sliderValueToValue(sliderValue);
                    this.updateLabel();
                    this.emit(false);
                }
                virtualVal = this.valueToSliderValue(this.value);
            }
            if (event.type === "pointermove" && [
                "left",
                "right"
            ].includes(event.button || "")) {
                let deltaX = event.dX;
                const deltaY = Math.abs(event.pageY - (event.downPageY || 0));
                const factor = (0, _sliderFalloff.calcSliderFalloffFactor)(deltaY, event.button === "right");
                deltaX *= factor;
                deltaX /= this.elementWidth;
                virtualVal += deltaX;
                const sliderValue = Math.max(0, Math.min(1, virtualVal));
                this.value = this.sliderValueToValue(sliderValue);
                this.updateLabel();
                this.emit(false);
            }
            if (event.type === "pointerup") {
                this.sliderWrapperEl.className = "slider-wrapper";
                this.emit(true);
            }
        };
        this.pointerListenerTimeout = setTimeout(()=>{
            this.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.sliderWrapperEl,
                fixScribble: true,
                onPointer: (e)=>{
                    onPointer(e);
                    eventChain.chainIn(e);
                },
                onWheel: (event)=>{
                    let sliderValue = this.valueToSliderValue(this.value);
                    sliderValue = (0, _bb.BB).clamp(sliderValue - event.deltaY / 40, 0, 1);
                    this.value = this.sliderValueToValue(sliderValue);
                    this.updateLabel();
                    this.onChange(this.value);
                }
            });
            this.updateLabel();
        }, 1);
    }
    changeSliderValue(f) {
        if (!this.isEnabled) return;
        let sliderValue = this.valueToSliderValue(this.value);
        sliderValue = (0, _bb.BB).clamp(sliderValue + f, 0, 1);
        this.value = this.sliderValueToValue(sliderValue);
        this.updateLabel();
        this.onChange(this.value);
    }
    setValue(v) {
        this.value = (0, _bb.BB).clamp(v, this.min, this.max);
        this.updateLabel();
    }
    getValue() {
        return this.value;
    }
    update(config) {
        this.min = config.min;
        this.max = config.max;
        this.useSpline = !!config.curve;
        if (this.useSpline) {
            if (!config.curve) throw new Error("curve needs to be set if useSpline true");
            const curveArr = config.curve === "quadratic" ? (0, _bb.BB).quadraticSplineInput(this.min, this.max, 0.1) : config.curve;
            this.splineInterpolator = new (0, _bb.BB).SplineInterpolator(curveArr);
        } else this.splineInterpolator = undefined;
        this.setIsEnabled(!config.isDisabled);
    }
    setIsEnabled(e) {
        this.isEnabled = !!e;
        this.updateEnable();
    }
    destroy() {
        clearTimeout(this.pointerListenerTimeout);
        this.pointerListener && this.pointerListener.destroy();
        if (this.manualInput) this.manualInput.destroy();
        if (this.emitInterval) clearInterval(this.emitInterval);
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"dcQKo","./slider-falloff":"8lnTu","../../../language/language":"iiYGN","./kl-slider-manual-input":"5Qr7f","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8lnTu":[function(require,module,exports) {
/**
 * To make sliders more fine-grained. The falloff when moving cursor away from cursor.
 * Returns the factor [0,1]
 *  0 -> infinite movement required for change of 1
 *  1 -> 1px movement for change of 1
 *
 * @param deltaY vertical distance from pointerdown
 * @param isRightButton
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "calcSliderFalloffFactor", ()=>calcSliderFalloffFactor);
function calcSliderFalloffFactor(deltaY, isRightButton) {
    let result = Math.min(10, 1 + Math.pow(Math.floor(deltaY / 50), 2));
    if (isRightButton) result *= 2;
    return 1 / result;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Qr7f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Used by KlSlider. Allows user to type in value in input (type=number) field, instead of dragging with mouse.
 * Input goes away when losing focus, or when pressing Enter/Escape.
 */ parcelHelpers.export(exports, "KlSliderManualInput", ()=>KlSliderManualInput);
var _bb = require("../../../bb/bb");
var _input = require("./input");
class KlSliderManualInput {
    emit() {
        if (this.lastValue !== Number(this.input.value)) {
            this.onChange(Number(this.input.value));
            this.lastValue = Number(this.input.value);
        }
    }
    privateOnClose() {
        if (this.isClosed) return;
        this.isClosed = true;
        this.emit();
        this.onClose();
        setTimeout(()=>{
            // because iPad keyboard changes the scroll position
            this.scrollBefore && window.scrollTo(this.scrollBefore.x, this.scrollBefore.y);
            this.scrollBefore = undefined;
        });
    }
    // --- public ---
    constructor(value, min, max, rect, onChange, onClose, roundDigits){
        this.onChange = onChange;
        this.onClose = onClose;
        this.isEnabled = true;
        this.isClosed = false;
        this.input = (0, _input.input)({
            type: "number",
            init: value,
            min,
            max,
            callback: (val)=>{
                this.emit();
            }
        });
        if (roundDigits !== 0) this.input.setAttribute("step", "any");
        this.input.onblur = ()=>{
            this.privateOnClose();
        };
        this.input.addEventListener("keyup", (e)=>{
            if ([
                "Enter",
                "Escape"
            ].includes(e.key)) this.privateOnClose();
            else this.emit();
        });
        this.input.addEventListener("wheel", ()=>this.emit());
        this.scrollBefore = {
            x: window.scrollX,
            y: window.scrollY
        };
        let currentValue;
        if (roundDigits || roundDigits === 0) currentValue = (0, _bb.BB).round(value, roundDigits);
        else currentValue = value;
        this.lastValue = currentValue;
        this.input.value = "" + currentValue;
        (0, _bb.BB).css(this.input, {
            width: rect.width + "px",
            height: rect.height + "px"
        });
    }
    getElement() {
        return this.input;
    }
    setIsEnabled(b) {
        this.isEnabled = !!b;
    }
    focus() {
        this.input.focus();
        this.input.select();
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.input);
    }
}

},{"../../../bb/bb":"dcQKo","./input":"je8IE","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"es6uV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * dialog for manually inputting the color
 */ parcelHelpers.export(exports, "HexColorDialog", ()=>HexColorDialog);
var _bb = require("../../../bb/bb");
var _input = require("../components/input");
var _showModal = require("./base/showModal");
var _language = require("../../../language/language");
var _copySvg = require("/src/app/img/ui/copy.svg");
var _copySvgDefault = parcelHelpers.interopDefault(_copySvg);
var _c = require("../../../bb/base/c");
var _css = require("@emotion/css");
class HexColorDialog {
    // ---- public ----
    constructor(p){
        let lastValidRgb = new (0, _bb.BB).RGB(p.color.r, p.color.g, p.color.b);
        const previewEl = (0, _bb.BB).el({
            css: {
                width: "20px",
                height: "20px",
                marginBottom: "10px",
                boxShadow: "inset 0 0 0 1px #fff, 0 0 0 1px #000",
                background: "#" + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb)
            }
        });
        // --- Hex ---
        const hexLabel = (0, _bb.BB).el({
            content: (0, _language.LANG)("mci-hex")
        });
        const hexInput = (0, _input.input)({
            init: "#" + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb),
            css: {
                width: "80px"
            },
            callback: function() {
                let rgbObj = (0, _bb.BB).ColorConverter.hexToRGB(hexInput.value);
                if (!rgbObj) {
                    rgbObj = lastValidRgb;
                    hexInput.value = "#" + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb);
                } else lastValidRgb = rgbObj;
                previewEl.style.background = "#" + (0, _bb.BB).ColorConverter.toHexString(rgbObj);
                for(let i = 0; i < rgbArr.length; i++)rgbArr[i].update();
            }
        });
        const copyButton = (0, _bb.BB).el({
            tagName: "button",
            content: '<img src="' + (0, _copySvgDefault.default) + '" height="20" alt=""/>',
            title: (0, _language.LANG)("mci-copy"),
            onClick: function() {
                hexInput.select();
                navigator.clipboard.writeText(hexInput.value).then().catch();
            }
        });
        const hexRowEl = (0, _c.c)({
            css: {
                display: "flex",
                alignItems: "center",
                marginBottom: "15px",
                flexWrap: "wrap",
                gap: "5px 10px",
                maxWidth: "250px"
            }
        }, [
            hexLabel,
            (0, _c.c)(",flex,items-center,gap-10", [
                hexInput,
                copyButton
            ])
        ]);
        setTimeout(function() {
            hexInput.focus();
            hexInput.select();
        }, 0);
        // --- R G B ---
        function createRgbInputRow(labelStr, attributeStr) {
            const inputEl = (0, _input.input)({
                init: lastValidRgb[attributeStr],
                min: 0,
                max: 255,
                type: "number",
                css: {
                    width: "80px"
                },
                callback: function() {
                    if (inputEl.value === "" || parseFloat(inputEl.value) < 0 || parseFloat(inputEl.value) > 255) {
                        result.update();
                        return;
                    }
                    inputEl.value = "" + Math.round(parseFloat(inputEl.value));
                    lastValidRgb[attributeStr] = Number(inputEl.value);
                    previewEl.style.background = "#" + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb);
                    hexInput.value = "#" + (0, _bb.BB).ColorConverter.toHexString(lastValidRgb);
                }
            });
            const rowEl = (0, _c.c)("tr", [
                (0, _c.c)("td,pr-10", labelStr),
                (0, _c.c)("td", [
                    inputEl
                ])
            ]);
            const result = {
                update: ()=>{
                    inputEl.value = "" + lastValidRgb[attributeStr];
                },
                destroy: ()=>{
                    (0, _bb.BB).unsetEventHandler(inputEl, "onchange");
                },
                element: rowEl
            };
            return result;
        }
        const rgbArr = [
            createRgbInputRow((0, _language.LANG)("red"), "r"),
            createRgbInputRow((0, _language.LANG)("green"), "g"),
            createRgbInputRow((0, _language.LANG)("blue"), "b")
        ];
        const tableCss = (0, _css.css)({
            borderCollapse: "collapse",
            "td": {
                paddingBottom: "5px"
            }
        });
        const rootEl = (0, _c.c)("", [
            previewEl,
            hexRowEl,
            (0, _c.c)("table." + tableCss, [
                (0, _c.c)("tbody", rgbArr.map((item)=>item.element))
            ])
        ]);
        (0, _showModal.showModal)({
            target: document.body,
            message: `<b>${(0, _language.LANG)("manual-color-input")}</b>`,
            div: rootEl,
            autoFocus: false,
            clickOnEnter: "Ok",
            buttons: [
                "Ok",
                "Cancel"
            ],
            callback: function(resultStr) {
                (0, _bb.BB).destroyEl(copyButton);
                rgbArr.forEach((item)=>item.destroy());
                rgbArr.splice(0, rgbArr.length);
                p.onClose(resultStr === "Ok" ? (0, _bb.BB).ColorConverter.hexToRGB(hexInput.value) : undefined);
            }
        });
    }
}

},{"../../../bb/bb":"dcQKo","../components/input":"je8IE","./base/showModal":"hr9Po","../../../language/language":"iiYGN","/src/app/img/ui/copy.svg":"i6121","../../../bb/base/c":"eg9k9","@emotion/css":"gyRZs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"i6121":[function(require,module,exports) {
module.exports = require("f4a9cc8fb9ed610d").getBundleURL("d3gnI") + "copy.afbd5028.svg" + "?" + Date.now();

},{"f4a9cc8fb9ed610d":"lgJ39"}],"eg9k9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * composes HTML
 */ parcelHelpers.export(exports, "c", ()=>c);
var _bb = require("../bb");
var _ui = require("./ui");
function decomposeElString(el) {
    if (el === "") return {};
    let split;
    let tagName;
    const classes = [];
    split = el.split(".");
    if (split.length === 1) {
        split = split[0].split(",");
        tagName = split.shift();
    } else {
        tagName = split.shift();
        split.forEach((item, index)=>{
            const isLast = index === split.length - 1;
            if (isLast) {
                split = item.split(",");
                const last = split.shift();
                if (last !== undefined) classes.push(last);
            } else classes.push(item);
        });
    }
    const result = {};
    if (tagName !== "") result.tagName = tagName;
    if (classes.length > 0) result.classes = classes;
    if (split.length > 0) result.styles = split;
    return result;
}
function applyStyleNames(el, styleNames) {
    const style = {};
    const operations = {
        c: (params)=>{
            style.color = params[0];
        },
        bg: (params)=>{
            style.background = params[0];
        },
        p: (params)=>{
            style.padding = params[0] + "px";
        },
        py: (params)=>{
            style.paddingTop = params[0] + "px";
            style.paddingBottom = params[0] + "px";
        },
        pt: (params)=>{
            style.paddingTop = params[0] + "px";
        },
        pr: (params)=>{
            style.paddingRight = params[0] + "px";
        },
        pb: (params)=>{
            style.paddingBottom = params[0] + "px";
        },
        pl: (params)=>{
            style.paddingLeft = params[0] + "px";
        },
        mt: (params)=>{
            style.marginTop = params[0] + "px";
        },
        mr: (params)=>{
            style.marginRight = params[0] + "px";
        },
        mb: (params)=>{
            style.marginBottom = params[0] + "px";
        },
        ml: (params)=>{
            style.marginLeft = params[0] + "px";
        },
        // flex
        flex: ()=>{
            style.display = "flex";
        },
        "flexCol": ()=>{
            style.flexDirection = "column";
        },
        "flexWrap": ()=>{
            style.flexWrap = "wrap";
        },
        gap: (params)=>{
            style.gap = params.map((item)=>item + "px").join(" ");
        },
        grow: ()=>{
            style.flexGrow = "1";
        },
        justify: (params)=>{
            style.justifyContent = params[0];
        },
        items: (params)=>{
            style.alignItems = params[0];
        },
        hidden: ()=>{
            style.display = "none";
        },
        nowrap: ()=>{
            style.whiteSpace = "nowrap";
        },
        abs: (params)=>{
            style.position = "absolute";
            style.left = params[0] + "px";
            style.top = params[1] + "px";
        },
        w: (params)=>{
            style.width = params[0] === "full" ? "100%" : params[0] + "px";
        },
        h: (params)=>{
            style.height = params[0] === "full" ? "100%" : params[0] + "px";
        },
        minh: (params)=>{
            style.minHeight = params[0] + "px";
        },
        z: (params)=>{
            style.zIndex = params[0];
        },
        overflow: (params)=>{
            style.overflow = params[0];
        },
        pos: (params)=>{
            style.position = params[0];
        },
        left: (params)=>{
            style.left = params[0] === "full" ? "100%" : params[0] + "px";
        },
        top: (params)=>{
            style.top = params[0] === "full" ? "100%" : params[0] + "px";
        },
        right: (params)=>{
            style.right = params[0] === "full" ? "100%" : params[0] + "px";
        },
        bottom: (params)=>{
            style.bottom = params[0] === "full" ? "100%" : params[0] + "px";
        },
        size: (params)=>{
            style.fontSize = params[0] + "px";
        },
        pointer: (params)=>{
            style.pointerEvents = params[0];
        }
    };
    styleNames.forEach((item)=>{
        const params = item.split("-");
        const operation = params.shift();
        operations[operation](params);
    });
    (0, _bb.BB).css(el, style);
}
function c(element, inner) {
    if (element === undefined) return document.createElement("div");
    if (typeof element !== "string") {
        if (!(element instanceof HTMLElement)) element = (0, _ui.el)(element);
        if (inner) {
            if (typeof inner === "string") element.innerHTML = inner;
            else element.append(...inner);
        }
        return element;
    }
    const decomp = decomposeElString(element);
    const result = document.createElement(decomp.tagName ?? "div");
    decomp.classes && result.classList.add(...decomp.classes);
    decomp.styles && applyStyleNames(result, decomp.styles);
    if (inner) {
        if (typeof inner === "string") result.innerHTML = inner;
        else result.append(...inner);
    }
    return result;
}

},{"../bb":"dcQKo","./ui":"2nyzl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gyRZs":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cache", ()=>cache);
parcelHelpers.export(exports, "css", ()=>css);
parcelHelpers.export(exports, "cx", ()=>cx);
parcelHelpers.export(exports, "flush", ()=>flush);
parcelHelpers.export(exports, "getRegisteredStyles", ()=>getRegisteredStyles);
parcelHelpers.export(exports, "hydrate", ()=>hydrate);
parcelHelpers.export(exports, "injectGlobal", ()=>injectGlobal);
parcelHelpers.export(exports, "keyframes", ()=>keyframes);
parcelHelpers.export(exports, "merge", ()=>merge);
parcelHelpers.export(exports, "sheet", ()=>sheet);
var _emotionCssCreateInstanceEsmJs = require("../create-instance/dist/emotion-css-create-instance.esm.js");
var _emotionCssCreateInstanceEsmJsDefault = parcelHelpers.interopDefault(_emotionCssCreateInstanceEsmJs);
var _cache = require("@emotion/cache");
var _serialize = require("@emotion/serialize");
var _utils = require("@emotion/utils");
var _createEmotion = (0, _emotionCssCreateInstanceEsmJsDefault.default)({
    key: "css"
}), flush = _createEmotion.flush, hydrate = _createEmotion.hydrate, cx = _createEmotion.cx, merge = _createEmotion.merge, getRegisteredStyles = _createEmotion.getRegisteredStyles, injectGlobal = _createEmotion.injectGlobal, keyframes = _createEmotion.keyframes, css = _createEmotion.css, sheet = _createEmotion.sheet, cache = _createEmotion.cache;

},{"../create-instance/dist/emotion-css-create-instance.esm.js":"k89zX","@emotion/cache":"3Umtj","@emotion/serialize":"kS2E2","@emotion/utils":"6UI8e","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k89zX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createEmotion);
var _cache = require("@emotion/cache");
var _cacheDefault = parcelHelpers.interopDefault(_cache);
var _serialize = require("@emotion/serialize");
var _utils = require("@emotion/utils");
function insertWithoutScoping(cache, serialized) {
    if (cache.inserted[serialized.name] === undefined) return cache.insert("", serialized, cache.sheet, true);
}
function merge(registered, css, className) {
    var registeredStyles = [];
    var rawClassName = (0, _utils.getRegisteredStyles)(registered, registeredStyles, className);
    if (registeredStyles.length < 2) return className;
    return rawClassName + css(registeredStyles);
}
var createEmotion = function createEmotion(options) {
    var cache = (0, _cacheDefault.default)(options); // $FlowFixMe
    cache.sheet.speedy = function(value) {
        if (this.ctr !== 0) throw new Error("speedy must be changed before any rules are inserted");
        this.isSpeedy = value;
    };
    cache.compat = true;
    var css = function css() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        var serialized = (0, _serialize.serializeStyles)(args, cache.registered, undefined);
        (0, _utils.insertStyles)(cache, serialized, false);
        return cache.key + "-" + serialized.name;
    };
    var keyframes = function keyframes() {
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
        var serialized = (0, _serialize.serializeStyles)(args, cache.registered);
        var animation = "animation-" + serialized.name;
        insertWithoutScoping(cache, {
            name: serialized.name,
            styles: "@keyframes " + animation + "{" + serialized.styles + "}"
        });
        return animation;
    };
    var injectGlobal = function injectGlobal() {
        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)args[_key3] = arguments[_key3];
        var serialized = (0, _serialize.serializeStyles)(args, cache.registered);
        insertWithoutScoping(cache, serialized);
    };
    var cx = function cx() {
        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)args[_key4] = arguments[_key4];
        return merge(cache.registered, css, classnames(args));
    };
    return {
        css: css,
        cx: cx,
        injectGlobal: injectGlobal,
        keyframes: keyframes,
        hydrate: function hydrate(ids) {
            ids.forEach(function(key) {
                cache.inserted[key] = true;
            });
        },
        flush: function flush() {
            cache.registered = {};
            cache.inserted = {};
            cache.sheet.flush();
        },
        // $FlowFixMe
        sheet: cache.sheet,
        cache: cache,
        getRegisteredStyles: (0, _utils.getRegisteredStyles).bind(null, cache.registered),
        merge: merge.bind(null, cache.registered, css)
    };
};
var classnames = function classnames(args) {
    var cls = "";
    for(var i = 0; i < args.length; i++){
        var arg = args[i];
        if (arg == null) continue;
        var toAdd = void 0;
        switch(typeof arg){
            case "boolean":
                break;
            case "object":
                if (Array.isArray(arg)) toAdd = classnames(arg);
                else {
                    toAdd = "";
                    for(var k in arg)if (arg[k] && k) {
                        toAdd && (toAdd += " ");
                        toAdd += k;
                    }
                }
                break;
            default:
                toAdd = arg;
        }
        if (toAdd) {
            cls && (cls += " ");
            cls += toAdd;
        }
    }
    return cls;
};

},{"@emotion/cache":"3Umtj","@emotion/serialize":"kS2E2","@emotion/utils":"6UI8e","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3Umtj":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>createCache);
var _sheet = require("@emotion/sheet");
var _stylis = require("stylis");
var _weakMemoize = require("@emotion/weak-memoize");
var _memoize = require("@emotion/memoize");
var identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {
    var previous = 0;
    var character = 0;
    while(true){
        previous = character;
        character = (0, _stylis.peek)(); // &\f
        if (previous === 38 && character === 12) points[index] = 1;
        if ((0, _stylis.token)(character)) break;
        (0, _stylis.next)();
    }
    return (0, _stylis.slice)(begin, (0, _stylis.position));
};
var toRules = function toRules(parsed, points) {
    // pretend we've started with a comma
    var index = -1;
    var character = 44;
    do switch((0, _stylis.token)(character)){
        case 0:
            // &\f
            if (character === 38 && (0, _stylis.peek)() === 12) // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings
            // stylis inserts \f after & to know when & where it should replace this sequence with the context selector
            // and when it should just concatenate the outer and inner selectors
            // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here
            points[index] = 1;
            parsed[index] += identifierWithPointTracking((0, _stylis.position) - 1, points, index);
            break;
        case 2:
            parsed[index] += (0, _stylis.delimit)(character);
            break;
        case 4:
            // comma
            if (character === 44) {
                // colon
                parsed[++index] = (0, _stylis.peek)() === 58 ? "&\f" : "";
                points[index] = parsed[index].length;
                break;
            }
        // fallthrough
        default:
            parsed[index] += (0, _stylis.from)(character);
    }
    while (character = (0, _stylis.next)());
    return parsed;
};
var getRules = function getRules(value, points) {
    return (0, _stylis.dealloc)(toRules((0, _stylis.alloc)(value), points));
}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11
var fixedElements = /* #__PURE__ */ new WeakMap();
var compat = function compat(element) {
    if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
    // negative .length indicates that this rule has been already prefixed
    element.length < 1) return;
    var value = element.value, parent = element.parent;
    var isImplicitRule = element.column === parent.column && element.line === parent.line;
    while(parent.type !== "rule"){
        parent = parent.parent;
        if (!parent) return;
    } // short-circuit for the simplest case
    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) return;
     // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)
    // then the props has already been manipulated beforehand as they that array is shared between it and its "rule parent"
    if (isImplicitRule) return;
    fixedElements.set(element, true);
    var points = [];
    var rules = getRules(value, points);
    var parentRules = parent.props;
    for(var i = 0, k = 0; i < rules.length; i++)for(var j = 0; j < parentRules.length; j++, k++)element.props[k] = points[i] ? rules[i].replace(/&\f/g, parentRules[j]) : parentRules[j] + " " + rules[i];
};
var removeLabel = function removeLabel(element) {
    if (element.type === "decl") {
        var value = element.value;
        if (value.charCodeAt(0) === 108 && // charcode for b
        value.charCodeAt(2) === 98) {
            // this ignores label
            element["return"] = "";
            element.value = "";
        }
    }
};
var ignoreFlag = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason";
var isIgnoringComment = function isIgnoringComment(element) {
    return element.type === "comm" && element.children.indexOf(ignoreFlag) > -1;
};
var createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {
    return function(element, index, children) {
        if (element.type !== "rule" || cache.compat) return;
        var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);
        if (unsafePseudoClasses) {
            var isNested = !!element.parent; // in nested rules comments become children of the "auto-inserted" rule and that's always the `element.parent`
            //
            // considering this input:
            // .a {
            //   .b /* comm */ {}
            //   color: hotpink;
            // }
            // we get output corresponding to this:
            // .a {
            //   & {
            //     /* comm */
            //     color: hotpink;
            //   }
            //   .b {}
            // }
            var commentContainer = isNested ? element.parent.children : children;
            for(var i = commentContainer.length - 1; i >= 0; i--){
                var node = commentContainer[i];
                if (node.line < element.line) break;
                 // it is quite weird but comments are *usually* put at `column: element.column - 1`
                // so we seek *from the end* for the node that is earlier than the rule's `element` and check that
                // this will also match inputs like this:
                // .a {
                //   /* comm */
                //   .b {}
                // }
                //
                // but that is fine
                //
                // it would be the easiest to change the placement of the comment to be the first child of the rule:
                // .a {
                //   .b { /* comm */ }
                // }
                // with such inputs we wouldn't have to search for the comment at all
                // TODO: consider changing this comment placement in the next major version
                if (node.column < element.column) {
                    if (isIgnoringComment(node)) return;
                    break;
                }
            }
            unsafePseudoClasses.forEach(function(unsafePseudoClass) {
                console.error('The pseudo class "' + unsafePseudoClass + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + unsafePseudoClass.split("-child")[0] + '-of-type".');
            });
        }
    };
};
var isImportRule = function isImportRule(element) {
    return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;
};
var isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {
    for(var i = index - 1; i >= 0; i--){
        if (!isImportRule(children[i])) return true;
    }
    return false;
}; // use this to remove incorrect elements from further processing
// so they don't get handed to the `sheet` (or anything else)
// as that could potentially lead to additional logs which in turn could be overhelming to the user
var nullifyElement = function nullifyElement(element) {
    element.type = "";
    element.value = "";
    element["return"] = "";
    element.children = "";
    element.props = "";
};
var incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {
    if (!isImportRule(element)) return;
    if (element.parent) {
        console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.");
        nullifyElement(element);
    } else if (isPrependedWithRegularRules(index, children)) {
        console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.");
        nullifyElement(element);
    }
};
/* eslint-disable no-fallthrough */ function prefix(value, length) {
    switch((0, _stylis.hash)(value, length)){
        // color-adjust
        case 5103:
            return (0, _stylis.WEBKIT) + "print-" + value + value;
        // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
            return (0, _stylis.WEBKIT) + value + value;
        // appearance, user-select, transform, hyphens, text-size-adjust
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
            return (0, _stylis.WEBKIT) + value + (0, _stylis.MOZ) + value + (0, _stylis.MS) + value + value;
        // flex, flex-direction
        case 6828:
        case 4268:
            return (0, _stylis.WEBKIT) + value + (0, _stylis.MS) + value + value;
        // order
        case 6165:
            return (0, _stylis.WEBKIT) + value + (0, _stylis.MS) + "flex-" + value + value;
        // align-items
        case 5187:
            return (0, _stylis.WEBKIT) + value + (0, _stylis.replace)(value, /(\w+).+(:[^]+)/, (0, _stylis.WEBKIT) + "box-$1$2" + (0, _stylis.MS) + "flex-$1$2") + value;
        // align-self
        case 5443:
            return (0, _stylis.WEBKIT) + value + (0, _stylis.MS) + "flex-item-" + (0, _stylis.replace)(value, /flex-|-self/, "") + value;
        // align-content
        case 4675:
            return (0, _stylis.WEBKIT) + value + (0, _stylis.MS) + "flex-line-pack" + (0, _stylis.replace)(value, /align-content|flex-|-self/, "") + value;
        // flex-shrink
        case 5548:
            return (0, _stylis.WEBKIT) + value + (0, _stylis.MS) + (0, _stylis.replace)(value, "shrink", "negative") + value;
        // flex-basis
        case 5292:
            return (0, _stylis.WEBKIT) + value + (0, _stylis.MS) + (0, _stylis.replace)(value, "basis", "preferred-size") + value;
        // flex-grow
        case 6060:
            return (0, _stylis.WEBKIT) + "box-" + (0, _stylis.replace)(value, "-grow", "") + (0, _stylis.WEBKIT) + value + (0, _stylis.MS) + (0, _stylis.replace)(value, "grow", "positive") + value;
        // transition
        case 4554:
            return (0, _stylis.WEBKIT) + (0, _stylis.replace)(value, /([^-])(transform)/g, "$1" + (0, _stylis.WEBKIT) + "$2") + value;
        // cursor
        case 6187:
            return (0, _stylis.replace)((0, _stylis.replace)((0, _stylis.replace)(value, /(zoom-|grab)/, (0, _stylis.WEBKIT) + "$1"), /(image-set)/, (0, _stylis.WEBKIT) + "$1"), value, "") + value;
        // background, background-image
        case 5495:
        case 3959:
            return (0, _stylis.replace)(value, /(image-set\([^]*)/, (0, _stylis.WEBKIT) + "$1" + "$`$1");
        // justify-content
        case 4968:
            return (0, _stylis.replace)((0, _stylis.replace)(value, /(.+:)(flex-)?(.*)/, (0, _stylis.WEBKIT) + "box-pack:$3" + (0, _stylis.MS) + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + (0, _stylis.WEBKIT) + value + value;
        // (margin|padding)-inline-(start|end)
        case 4095:
        case 3583:
        case 4068:
        case 2532:
            return (0, _stylis.replace)(value, /(.+)-inline(.+)/, (0, _stylis.WEBKIT) + "$1$2") + value;
        // (min|max)?(width|height|inline-size|block-size)
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
            // stretch, max-content, min-content, fill-available
            if ((0, _stylis.strlen)(value) - 1 - length > 6) switch((0, _stylis.charat)(value, length + 1)){
                // (m)ax-content, (m)in-content
                case 109:
                    // -
                    if ((0, _stylis.charat)(value, length + 4) !== 45) break;
                // (f)ill-available, (f)it-content
                case 102:
                    return (0, _stylis.replace)(value, /(.+:)(.+)-([^]+)/, "$1" + (0, _stylis.WEBKIT) + "$2-$3" + "$1" + (0, _stylis.MOZ) + ((0, _stylis.charat)(value, length + 3) == 108 ? "$3" : "$2-$3")) + value;
                // (s)tretch
                case 115:
                    return ~(0, _stylis.indexof)(value, "stretch") ? prefix((0, _stylis.replace)(value, "stretch", "fill-available"), length) + value : value;
            }
            break;
        // position: sticky
        case 4949:
            // (s)ticky?
            if ((0, _stylis.charat)(value, length + 1) !== 115) break;
        // display: (flex|inline-flex)
        case 6444:
            switch((0, _stylis.charat)(value, (0, _stylis.strlen)(value) - 3 - (~(0, _stylis.indexof)(value, "!important") && 10))){
                // stic(k)y
                case 107:
                    return (0, _stylis.replace)(value, ":", ":" + (0, _stylis.WEBKIT)) + value;
                // (inline-)?fl(e)x
                case 101:
                    return (0, _stylis.replace)(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + (0, _stylis.WEBKIT) + ((0, _stylis.charat)(value, 14) === 45 ? "inline-" : "") + "box$3" + "$1" + (0, _stylis.WEBKIT) + "$2$3" + "$1" + (0, _stylis.MS) + "$2box$3") + value;
            }
            break;
        // writing-mode
        case 5936:
            switch((0, _stylis.charat)(value, length + 11)){
                // vertical-l(r)
                case 114:
                    return (0, _stylis.WEBKIT) + value + (0, _stylis.MS) + (0, _stylis.replace)(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
                // vertical-r(l)
                case 108:
                    return (0, _stylis.WEBKIT) + value + (0, _stylis.MS) + (0, _stylis.replace)(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
                // horizontal(-)tb
                case 45:
                    return (0, _stylis.WEBKIT) + value + (0, _stylis.MS) + (0, _stylis.replace)(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
            }
            return (0, _stylis.WEBKIT) + value + (0, _stylis.MS) + value + value;
    }
    return value;
}
var prefixer = function prefixer(element, index, children, callback) {
    if (element.length > -1) {
        if (!element["return"]) switch(element.type){
            case 0, _stylis.DECLARATION:
                element["return"] = prefix(element.value, element.length);
                break;
            case 0, _stylis.KEYFRAMES:
                return (0, _stylis.serialize)([
                    (0, _stylis.copy)(element, {
                        value: (0, _stylis.replace)(element.value, "@", "@" + (0, _stylis.WEBKIT))
                    })
                ], callback);
            case 0, _stylis.RULESET:
                if (element.length) return (0, _stylis.combine)(element.props, function(value) {
                    switch((0, _stylis.match)(value, /(::plac\w+|:read-\w+)/)){
                        // :read-(only|write)
                        case ":read-only":
                        case ":read-write":
                            return (0, _stylis.serialize)([
                                (0, _stylis.copy)(element, {
                                    props: [
                                        (0, _stylis.replace)(value, /:(read-\w+)/, ":" + (0, _stylis.MOZ) + "$1")
                                    ]
                                })
                            ], callback);
                        // :placeholder
                        case "::placeholder":
                            return (0, _stylis.serialize)([
                                (0, _stylis.copy)(element, {
                                    props: [
                                        (0, _stylis.replace)(value, /:(plac\w+)/, ":" + (0, _stylis.WEBKIT) + "input-$1")
                                    ]
                                }),
                                (0, _stylis.copy)(element, {
                                    props: [
                                        (0, _stylis.replace)(value, /:(plac\w+)/, ":" + (0, _stylis.MOZ) + "$1")
                                    ]
                                }),
                                (0, _stylis.copy)(element, {
                                    props: [
                                        (0, _stylis.replace)(value, /:(plac\w+)/, (0, _stylis.MS) + "input-$1")
                                    ]
                                })
                            ], callback);
                    }
                    return "";
                });
        }
    }
};
var defaultStylisPlugins = [
    prefixer
];
var createCache = function createCache(options) {
    var key = options.key;
    if (!key) throw new Error("You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\nIf multiple caches share the same key they might \"fight\" for each other's style elements.");
    if (key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])"); // get SSRed styles out of the way of React's hydration
        // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)
        // note this very very intentionally targets all style elements regardless of the key to ensure
        // that creating a cache works inside of render of a React component
        Array.prototype.forEach.call(ssrStyles, function(node) {
            // we want to only move elements which have a space in the data-emotion attribute value
            // because that indicates that it is an Emotion 11 server-side rendered style elements
            // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector
            // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)
            // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles
            // will not result in the Emotion 10 styles being destroyed
            var dataEmotionAttribute = node.getAttribute("data-emotion");
            if (dataEmotionAttribute.indexOf(" ") === -1) return;
            document.head.appendChild(node);
            node.setAttribute("data-s", "");
        });
    }
    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
    // $FlowFixMe
    if (/[^a-z-]/.test(key)) throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + key + '" was passed');
    var inserted = {};
    var container;
    var nodesToHydrate = [];
    container = options.container || document.head;
    Array.prototype.forEach.call(// means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + key + ' "]'), function(node) {
        var attrib = node.getAttribute("data-emotion").split(" "); // $FlowFixMe
        for(var i = 1; i < attrib.length; i++)inserted[attrib[i]] = true;
        nodesToHydrate.push(node);
    });
    var _insert;
    var omnipresentPlugins = [
        compat,
        removeLabel
    ];
    omnipresentPlugins.push(createUnsafeSelectorsAlarm({
        get compat () {
            return cache.compat;
        }
    }), incorrectImportAlarm);
    var currentSheet;
    var finalizingPlugins = [
        (0, _stylis.stringify),
        function(element) {
            if (!element.root) {
                if (element["return"]) currentSheet.insert(element["return"]);
                else if (element.value && element.type !== (0, _stylis.COMMENT)) // insert empty rule in non-production environments
                // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet
                currentSheet.insert(element.value + "{}");
            }
        }
    ];
    var serializer = (0, _stylis.middleware)(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis(styles) {
        return (0, _stylis.serialize)((0, _stylis.compile)(styles), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
        currentSheet = sheet;
        if (serialized.map !== undefined) currentSheet = {
            insert: function insert(rule) {
                sheet.insert(rule + serialized.map);
            }
        };
        stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
        if (shouldCache) cache.inserted[serialized.name] = true;
    };
    var cache = {
        key: key,
        sheet: new (0, _sheet.StyleSheet)({
            key: key,
            container: container,
            nonce: options.nonce,
            speedy: options.speedy,
            prepend: options.prepend,
            insertionPoint: options.insertionPoint
        }),
        nonce: options.nonce,
        inserted: inserted,
        registered: {},
        insert: _insert
    };
    cache.sheet.hydrate(nodesToHydrate);
    return cache;
};

},{"@emotion/sheet":"1BWeq","stylis":"bMCXt","@emotion/weak-memoize":"grJxk","@emotion/memoize":"2vzJd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1BWeq":[function(require,module,exports) {
/*

Based off glamor's StyleSheet, thanks Sunil ❤️

high performance StyleSheet for css-in-js systems

- uses multiple style tags behind the scenes for millions of rules
- uses `insertRule` for appending in production for *much* faster performance

// usage

import { StyleSheet } from '@emotion/sheet'

let styleSheet = new StyleSheet({ key: '', container: document.head })

styleSheet.insert('#box { border: 1px solid red; }')
- appends a css rule into the stylesheet

styleSheet.flush()
- empties the stylesheet of all its contents

*/ // $FlowFixMe
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "StyleSheet", ()=>StyleSheet);
function sheetForTag(tag) {
    if (tag.sheet) // $FlowFixMe
    return tag.sheet;
     // this weirdness brought to you by firefox
    /* istanbul ignore next */ for(var i = 0; i < document.styleSheets.length; i++){
        if (document.styleSheets[i].ownerNode === tag) // $FlowFixMe
        return document.styleSheets[i];
    }
}
function createStyleElement(options) {
    var tag = document.createElement("style");
    tag.setAttribute("data-emotion", options.key);
    if (options.nonce !== undefined) tag.setAttribute("nonce", options.nonce);
    tag.appendChild(document.createTextNode(""));
    tag.setAttribute("data-s", "");
    return tag;
}
var StyleSheet = /*#__PURE__*/ function() {
    // Using Node instead of HTMLElement since container may be a ShadowRoot
    function StyleSheet(options) {
        var _this = this;
        this._insertTag = function(tag) {
            var before;
            if (_this.tags.length === 0) {
                if (_this.insertionPoint) before = _this.insertionPoint.nextSibling;
                else if (_this.prepend) before = _this.container.firstChild;
                else before = _this.before;
            } else before = _this.tags[_this.tags.length - 1].nextSibling;
            _this.container.insertBefore(tag, before);
            _this.tags.push(tag);
        };
        this.isSpeedy = options.speedy === undefined ? false : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets
        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.insertionPoint = options.insertionPoint;
        this.before = null;
    }
    var _proto = StyleSheet.prototype;
    _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
    };
    _proto.insert = function insert(rule) {
        // the max length is how many rules we have per style tag, it's 65000 in speedy mode
        // it's 1 in dev because we insert source maps that map a single rule to a location
        // and you can only have one source map per style tag
        if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) this._insertTag(createStyleElement(this));
        var tag = this.tags[this.tags.length - 1];
        var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;
        if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) // this would only cause problem in speedy mode
        // but we don't want enabling speedy to affect the observable behavior
        // so we report this error at all times
        console.error("You're attempting to insert the following rule:\n" + rule + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.");
        this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;
        if (this.isSpeedy) {
            var sheet = sheetForTag(tag);
            try {
                // this is the ultrafast version, works across browsers
                // the big drawback is that the css won't be editable in devtools
                sheet.insertRule(rule, sheet.cssRules.length);
            } catch (e) {
                if (!/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) console.error('There was a problem inserting the following rule: "' + rule + '"', e);
            }
        } else tag.appendChild(document.createTextNode(rule));
        this.ctr++;
    };
    _proto.flush = function flush() {
        // $FlowFixMe
        this.tags.forEach(function(tag) {
            return tag.parentNode && tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
        this._alreadyInsertedOrderInsensitiveRule = false;
    };
    return StyleSheet;
}();

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bMCXt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "CHARSET", ()=>f);
parcelHelpers.export(exports, "COMMENT", ()=>n);
parcelHelpers.export(exports, "COUNTER_STYLE", ()=>w);
parcelHelpers.export(exports, "DECLARATION", ()=>s);
parcelHelpers.export(exports, "DOCUMENT", ()=>v);
parcelHelpers.export(exports, "FONT_FACE", ()=>b);
parcelHelpers.export(exports, "FONT_FEATURE_VALUES", ()=>d);
parcelHelpers.export(exports, "IMPORT", ()=>i);
parcelHelpers.export(exports, "KEYFRAMES", ()=>h);
parcelHelpers.export(exports, "LAYER", ()=>$);
parcelHelpers.export(exports, "MEDIA", ()=>u);
parcelHelpers.export(exports, "MOZ", ()=>r);
parcelHelpers.export(exports, "MS", ()=>e);
parcelHelpers.export(exports, "NAMESPACE", ()=>p);
parcelHelpers.export(exports, "PAGE", ()=>t);
parcelHelpers.export(exports, "RULESET", ()=>c);
parcelHelpers.export(exports, "SUPPORTS", ()=>l);
parcelHelpers.export(exports, "VIEWPORT", ()=>o);
parcelHelpers.export(exports, "WEBKIT", ()=>a);
parcelHelpers.export(exports, "abs", ()=>g);
parcelHelpers.export(exports, "alloc", ()=>V);
parcelHelpers.export(exports, "append", ()=>q);
parcelHelpers.export(exports, "assign", ()=>m);
parcelHelpers.export(exports, "caret", ()=>R);
parcelHelpers.export(exports, "char", ()=>L);
parcelHelpers.export(exports, "character", ()=>H);
parcelHelpers.export(exports, "characters", ()=>I);
parcelHelpers.export(exports, "charat", ()=>O);
parcelHelpers.export(exports, "column", ()=>E);
parcelHelpers.export(exports, "combine", ()=>B);
parcelHelpers.export(exports, "comment", ()=>ue);
parcelHelpers.export(exports, "commenter", ()=>ae);
parcelHelpers.export(exports, "compile", ()=>ce);
parcelHelpers.export(exports, "copy", ()=>K);
parcelHelpers.export(exports, "dealloc", ()=>W);
parcelHelpers.export(exports, "declaration", ()=>ie);
parcelHelpers.export(exports, "delimit", ()=>X);
parcelHelpers.export(exports, "delimiter", ()=>re);
parcelHelpers.export(exports, "escaping", ()=>ee);
parcelHelpers.export(exports, "from", ()=>k);
parcelHelpers.export(exports, "hash", ()=>x);
parcelHelpers.export(exports, "identifier", ()=>ne);
parcelHelpers.export(exports, "indexof", ()=>C);
parcelHelpers.export(exports, "length", ()=>F);
parcelHelpers.export(exports, "line", ()=>D);
parcelHelpers.export(exports, "match", ()=>j);
parcelHelpers.export(exports, "middleware", ()=>ve);
parcelHelpers.export(exports, "namespace", ()=>be);
parcelHelpers.export(exports, "next", ()=>P);
parcelHelpers.export(exports, "node", ()=>J);
parcelHelpers.export(exports, "parse", ()=>se);
parcelHelpers.export(exports, "peek", ()=>Q);
parcelHelpers.export(exports, "position", ()=>G);
parcelHelpers.export(exports, "prefix", ()=>fe);
parcelHelpers.export(exports, "prefixer", ()=>he);
parcelHelpers.export(exports, "prev", ()=>N);
parcelHelpers.export(exports, "replace", ()=>z);
parcelHelpers.export(exports, "ruleset", ()=>te);
parcelHelpers.export(exports, "rulesheet", ()=>pe);
parcelHelpers.export(exports, "serialize", ()=>oe);
parcelHelpers.export(exports, "sizeof", ()=>S);
parcelHelpers.export(exports, "slice", ()=>T);
parcelHelpers.export(exports, "stringify", ()=>le);
parcelHelpers.export(exports, "strlen", ()=>M);
parcelHelpers.export(exports, "substr", ()=>A);
parcelHelpers.export(exports, "token", ()=>U);
parcelHelpers.export(exports, "tokenize", ()=>Y);
parcelHelpers.export(exports, "tokenizer", ()=>_);
parcelHelpers.export(exports, "trim", ()=>y);
parcelHelpers.export(exports, "whitespace", ()=>Z);
var e = "-ms-";
var r = "-moz-";
var a = "-webkit-";
var n = "comm";
var c = "rule";
var s = "decl";
var t = "@page";
var u = "@media";
var i = "@import";
var f = "@charset";
var o = "@viewport";
var l = "@supports";
var v = "@document";
var p = "@namespace";
var h = "@keyframes";
var b = "@font-face";
var w = "@counter-style";
var d = "@font-feature-values";
var $ = "@layer";
var g = Math.abs;
var k = String.fromCharCode;
var m = Object.assign;
function x(e, r) {
    return O(e, 0) ^ 45 ? (((r << 2 ^ O(e, 0)) << 2 ^ O(e, 1)) << 2 ^ O(e, 2)) << 2 ^ O(e, 3) : 0;
}
function y(e) {
    return e.trim();
}
function j(e, r) {
    return (e = r.exec(e)) ? e[0] : e;
}
function z(e, r, a) {
    return e.replace(r, a);
}
function C(e, r) {
    return e.indexOf(r);
}
function O(e, r) {
    return e.charCodeAt(r) | 0;
}
function A(e, r, a) {
    return e.slice(r, a);
}
function M(e) {
    return e.length;
}
function S(e) {
    return e.length;
}
function q(e, r) {
    return r.push(e), e;
}
function B(e, r) {
    return e.map(r).join("");
}
var D = 1;
var E = 1;
var F = 0;
var G = 0;
var H = 0;
var I = "";
function J(e, r, a, n, c, s, t) {
    return {
        value: e,
        root: r,
        parent: a,
        type: n,
        props: c,
        children: s,
        line: D,
        column: E,
        length: t,
        return: ""
    };
}
function K(e, r) {
    return m(J("", null, null, "", null, null, 0), e, {
        length: -e.length
    }, r);
}
function L() {
    return H;
}
function N() {
    H = G > 0 ? O(I, --G) : 0;
    if (E--, H === 10) E = 1, D--;
    return H;
}
function P() {
    H = G < F ? O(I, G++) : 0;
    if (E++, H === 10) E = 1, D++;
    return H;
}
function Q() {
    return O(I, G);
}
function R() {
    return G;
}
function T(e, r) {
    return A(I, e, r);
}
function U(e) {
    switch(e){
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
            return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
            return 4;
        case 58:
            return 3;
        case 34:
        case 39:
        case 40:
        case 91:
            return 2;
        case 41:
        case 93:
            return 1;
    }
    return 0;
}
function V(e) {
    return D = E = 1, F = M(I = e), G = 0, [];
}
function W(e) {
    return I = "", e;
}
function X(e) {
    return y(T(G - 1, re(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
}
function Y(e) {
    return W(_(V(e)));
}
function Z(e) {
    while(H = Q())if (H < 33) P();
    else break;
    return U(e) > 2 || U(H) > 3 ? "" : " ";
}
function _(e) {
    while(P())switch(U(H)){
        case 0:
            q(ne(G - 1), e);
            break;
        case 2:
            q(X(H), e);
            break;
        default:
            q(k(H), e);
    }
    return e;
}
function ee(e, r) {
    while(--r && P())if (H < 48 || H > 102 || H > 57 && H < 65 || H > 70 && H < 97) break;
    return T(e, R() + (r < 6 && Q() == 32 && P() == 32));
}
function re(e) {
    while(P())switch(H){
        case e:
            return G;
        case 34:
        case 39:
            if (e !== 34 && e !== 39) re(H);
            break;
        case 40:
            if (e === 41) re(e);
            break;
        case 92:
            P();
            break;
    }
    return G;
}
function ae(e, r) {
    while(P())if (e + H === 57) break;
    else if (e + H === 84 && Q() === 47) break;
    return "/*" + T(r, G - 1) + "*" + k(e === 47 ? e : P());
}
function ne(e) {
    while(!U(Q()))P();
    return T(e, G);
}
function ce(e) {
    return W(se("", null, null, null, [
        ""
    ], e = V(e), 0, [
        0
    ], e));
}
function se(e, r, a, n, c, s, t, u, i) {
    var f = 0;
    var o = 0;
    var l = t;
    var v = 0;
    var p = 0;
    var h = 0;
    var b = 1;
    var w = 1;
    var d = 1;
    var $ = 0;
    var g = "";
    var m = c;
    var x = s;
    var y = n;
    var j = g;
    while(w)switch(h = $, $ = P()){
        case 40:
            if (h != 108 && O(j, l - 1) == 58) {
                if (C(j += z(X($), "&", "&\f"), "&\f") != -1) d = -1;
                break;
            }
        case 34:
        case 39:
        case 91:
            j += X($);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            j += Z(h);
            break;
        case 92:
            j += ee(R() - 1, 7);
            continue;
        case 47:
            switch(Q()){
                case 42:
                case 47:
                    q(ue(ae(P(), R()), r, a), i);
                    break;
                default:
                    j += "/";
            }
            break;
        case 123 * b:
            u[f++] = M(j) * d;
        case 125 * b:
        case 59:
        case 0:
            switch($){
                case 0:
                case 125:
                    w = 0;
                case 59 + o:
                    if (d == -1) j = z(j, /\f/g, "");
                    if (p > 0 && M(j) - l) q(p > 32 ? ie(j + ";", n, a, l - 1) : ie(z(j, " ", "") + ";", n, a, l - 2), i);
                    break;
                case 59:
                    j += ";";
                default:
                    q(y = te(j, r, a, f, o, c, u, g, m = [], x = [], l), s);
                    if ($ === 123) {
                        if (o === 0) se(j, r, y, y, m, s, l, u, x);
                        else switch(v === 99 && O(j, 3) === 110 ? 100 : v){
                            case 100:
                            case 108:
                            case 109:
                            case 115:
                                se(e, y, y, n && q(te(e, y, y, 0, 0, c, u, g, c, m = [], l), x), c, x, l, u, n ? m : x);
                                break;
                            default:
                                se(j, y, y, y, [
                                    ""
                                ], x, 0, u, x);
                        }
                    }
            }
            f = o = p = 0, b = d = 1, g = j = "", l = t;
            break;
        case 58:
            l = 1 + M(j), p = h;
        default:
            if (b < 1) {
                if ($ == 123) --b;
                else if ($ == 125 && b++ == 0 && N() == 125) continue;
            }
            switch(j += k($), $ * b){
                case 38:
                    d = o > 0 ? 1 : (j += "\f", -1);
                    break;
                case 44:
                    u[f++] = (M(j) - 1) * d, d = 1;
                    break;
                case 64:
                    if (Q() === 45) j += X(P());
                    v = Q(), o = l = M(g = j += ne(R())), $++;
                    break;
                case 45:
                    if (h === 45 && M(j) == 2) b = 0;
            }
    }
    return s;
}
function te(e, r, a, n, s, t, u, i, f, o, l) {
    var v = s - 1;
    var p = s === 0 ? t : [
        ""
    ];
    var h = S(p);
    for(var b = 0, w = 0, d = 0; b < n; ++b)for(var $ = 0, k = A(e, v + 1, v = g(w = u[b])), m = e; $ < h; ++$)if (m = y(w > 0 ? p[$] + " " + k : z(k, /&\f/g, p[$]))) f[d++] = m;
    return J(e, r, a, s === 0 ? c : i, f, o, l);
}
function ue(e, r, a) {
    return J(e, r, a, n, k(L()), A(e, 2, -2), 0);
}
function ie(e, r, a, n) {
    return J(e, r, a, s, A(e, 0, n), A(e, n + 1, -1), n);
}
function fe(n, c, s) {
    switch(x(n, c)){
        case 5103:
            return a + "print-" + n + n;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
            return a + n + n;
        case 4789:
            return r + n + n;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
            return a + n + r + n + e + n + n;
        case 5936:
            switch(O(n, c + 11)){
                case 114:
                    return a + n + e + z(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
                case 108:
                    return a + n + e + z(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
                case 45:
                    return a + n + e + z(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
            }
        case 6828:
        case 4268:
        case 2903:
            return a + n + e + n + n;
        case 6165:
            return a + n + e + "flex-" + n + n;
        case 5187:
            return a + n + z(n, /(\w+).+(:[^]+)/, a + "box-$1$2" + e + "flex-$1$2") + n;
        case 5443:
            return a + n + e + "flex-item-" + z(n, /flex-|-self/g, "") + (!j(n, /flex-|baseline/) ? e + "grid-row-" + z(n, /flex-|-self/g, "") : "") + n;
        case 4675:
            return a + n + e + "flex-line-pack" + z(n, /align-content|flex-|-self/g, "") + n;
        case 5548:
            return a + n + e + z(n, "shrink", "negative") + n;
        case 5292:
            return a + n + e + z(n, "basis", "preferred-size") + n;
        case 6060:
            return a + "box-" + z(n, "-grow", "") + a + n + e + z(n, "grow", "positive") + n;
        case 4554:
            return a + z(n, /([^-])(transform)/g, "$1" + a + "$2") + n;
        case 6187:
            return z(z(z(n, /(zoom-|grab)/, a + "$1"), /(image-set)/, a + "$1"), n, "") + n;
        case 5495:
        case 3959:
            return z(n, /(image-set\([^]*)/, a + "$1" + "$`$1");
        case 4968:
            return z(z(n, /(.+:)(flex-)?(.*)/, a + "box-pack:$3" + e + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + a + n + n;
        case 4200:
            if (!j(n, /flex-|baseline/)) return e + "grid-column-align" + A(n, c) + n;
            break;
        case 2592:
        case 3360:
            return e + z(n, "template-", "") + n;
        case 4384:
        case 3616:
            if (s && s.some(function(e, r) {
                return c = r, j(e.props, /grid-\w+-end/);
            })) return ~C(n + (s = s[c].value), "span") ? n : e + z(n, "-start", "") + n + e + "grid-row-span:" + (~C(s, "span") ? j(s, /\d+/) : +j(s, /\d+/) - +j(n, /\d+/)) + ";";
            return e + z(n, "-start", "") + n;
        case 4896:
        case 4128:
            return s && s.some(function(e) {
                return j(e.props, /grid-\w+-start/);
            }) ? n : e + z(z(n, "-end", "-span"), "span ", "") + n;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
            return z(n, /(.+)-inline(.+)/, a + "$1$2") + n;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
            if (M(n) - 1 - c > 6) switch(O(n, c + 1)){
                case 109:
                    if (O(n, c + 4) !== 45) break;
                case 102:
                    return z(n, /(.+:)(.+)-([^]+)/, "$1" + a + "$2-$3" + "$1" + r + (O(n, c + 3) == 108 ? "$3" : "$2-$3")) + n;
                case 115:
                    return ~C(n, "stretch") ? fe(z(n, "stretch", "fill-available"), c, s) + n : n;
            }
            break;
        case 5152:
        case 5920:
            return z(n, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(r, a, c, s, t, u, i) {
                return e + a + ":" + c + i + (s ? e + a + "-span:" + (t ? u : +u - +c) + i : "") + n;
            });
        case 4949:
            if (O(n, c + 6) === 121) return z(n, ":", ":" + a) + n;
            break;
        case 6444:
            switch(O(n, O(n, 14) === 45 ? 18 : 11)){
                case 120:
                    return z(n, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + a + (O(n, 14) === 45 ? "inline-" : "") + "box$3" + "$1" + a + "$2$3" + "$1" + e + "$2box$3") + n;
                case 100:
                    return z(n, ":", ":" + e) + n;
            }
            break;
        case 5719:
        case 2647:
        case 2135:
        case 3927:
        case 2391:
            return z(n, "scroll-", "scroll-snap-") + n;
    }
    return n;
}
function oe(e, r) {
    var a = "";
    var n = S(e);
    for(var c = 0; c < n; c++)a += r(e[c], c, e, r) || "";
    return a;
}
function le(e, r, a, t) {
    switch(e.type){
        case $:
            if (e.children.length) break;
        case i:
        case s:
            return e.return = e.return || e.value;
        case n:
            return "";
        case h:
            return e.return = e.value + "{" + oe(e.children, t) + "}";
        case c:
            e.value = e.props.join(",");
    }
    return M(a = oe(e.children, t)) ? e.return = e.value + "{" + a + "}" : "";
}
function ve(e) {
    var r = S(e);
    return function(a, n, c, s) {
        var t = "";
        for(var u = 0; u < r; u++)t += e[u](a, n, c, s) || "";
        return t;
    };
}
function pe(e) {
    return function(r) {
        if (!r.root) {
            if (r = r.return) e(r);
        }
    };
}
function he(n, t, u, i) {
    if (n.length > -1) {
        if (!n.return) switch(n.type){
            case s:
                n.return = fe(n.value, n.length, u);
                return;
            case h:
                return oe([
                    K(n, {
                        value: z(n.value, "@", "@" + a)
                    })
                ], i);
            case c:
                if (n.length) return B(n.props, function(c) {
                    switch(j(c, /(::plac\w+|:read-\w+)/)){
                        case ":read-only":
                        case ":read-write":
                            return oe([
                                K(n, {
                                    props: [
                                        z(c, /:(read-\w+)/, ":" + r + "$1")
                                    ]
                                })
                            ], i);
                        case "::placeholder":
                            return oe([
                                K(n, {
                                    props: [
                                        z(c, /:(plac\w+)/, ":" + a + "input-$1")
                                    ]
                                }),
                                K(n, {
                                    props: [
                                        z(c, /:(plac\w+)/, ":" + r + "$1")
                                    ]
                                }),
                                K(n, {
                                    props: [
                                        z(c, /:(plac\w+)/, e + "input-$1")
                                    ]
                                })
                            ], i);
                    }
                    return "";
                });
        }
    }
}
function be(e) {
    switch(e.type){
        case c:
            e.props = e.props.map(function(r) {
                return B(Y(r), function(r, a, n) {
                    switch(O(r, 0)){
                        case 12:
                            return A(r, 1, M(r));
                        case 0:
                        case 40:
                        case 43:
                        case 62:
                        case 126:
                            return r;
                        case 58:
                            if (n[++a] === "global") n[a] = "", n[++a] = "\f" + A(n[a], a = 1, -1);
                        case 32:
                            return a === 1 ? "" : r;
                        default:
                            switch(a){
                                case 0:
                                    e = r;
                                    return S(n) > 1 ? "" : r;
                                case a = S(n) - 1:
                                case 2:
                                    return a === 2 ? r + e + e : r + e;
                                default:
                                    return r;
                            }
                    }
                });
            });
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"grJxk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>weakMemoize);
var weakMemoize = function weakMemoize(func) {
    // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps
    var cache = new WeakMap();
    return function(arg) {
        if (cache.has(arg)) // $FlowFixMe
        return cache.get(arg);
        var ret = func(arg);
        cache.set(arg, ret);
        return ret;
    };
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2vzJd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>memoize);
function memoize(fn) {
    var cache = Object.create(null);
    return function(arg) {
        if (cache[arg] === undefined) cache[arg] = fn(arg);
        return cache[arg];
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kS2E2":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "serializeStyles", ()=>serializeStyles);
var _hash = require("@emotion/hash");
var _hashDefault = parcelHelpers.interopDefault(_hash);
var _unitless = require("@emotion/unitless");
var _unitlessDefault = parcelHelpers.interopDefault(_unitless);
var _memoize = require("@emotion/memoize");
var _memoizeDefault = parcelHelpers.interopDefault(_memoize);
var ILLEGAL_ESCAPE_SEQUENCE_ERROR = "You have illegal escape sequence in your template literal, most likely inside content's property value.\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \"content: '\\00d7';\" should become \"content: '\\\\00d7';\".\nYou can read more about this here:\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences";
var UNDEFINED_AS_OBJECT_KEY_ERROR = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).";
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty(property) {
    return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue(value) {
    return value != null && typeof value !== "boolean";
};
var processStyleName = /* #__PURE__ */ (0, _memoizeDefault.default)(function(styleName) {
    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue(key, value) {
    switch(key){
        case "animation":
        case "animationName":
            if (typeof value === "string") return value.replace(animationRegex, function(match, p1, p2) {
                cursor = {
                    name: p1,
                    styles: p2,
                    next: cursor
                };
                return p1;
            });
    }
    if ((0, _unitlessDefault.default)[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) return value + "px";
    return value;
};
var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/;
var contentValues = [
    "normal",
    "none",
    "initial",
    "inherit",
    "unset"
];
var oldProcessStyleValue = processStyleValue;
var msPattern = /^-ms-/;
var hyphenPattern = /-(.)/g;
var hyphenatedCache = {};
processStyleValue = function processStyleValue(key, value) {
    if (key === "content") {
        if (typeof value !== "string" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '"' && value.charAt(0) !== "'")) throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + value + "\"'`");
    }
    var processed = oldProcessStyleValue(key, value);
    if (processed !== "" && !isCustomProperty(key) && key.indexOf("-") !== -1 && hyphenatedCache[key] === undefined) {
        hyphenatedCache[key] = true;
        console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + key.replace(msPattern, "ms-").replace(hyphenPattern, function(str, _char) {
            return _char.toUpperCase();
        }) + "?");
    }
    return processed;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
    if (interpolation == null) return "";
    if (interpolation.__emotion_styles !== undefined) {
        if (interpolation.toString() === "NO_COMPONENT_SELECTOR") throw new Error(noComponentSelectorMessage);
        return interpolation;
    }
    switch(typeof interpolation){
        case "boolean":
            return "";
        case "object":
            if (interpolation.anim === 1) {
                cursor = {
                    name: interpolation.name,
                    styles: interpolation.styles,
                    next: cursor
                };
                return interpolation.name;
            }
            if (interpolation.styles !== undefined) {
                var next = interpolation.next;
                if (next !== undefined) // not the most efficient thing ever but this is a pretty rare case
                // and there will be very few iterations of this generally
                while(next !== undefined){
                    cursor = {
                        name: next.name,
                        styles: next.styles,
                        next: cursor
                    };
                    next = next.next;
                }
                var styles = interpolation.styles + ";";
                if (interpolation.map !== undefined) styles += interpolation.map;
                return styles;
            }
            return createStringFromObject(mergedProps, registered, interpolation);
        case "function":
            if (mergedProps !== undefined) {
                var previousCursor = cursor;
                var result = interpolation(mergedProps);
                cursor = previousCursor;
                return handleInterpolation(mergedProps, registered, result);
            } else console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
            break;
        case "string":
            var matched = [];
            var replaced = interpolation.replace(animationRegex, function(match, p1, p2) {
                var fakeVarName = "animation" + matched.length;
                matched.push("const " + fakeVarName + " = keyframes`" + p2.replace(/^@keyframes animation-\w+/, "") + "`");
                return "${" + fakeVarName + "}";
            });
            if (matched.length) console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(matched, [
                "`" + replaced + "`"
            ]).join("\n") + "\n\nYou should wrap it with `css` like this:\n\n" + ("css`" + replaced + "`"));
            break;
    } // finalize string values (regular strings and functions interpolated into css calls)
    if (registered == null) return interpolation;
    var cached = registered[interpolation];
    return cached !== undefined ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
    var string = "";
    if (Array.isArray(obj)) for(var i = 0; i < obj.length; i++)string += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    else for(var _key in obj){
        var value = obj[_key];
        if (typeof value !== "object") {
            if (registered != null && registered[value] !== undefined) string += _key + "{" + registered[value] + "}";
            else if (isProcessableValue(value)) string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        } else {
            if (_key === "NO_COMPONENT_SELECTOR" && true) throw new Error(noComponentSelectorMessage);
            if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === undefined)) {
                for(var _i = 0; _i < value.length; _i++)if (isProcessableValue(value[_i])) string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            } else {
                var interpolated = handleInterpolation(mergedProps, registered, value);
                switch(_key){
                    case "animation":
                    case "animationName":
                        string += processStyleName(_key) + ":" + interpolated + ";";
                        break;
                    default:
                        if (_key === "undefined") console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);
                        string += _key + "{" + interpolated + "}";
                }
            }
        }
    }
    return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var sourceMapPattern;
sourceMapPattern = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g;
// keyframes are stored on the SerializedStyles object as a linked list
var cursor;
var serializeStyles = function serializeStyles(args, registered, mergedProps) {
    if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== undefined) return args[0];
    var stringMode = true;
    var styles = "";
    cursor = undefined;
    var strings = args[0];
    if (strings == null || strings.raw === undefined) {
        stringMode = false;
        styles += handleInterpolation(mergedProps, registered, strings);
    } else {
        if (strings[0] === undefined) console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
        styles += strings[0];
    } // we start at 1 since we've already handled the first arg
    for(var i = 1; i < args.length; i++){
        styles += handleInterpolation(mergedProps, registered, args[i]);
        if (stringMode) {
            if (strings[i] === undefined) console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);
            styles += strings[i];
        }
    }
    var sourceMap;
    styles = styles.replace(sourceMapPattern, function(match) {
        sourceMap = match;
        return "";
    });
    labelPattern.lastIndex = 0;
    var identifierName = "";
    var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5
    while((match = labelPattern.exec(styles)) !== null)identifierName += "-" + // $FlowFixMe we know it's not null
    match[1];
    var name = (0, _hashDefault.default)(styles) + identifierName;
    // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)
    return {
        name: name,
        styles: styles,
        map: sourceMap,
        next: cursor,
        toString: function toString() {
            return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
        }
    };
};

},{"@emotion/hash":"clggK","@emotion/unitless":"2Tu84","@emotion/memoize":"2vzJd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"clggK":[function(require,module,exports) {
/* eslint-disable */ // Inspired by https://github.com/garycourt/murmurhash-js
// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>murmur2);
function murmur2(str) {
    // 'm' and 'r' are mixing constants generated offline.
    // They're not really 'magic', they just happen to work well.
    // const m = 0x5bd1e995;
    // const r = 24;
    // Initialize the hash
    var h = 0; // Mix 4 bytes at a time into the hash
    var k, i = 0, len = str.length;
    for(; len >= 4; ++i, len -= 4){
        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
        k = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
        k ^= /* k >>> r: */ k >>> 24;
        h = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    } // Handle the last few bytes of the input array
    switch(len){
        case 3:
            h ^= (str.charCodeAt(i + 2) & 0xff) << 16;
        case 2:
            h ^= (str.charCodeAt(i + 1) & 0xff) << 8;
        case 1:
            h ^= str.charCodeAt(i) & 0xff;
            h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    } // Do a few final mixes of the hash to ensure the last few
    // bytes are well-incorporated.
    h ^= h >>> 13;
    h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2Tu84":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "default", ()=>unitlessKeys);
var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6UI8e":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getRegisteredStyles", ()=>getRegisteredStyles);
parcelHelpers.export(exports, "insertStyles", ()=>insertStyles);
parcelHelpers.export(exports, "registerStyles", ()=>registerStyles);
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
    var rawClassName = "";
    classNames.split(" ").forEach(function(className) {
        if (registered[className] !== undefined) registeredStyles.push(registered[className] + ";");
        else rawClassName += className + " ";
    });
    return rawClassName;
}
var registerStyles = function registerStyles(cache, serialized, isStringTag) {
    var className = cache.key + "-" + serialized.name;
    if (// class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === undefined) cache.registered[className] = serialized.styles;
};
var insertStyles = function insertStyles(cache, serialized, isStringTag) {
    registerStyles(cache, serialized, isStringTag);
    var className = cache.key + "-" + serialized.name;
    if (cache.inserted[serialized.name] === undefined) {
        var current = serialized;
        do {
            cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
            current = current.next;
        }while (current !== undefined);
    }
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9lORX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * big main HS+V color slider
 * 2 elements: slider, and colorpreview(output) + eyedropper
 */ parcelHelpers.export(exports, "KlColorSlider", ()=>KlColorSlider);
var _bb = require("../../../bb/bb");
var _colorSliderHexDialog = require("../modals/color-slider-hex-dialog");
var _sliderFalloff = require("./slider-falloff");
var _toolPickerSvg = require("/src/app/img/ui/tool-picker.svg");
var _toolPickerSvgDefault = parcelHelpers.interopDefault(_toolPickerSvg);
var _language = require("../../../language/language");
var _eraseColor = require("../../brushes/erase-color");
class KlColorSlider {
    updatePrimaryHSV(hsv) {
        if (hsv.s === 0) this.primaryColorHSV = new (0, _bb.BB).HSV(this.primaryColorHSV.h, hsv.s, hsv.v);
        else this.primaryColorHSV = new (0, _bb.BB).HSV(hsv.h, hsv.s, hsv.v);
    }
    updateSVCanvas() {
        const rgb = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(this.primaryColorHSV.h, 100, 100));
        (0, _bb.BB).setAttributes(this.hueStop, {
            "stop-color": "#" + (0, _bb.BB).ColorConverter.toHexString(rgb)
        });
    }
    updateSVPointer() {
        const left = this.primaryColorHSV.s / 100 * this.width - 7;
        const top = (1 - this.primaryColorHSV.v / 100) * this.svHeight - 6;
        (0, _bb.BB).css(this.pointerSV, {
            left: left + "px",
            top: top + "px"
        });
    }
    setColPreview() {
        this.divPreview.style.backgroundColor = "rgb(" + this.primaryColorRGB.r + "," + this.primaryColorRGB.g + "," + this.primaryColorRGB.b + ")";
        if ((0, _bb.BB).testIsWhiteBestContrast(this.primaryColorRGB)) {
            (0, _bb.BB).css(this.pickerButton, {
                filter: "invert(1)"
            });
            (0, _bb.BB).css(this.hexButton, {
                filter: "invert(1)"
            });
        } else {
            (0, _bb.BB).css(this.pickerButton, {
                filter: ""
            });
            (0, _bb.BB).css(this.hexButton, {
                filter: ""
            });
        }
    }
    updateSecondaryColor() {
        this.secondaryColorBtn.style.backgroundColor = (0, _bb.BB).ColorConverter.toRgbStr(this.secondaryColorRGB);
    }
    // ---- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            className: "kl-color-picker",
            css: {
                position: "relative"
            }
        });
        this.outputDiv = (0, _bb.BB).el({
            css: {
                display: "flex",
                alignItems: "center"
            }
        });
        this.width = p.width;
        this.svHeight = p.svHeight;
        this.height = p.height;
        this.emitColor = p.onPick;
        this.primaryColorRGB = {
            r: parseInt("" + p.startValue.r),
            g: parseInt("" + p.startValue.g),
            b: parseInt("" + p.startValue.b)
        };
        this.primaryColorHSV = (0, _bb.BB).ColorConverter.toHSV(p.startValue); // BB.HSV
        this.secondaryColorRGB = {
            r: (0, _eraseColor.ERASE_COLOR),
            g: (0, _eraseColor.ERASE_COLOR),
            b: (0, _eraseColor.ERASE_COLOR)
        };
        this.secondaryColorHSV = (0, _bb.BB).ColorConverter._RGBtoHSV(this.secondaryColorRGB); // BB.HSV
        const svWrapper = (0, _bb.BB).el();
        this.svSvg = new DOMParser().parseFromString('<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" preserveAspectRatio="none"><defs><linearGradient id="value" gradientTransform="rotate(90)"><stop offset="0" stop-color="#fff"/><stop offset="100%" stop-color="#000"/></linearGradient><linearGradient id="hue" gradientTransform="rotate(0)"><stop offset="0" stop-color="#fff"/><stop id="hue-stop" offset="100%" stop-color="#f00"/></linearGradient></defs><rect x="0" y="0" width="100" height="100" fill="url(\'#hue\')"/><rect x="0" y="0" width="100" height="100" fill="url(\'#value\')" style="mix-blend-mode: multiply"/></svg>', "image/svg+xml").documentElement;
        {
            const hueStop = this.svSvg.querySelector("#hue-stop");
            if (!hueStop) throw Error("#hue-stop not found in svSvg");
            this.hueStop = hueStop;
        }
        (0, _bb.BB).setAttributes(this.hueStop, {
            "stop-color": "#f0f"
        });
        (0, _bb.BB).css(this.svSvg, {
            width: this.width + "px",
            height: this.svHeight + "px"
        });
        svWrapper.append(this.svSvg);
        const divH = (0, _bb.BB).el({
            className: "kl-color-picker__h",
            css: {
                overflow: "hidden",
                position: "relative",
                width: this.width + "px",
                height: this.height + "px",
                cursor: "ew-resize",
                marginTop: "1px",
                marginBottom: "1px"
            }
        });
        this.divPreview = (0, _bb.BB).el({
            className: "kl-color-picker__preview",
            css: {
                display: "flex",
                justifyContent: "space-between",
                width: this.height * 2.5 + "px",
                height: this.height + "px"
            }
        });
        this.controlH = (0, _bb.BB).el();
        const createHueBg = (targetEl)=>{
            const im = new Image();
            (0, _bb.BB).css(im, {
                position: "absolute",
                left: "0",
                top: "0",
                display: "none",
                pointerEvents: "none"
            });
            const cv = (0, _bb.BB).canvas(this.width, this.height);
            const ctx = (0, _bb.BB).ctx(cv);
            const gradH = ctx.createLinearGradient(0, 0, this.width, 0);
            for(let i = 0; i < 1; i += 0.01){
                const col = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(i * 360, 100, 100));
                let ha = parseInt("" + col.r).toString(16);
                let hb = parseInt("" + col.g).toString(16);
                let hc = parseInt("" + col.b).toString(16);
                if (ha.length === 1) ha = "0" + ha;
                if (hb.length === 1) hb = "0" + hb;
                if (hc.length === 1) hc = "0" + hc;
                gradH.addColorStop(i, "#" + ha + hb + hc);
            }
            ctx.fillStyle = gradH;
            ctx.fillRect(0, 0, this.width, this.height);
            targetEl.append(im);
            im.alt = "hue";
            im.src = cv.toDataURL("image/png");
            im.style.display = "block";
        };
        this.updateSVCanvas();
        this.rootEl.style.width = this.width + "px";
        this.rootEl.oncontextmenu = ()=>{
            return false;
        };
        this.SVContainer = (0, _bb.BB).el({
            className: "kl-color-picker__sv",
            css: {
                width: this.width + "px",
                height: this.svHeight + "px",
                overflow: "hidden",
                display: "block",
                position: "relative",
                cursor: "crosshair"
            }
        });
        this.pointerSV = (0, _bb.BB).el({
            css: {
                width: "12px",
                height: "12px",
                borderRadius: "6px",
                position: "absolute",
                pointerEvents: "none",
                boxShadow: "0px 0px 0 1px #000, inset 0px 0px 0 1px #fff"
            }
        });
        this.SVContainer.append(svWrapper, this.pointerSV);
        this.updateSVPointer();
        this.rootEl.append(this.SVContainer, divH);
        this.outputDiv.append(this.divPreview);
        //divH.className = "svSlider";
        (0, _bb.BB).css(this.controlH, {
            width: "1px",
            height: this.height + "px",
            background: "#000",
            borderLeft: "1px solid #fff",
            position: "absolute",
            top: "0",
            left: parseInt("" + (this.primaryColorHSV.h / 360 * this.width - 1)) + "px"
        });
        const virtualHSV = {
            h: 0,
            s: 0,
            v: 0
        };
        this.pickerButton = (0, _bb.BB).el({
            title: (0, _language.LANG)("eyedropper") + " [Alt]",
            className: "color-picker-preview-button",
            css: {
                width: "30px",
                height: "30px",
                backgroundImage: "url(" + (0, _toolPickerSvgDefault.default) + ")",
                backgroundRepeat: "no-repeat",
                backgroundSize: "70%",
                backgroundPosition: "center"
            },
            onClick: ()=>{
                if (this.isPicking) {
                    this.pickCallback && this.pickCallback(false);
                    this.pickingDone();
                } else {
                    this.pickerButton.classList.remove("color-picker-preview-button-hover");
                    this.pickerButton.classList.add("color-picker-preview-button-active");
                    this.isPicking = true;
                    this.pickCallback && this.pickCallback(true);
                }
            }
        });
        this.isPicking = false;
        const pickerButtonPointerListener = new (0, _bb.BB).PointerListener({
            target: this.pickerButton,
            onEnterLeave: (isOver)=>{
                if (this.isPicking) return;
                this.pickerButton.classList.toggle("color-picker-preview-button-hover", isOver);
            }
        });
        this.divPreview.append(this.pickerButton);
        this.hexButton = (0, _bb.BB).el({
            content: "#",
            className: "color-picker-preview-button",
            title: (0, _language.LANG)("manual-color-input"),
            css: {
                height: "100%",
                width: this.height + "px",
                lineHeight: this.height + "px",
                fontSize: this.height * 0.65 + "px"
            },
            onClick: ()=>{
                new (0, _colorSliderHexDialog.HexColorDialog)({
                    color: new (0, _bb.BB).RGB(this.primaryColorRGB.r, this.primaryColorRGB.g, this.primaryColorRGB.b),
                    onClose: (rgbObj)=>{
                        if (!rgbObj) return;
                        this.setColor(rgbObj);
                        this.emitColor(new (0, _bb.BB).RGB(this.primaryColorRGB.r, this.primaryColorRGB.g, this.primaryColorRGB.b));
                    }
                });
            }
        });
        const hexButtonPointerListener = new (0, _bb.BB).PointerListener({
            target: this.hexButton,
            onEnterLeave: (isOver)=>{
                this.hexButton.classList.toggle("color-picker-preview-button-hover", isOver);
            }
        });
        this.divPreview.append(this.hexButton);
        this.setColPreview();
        setTimeout(()=>{
            createHueBg(divH);
            divH.append(this.controlH);
            const svPointerListener = new (0, _bb.BB).PointerListener({
                target: svWrapper,
                fixScribble: true,
                onPointer: (event)=>{
                    if (event.type === "pointerdown") {
                        // prevent manual slider input keeping focus on iPad
                        (0, _bb.BB).unfocusAnyInput();
                        this.SVContainer.classList.toggle("kl-color-picker--active", true);
                        if (event.button === "left") {
                            virtualHSV.s = event.relX / this.width * 100;
                            virtualHSV.v = 100 - event.relY / this.svHeight * 100;
                            this.primaryColorHSV = new (0, _bb.BB).HSV(this.primaryColorHSV.h, virtualHSV.s, virtualHSV.v);
                            this.primaryColorRGB = (0, _bb.BB).ColorConverter.toRGB(this.primaryColorHSV);
                            this.updateSVPointer();
                            this.setColPreview();
                            this.emitColor((0, _bb.BB).ColorConverter.toRGB(this.primaryColorHSV));
                        } else {
                            virtualHSV.s = this.primaryColorHSV.s;
                            virtualHSV.v = this.primaryColorHSV.v;
                        }
                    }
                    if (event.type === "pointermove" && [
                        "left",
                        "right"
                    ].includes(event.button || "")) {
                        let factor = 1;
                        if (event.button === "right") factor = 0.5;
                        virtualHSV.s += event.dX / this.width * 100 * factor;
                        virtualHSV.v -= event.dY / this.svHeight * 100 * factor;
                        this.primaryColorHSV = new (0, _bb.BB).HSV(this.primaryColorHSV.h, virtualHSV.s, virtualHSV.v);
                        this.primaryColorRGB = (0, _bb.BB).ColorConverter.toRGB(this.primaryColorHSV);
                        this.updateSVPointer();
                        this.setColPreview();
                        this.emitColor((0, _bb.BB).ColorConverter.toRGB(this.primaryColorHSV));
                    }
                    if (event.type === "pointerup") this.SVContainer.classList.toggle("kl-color-picker--active", false);
                }
            });
            const hPointerListener = new (0, _bb.BB).PointerListener({
                target: divH,
                fixScribble: true,
                onPointer: (event)=>{
                    if (event.type === "pointerdown") {
                        // prevent manual slider input keeping focus on iPad
                        (0, _bb.BB).unfocusAnyInput();
                        divH.classList.toggle("kl-color-picker--active", true);
                        if (event.button === "left") {
                            virtualHSV.h = event.relX / this.width * 359.99;
                            this.primaryColorHSV = new (0, _bb.BB).HSV(virtualHSV.h, this.primaryColorHSV.s, this.primaryColorHSV.v);
                            this.primaryColorRGB = (0, _bb.BB).ColorConverter.toRGB(this.primaryColorHSV);
                            this.controlH.style.left = Math.round(this.primaryColorHSV.h / 359.99 * this.width) - 1 + "px";
                            this.updateSVCanvas();
                            this.setColPreview();
                            this.emitColor((0, _bb.BB).ColorConverter.toRGB(this.primaryColorHSV));
                        } else virtualHSV.h = this.primaryColorHSV.h;
                    }
                    if (event.type === "pointermove" && [
                        "left",
                        "right"
                    ].includes(event.button || "")) {
                        const deltaY = Math.abs(event.pageY - event.downPageY);
                        const factor = (0, _sliderFalloff.calcSliderFalloffFactor)(deltaY, event.button === "right");
                        virtualHSV.h += event.dX / this.width * 359.99 * factor;
                        if (event.button === "right") {
                            virtualHSV.h = virtualHSV.h % 359.99;
                            if (virtualHSV.h < 0) virtualHSV.h += 359.99;
                        }
                        virtualHSV.h = Math.min(359.99, virtualHSV.h);
                        this.primaryColorHSV = new (0, _bb.BB).HSV(virtualHSV.h, this.primaryColorHSV.s, this.primaryColorHSV.v);
                        this.primaryColorRGB = (0, _bb.BB).ColorConverter.toRGB(this.primaryColorHSV);
                        this.controlH.style.left = Math.round(this.primaryColorHSV.h / 359.99 * this.width) - 1 + "px";
                        this.updateSVCanvas();
                        this.setColPreview();
                        this.emitColor((0, _bb.BB).ColorConverter.toRGB(this.primaryColorHSV));
                    }
                    if (event.type === "pointerup") divH.classList.toggle("kl-color-picker--active", false);
                }
            });
        }, 1);
        // --- secondary color ---
        this.secondaryColorBtn = (0, _bb.BB).el({
            parent: this.outputDiv,
            title: (0, _language.LANG)("secondary-color") + " [X]",
            className: "kl-color-picker__secondary",
            css: {
                cursor: "pointer",
                marginLeft: "5px",
                width: "22px",
                height: "22px"
            },
            onClick: (e)=>{
                e.preventDefault();
                this.swapColors();
            }
        });
        this.updateSecondaryColor();
    }
    setColor(c) {
        this.primaryColorRGB = {
            r: parseInt("" + c.r),
            g: parseInt("" + c.g),
            b: parseInt("" + c.b)
        };
        this.updatePrimaryHSV((0, _bb.BB).ColorConverter.toHSV(c));
        this.controlH.style.left = parseInt("" + (this.primaryColorHSV.h / 359 * this.width - 1)) + "px";
        this.updateSVCanvas();
        this.updateSVPointer();
        this.setColPreview();
    }
    getColor() {
        return new (0, _bb.BB).RGB(this.primaryColorRGB.r, this.primaryColorRGB.g, this.primaryColorRGB.b);
    }
    getSecondaryRGB() {
        return new (0, _bb.BB).RGB(this.secondaryColorRGB.r, this.secondaryColorRGB.g, this.secondaryColorRGB.b);
    }
    setPickCallback(func) {
        this.pickCallback = func;
    }
    pickingDone() {
        if (!this.isPicking) return;
        this.isPicking = false;
        this.pickerButton.classList.remove("color-picker-preview-button-active");
    }
    enable(e) {
        if (e) {
            this.rootEl.style.pointerEvents = "";
            this.rootEl.style.opacity = "1";
            this.outputDiv.style.pointerEvents = "";
            this.outputDiv.style.opacity = "1";
        } else {
            this.rootEl.style.pointerEvents = "none";
            this.rootEl.style.opacity = "0.5";
            this.outputDiv.style.pointerEvents = "none";
            this.outputDiv.style.opacity = "0.5";
        }
    }
    setHeight(h) {
        h = parseInt("" + (h - this.height * 2 - 3), 10);
        if (h === this.svHeight) return;
        this.svHeight = h;
        (0, _bb.BB).css(this.svSvg, {
            width: this.width + "px",
            height: this.svHeight + "px"
        });
        this.SVContainer.style.height = this.svHeight + "px";
        this.updateSVPointer();
    }
    swapColors() {
        // swap hsv
        let tmp = this.secondaryColorHSV;
        this.secondaryColorHSV = this.primaryColorHSV;
        this.updatePrimaryHSV(tmp);
        // swap rgb
        tmp = this.secondaryColorRGB;
        this.secondaryColorRGB = this.primaryColorRGB;
        this.primaryColorRGB = tmp;
        this.controlH.style.left = parseInt("" + (this.primaryColorHSV.h / 359 * this.width - 1)) + "px";
        this.updateSVCanvas();
        this.updateSVPointer();
        this.setColPreview();
        this.updateSecondaryColor();
        this.emitColor(new (0, _bb.BB).RGB(this.primaryColorRGB.r, this.primaryColorRGB.g, this.primaryColorRGB.b));
    }
    getElement() {
        return this.rootEl;
    }
    getOutputElement() {
        return this.outputDiv;
    }
}

},{"../../../bb/bb":"dcQKo","../modals/color-slider-hex-dialog":"es6uV","./slider-falloff":"8lnTu","/src/app/img/ui/tool-picker.svg":"a4NBW","../../../language/language":"iiYGN","../../brushes/erase-color":"lUgDd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a4NBW":[function(require,module,exports) {
module.exports = require("bc11ba99d52054c2").getBundleURL("d3gnI") + "tool-picker.78a99ccf.svg" + "?" + Date.now();

},{"bc11ba99d52054c2":"lgJ39"}],"lUgDd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ERASE_COLOR", ()=>ERASE_COLOR);
var _theme = require("../../theme/theme");
const ERASE_COLOR = (0, _theme.theme).isDark() ? 255 : 255;

},{"../../theme/theme":"4G3JB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4G3JB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "theme", ()=>theme);
var _base = require("../bb/base/base");
const LS_THEME_KEY = "klecks-theme";
class Theme {
    updateTheme() {
        const oldTheme = this.theme;
        this.theme = this.storedTheme || this.mediaQueryTheme;
        if (this.theme === oldTheme) return;
        document.body.classList.toggle("kl-theme-dark", this.theme === "dark");
        this.listeners.forEach((item)=>item());
    }
    readLocalStorage() {
        let result = localStorage.getItem(LS_THEME_KEY);
        if (!result || typeof result === "string" && ![
            "dark",
            "light"
        ].includes(result)) {
            result = undefined;
            localStorage.removeItem(LS_THEME_KEY); // reset because invalid
        }
        return result;
    }
    // ---- public ----
    constructor(){
        // initialization will be overwritten.
        this.mediaQueryTheme = "light" // prefers-color-scheme
        ;
        this.theme = "light";
        this.listeners = [];
        // init media query
        this.mediaQueryTheme = (0, _base.isDark)() ? "dark" : "light";
        (0, _base.addIsDarkListener)(()=>{
            this.mediaQueryTheme = (0, _base.isDark)() ? "dark" : "light";
            this.updateTheme();
        });
        // init local storage
        this.storedTheme = this.readLocalStorage();
        addEventListener("storage", (e)=>{
            if (e.key === LS_THEME_KEY) {
                this.storedTheme = this.readLocalStorage();
                this.updateTheme();
            }
        });
        this.updateTheme();
    }
    isDark() {
        return this.theme === "dark";
    }
    addIsDarkListener(func) {
        if (this.listeners.includes(func)) return;
        this.listeners.push(func);
    }
    removeIsDarkListener(func) {
        for(let i = 0; i < this.listeners.length; i++)if (this.listeners[i] === func) {
            this.listeners.splice(i, 1);
            return;
        }
    }
    getMediaQueryTheme() {
        return this.mediaQueryTheme;
    }
    getStoredTheme() {
        return this.storedTheme;
    }
    setStoredTheme(theme) {
        if (theme) localStorage.setItem(LS_THEME_KEY, theme);
        else localStorage.removeItem(LS_THEME_KEY);
        this.storedTheme = theme;
        this.updateTheme();
    }
}
const theme = new Theme();

},{"../bb/base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jJnMO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * a small color slider
 */ parcelHelpers.export(exports, "KlColorSliderSmall", ()=>KlColorSliderSmall);
var _bb = require("../../../bb/bb");
var _sliderFalloff = require("./slider-falloff");
class KlColorSliderSmall {
    updateSV() {
        const ctx = (0, _bb.BB).ctx(this.canvasSV);
        if (!ctx) throw new Error("couldnt create canvas");
        for(let i = 0; i < this.canvasSV.height; i += 1){
            const gradient1 = ctx.createLinearGradient(0, 0, this.canvasSV.width, 0);
            const colleft = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(this.color.h, 1, 100 - i / this.canvasSV.height * 100.0));
            const colright = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(this.color.h, 100, 100 - i / this.canvasSV.height * 100.0));
            gradient1.addColorStop(0, "#" + (0, _bb.BB).ColorConverter.toHexString(colleft));
            gradient1.addColorStop(1, "#" + (0, _bb.BB).ColorConverter.toHexString(colright));
            ctx.fillStyle = "#ff0000"; //needed for chrome...otherwise alpha problem
            ctx.fillStyle = gradient1;
            ctx.fillRect(0, i, this.canvasSV.width, 1);
        }
    }
    updateSVPointer() {
        const left = this.color.s / 100 * this.width - 4;
        const top = (1 - this.color.v / 100) * this.heightSV - 4;
        (0, _bb.BB).css(this.pointerSV, {
            left: left + "px",
            top: top + "px"
        });
    }
    updateHPointer() {
        this.pointerH.style.left = this.color.h / 359.999 * this.width - 1 + "px";
    }
    // ----- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: {
                width: p.width + "px",
                position: "relative",
                overflow: "hidden",
                userSelect: "none"
            }
        });
        this.rootEl.oncontextmenu = (e)=>{
            e.preventDefault();
        };
        this.color = (0, _bb.BB).ColorConverter.toHSV(new (0, _bb.BB).RGB(p.color.r, p.color.g, p.color.b));
        this.width = p.width;
        this.heightSV = p.heightSV;
        this.canvasSV = (0, _bb.BB).canvas(10, 10);
        (0, _bb.BB).css(this.canvasSV, {
            width: this.width + "px",
            height: this.heightSV + "px",
            cursor: "crosshair"
        });
        this.updateSV();
        const canvasH = (0, _bb.BB).canvas(p.width, p.heightH);
        canvasH.style.cursor = "ew-resize";
        (()=>{
            const ctx = (0, _bb.BB).ctx(canvasH);
            const gradH = ctx.createLinearGradient(0, 0, p.width, 0);
            for(let i = 0; i < 1; i += 0.01){
                const col = (0, _bb.BB).ColorConverter.toRGB(new (0, _bb.BB).HSV(i * 360, 100, 100));
                gradH.addColorStop(i, "rgba(" + parseInt("" + col.r) + ", " + parseInt("" + col.g) + ", " + parseInt("" + col.b) + ", 1)");
            }
            ctx.fillStyle = gradH;
            ctx.fillRect(0, 0, p.width, p.heightH);
        })();
        (0, _bb.BB).css(this.canvasSV, {
            width: p.width + "px",
            height: p.heightSV + "px",
            overflow: "hidden",
            position: "relative"
        });
        this.canvasSV.style.cssFloat = "left";
        canvasH.style.cssFloat = "left";
        this.rootEl.append(this.canvasSV, canvasH);
        this.pointerSV = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                width: "8px",
                height: "8px",
                borderRadius: "8px",
                position: "absolute",
                pointerEvents: "none",
                boxShadow: "0 0 0 1px #000, inset 0 0 0 1px #fff"
            }
        });
        this.pointerH = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                width: "0",
                height: p.heightH + "px",
                borderLeft: "1px solid #fff",
                borderRight: "1px solid #000",
                position: "absolute",
                top: p.heightSV + "px",
                pointerEvents: "none"
            }
        });
        this.updateSVPointer();
        this.updateHPointer();
        const virtualHSV = {
            h: 0,
            s: 0,
            v: 0
        };
        this.svPointerId = null;
        this.svPointerListener = new (0, _bb.BB).PointerListener({
            target: this.canvasSV,
            fixScribble: true,
            onPointer: (event)=>{
                if (event.type === "pointerdown") {
                    // prevent manual slider input keeping focus on iPad
                    (0, _bb.BB).unfocusAnyInput();
                    this.svPointerId = event.pointerId;
                    if (event.button === "left") {
                        virtualHSV.s = event.relX / p.width * 100;
                        virtualHSV.v = 100 - event.relY / p.heightSV * 100;
                        this.color = new (0, _bb.BB).HSV(this.color.h, virtualHSV.s, virtualHSV.v);
                        this.updateSVPointer();
                        p.callback((0, _bb.BB).ColorConverter.toRGB(this.color));
                    } else {
                        virtualHSV.s = this.color.s;
                        virtualHSV.v = this.color.v;
                    }
                }
                if (event.type === "pointermove" && [
                    "left",
                    "right"
                ].includes("" + event.button) && this.svPointerId === event.pointerId) {
                    let factor = 1;
                    if (event.button === "right") factor = 0.5;
                    virtualHSV.s += event.dX / p.width * 100 * factor;
                    virtualHSV.v -= event.dY / p.heightSV * 100 * factor;
                    this.color = new (0, _bb.BB).HSV(this.color.h, virtualHSV.s, virtualHSV.v);
                    this.updateSVPointer();
                    p.callback((0, _bb.BB).ColorConverter.toRGB(this.color));
                }
                if (event.type === "pointerup") this.svPointerId = null;
            }
        });
        this.hPointerId = null;
        this.hPointerListener = new (0, _bb.BB).PointerListener({
            target: canvasH,
            fixScribble: true,
            onPointer: (event)=>{
                if (event.type === "pointerdown") {
                    this.hPointerId = event.pointerId;
                    if (event.button === "left") {
                        virtualHSV.h = event.relX / p.width * 359.99;
                        this.color = new (0, _bb.BB).HSV(virtualHSV.h, this.color.s, this.color.v);
                        this.updateSV();
                        this.updateHPointer();
                        p.callback((0, _bb.BB).ColorConverter.toRGB(this.color));
                    } else virtualHSV.h = this.color.h;
                }
                if (event.type === "pointermove" && [
                    "left",
                    "right"
                ].includes("" + event.button) && this.hPointerId === event.pointerId) {
                    const deltaY = Math.abs(event.pageY - event.downPageY);
                    const factor = (0, _sliderFalloff.calcSliderFalloffFactor)(deltaY, event.button === "right");
                    virtualHSV.h += event.dX / p.width * 359.99 * factor;
                    if (event.button === "right") {
                        virtualHSV.h = virtualHSV.h % 359.99;
                        if (virtualHSV.h < 0) virtualHSV.h += 359.99;
                    }
                    virtualHSV.h = Math.min(359.99, virtualHSV.h);
                    this.color = new (0, _bb.BB).HSV(virtualHSV.h, this.color.s, this.color.v);
                    this.updateSV();
                    this.updateHPointer();
                    p.callback((0, _bb.BB).ColorConverter.toRGB(this.color));
                }
                if (event.type === "pointerup") this.hPointerId = null;
            }
        });
        const cleardiv = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                clear: "both"
            }
        });
    }
    // ---- interface ----
    setColor(c) {
        this.color = (0, _bb.BB).ColorConverter.toHSV(new (0, _bb.BB).RGB(c.r, c.g, c.b));
        this.updateSV();
        this.updateSVPointer();
        this.updateHPointer();
    }
    getColor() {
        return (0, _bb.BB).ColorConverter.toRGB(this.color);
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.svPointerListener.destroy();
        this.hPointerListener.destroy();
    }
    end() {
        this.svPointerId = null;
        this.hPointerId = null;
    }
}

},{"../../../bb/bb":"dcQKo","./slider-falloff":"8lnTu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3j9Hm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * A slider that looks like this
 * ------O----
 */ parcelHelpers.export(exports, "PointSlider", ()=>PointSlider);
var _bb = require("../../../bb/bb");
class PointSlider {
    // ---- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: {
                position: "relative"
            }
        });
        const sliderLine = (0, _bb.BB).el({
            parent: this.rootEl,
            className: "kl-point-slider__line",
            css: {
                marginTop: parseInt("" + (p.pointSize / 2 - 1)) + "px",
                width: p.width + "px"
            }
        });
        this.sliderPoint = (0, _bb.BB).el({
            parent: this.rootEl,
            className: "kl-point-slider__point"
        });
        let sliderPos;
        let isDragging = false;
        //sliderPoint
        const touchAreaEl = (0, _bb.BB).el({
            parent: this.sliderPoint,
            css: {
                // background: 'rgba(255,0,0,0.4)',
                margin: "-7px 0 0 -7px",
                width: "calc(100% + 14px)",
                height: "calc(100% + 7px)"
            }
        });
        const redrawPoint = ()=>{
            (0, _bb.BB).css(this.sliderPoint, {
                left: sliderPos + "px"
            });
        };
        const getValue = ()=>{
            return sliderPos / (p.width - p.pointSize);
        };
        {
            let isFirst;
            sliderPos = (0, _bb.BB).clamp(p.init * (p.width - p.pointSize), 0, p.width - p.pointSize);
            (0, _bb.BB).css(this.sliderPoint, {
                width: p.pointSize + "px",
                height: p.pointSize + "px",
                borderRadius: p.pointSize + "px"
            });
            redrawPoint();
            let imaginaryPos;
            this.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.sliderPoint,
                fixScribble: true,
                onPointer: (event)=>{
                    if (event.type === "pointerdown" && event.button === "left") {
                        isFirst = true;
                        isDragging = true;
                        imaginaryPos = sliderPos;
                        redrawPoint();
                        event.eventStopPropagation();
                    } else if (event.type === "pointermove" && event.button === "left") {
                        event.eventStopPropagation();
                        imaginaryPos = imaginaryPos + event.dX;
                        sliderPos = parseInt("" + (0, _bb.BB).clamp(imaginaryPos, 0, p.width - p.pointSize));
                        redrawPoint();
                        p.callback(getValue(), isFirst, false);
                        isFirst = false;
                    }
                    if (event.type === "pointerup") {
                        event.eventStopPropagation();
                        isDragging = false;
                        redrawPoint();
                        p.callback(getValue(), false, true);
                    }
                }
            });
        }
    }
    // ---- interface ----
    getEl() {
        return this.rootEl;
    }
    setActive(isActive) {
        this.sliderPoint.style.backgroundColor = isActive ? "#fff" : "#eaeaea";
    }
    destroy() {
        this.pointerListener.destroy();
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iXzf7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * UI to pick between colors in colorArr. can display full transparent (checkerboard).
 * Can't deal with 0.5 alpha.
 * Rectangular buttons.
 */ parcelHelpers.export(exports, "ColorOptions", ()=>ColorOptions);
var _bb = require("../../../bb/bb");
var _theme = require("../../../theme/theme");
var _color = require("../../../bb/color/color");
var _c = require("../../../bb/base/c");
class ColorOptions {
    // ---- public ----
    constructor(p){
        this.colorArr = [];
        this.selectedIndex = 0;
        this.rootEl = (0, _bb.BB).el({
            content: p.label ? p.label : "",
            title: p.title ?? undefined,
            css: {
                display: "flex",
                alignItems: "center",
                gap: "7px"
            }
        });
        this.buttonArr = [];
        const buttonSize = 22;
        const checkerUrl = (0, _bb.BB).createCheckerDataUrl(5, undefined, (0, _theme.theme).isDark());
        this.onColorInputChange = ()=>{
            const i = this.selectedIndex;
            const color = this.colorArr[i];
            if (!color || color.a < 1) // ignore
            return;
            const newRawColor = this.colorInput.value;
            this.buttonArr[this.selectedIndex].el.style.backgroundColor = newRawColor;
            this.colorArr[i] = {
                ...(0, _color.ColorConverter).hexToRGB(newRawColor),
                a: 1
            };
            p.onChange(this.colorArr[i]);
        };
        this.colorInput = (0, _bb.BB).el({
            tagName: "input",
            custom: {
                type: "color",
                tabIndex: "-1"
            }
        });
        this.colorInput.onchange = this.onColorInputChange;
        this.colorInput.oninput = this.onColorInputChange;
        // build colorArr while removing duplicates
        for(let i = 0; i < p.colorArr.length; i++){
            const item = p.colorArr[i];
            let found = false;
            for(let e = 0; e < this.colorArr.length; e++){
                const sItem = this.colorArr[e];
                if (sItem === item) {
                    found = true;
                    break;
                }
                if (sItem === null || item === null) continue;
                if (sItem.r === item.r && sItem.g === item.g && sItem.b === item.b && sItem.a === item.a) {
                    found = true;
                    break;
                }
            }
            if (found) continue;
            this.colorArr.push(item);
            if ("initialIndex" in p && p.initialIndex === i) this.selectedIndex = this.colorArr.length - 1;
        }
        for(let i = 0; i < this.colorArr.length; i++)((i)=>{
            const color = this.colorArr[i];
            const colorButton = (0, _bb.BB).el({
                parent: this.rootEl,
                content: color ? "" : "X",
                className: "kl-color-option",
                css: {
                    width: buttonSize + "px",
                    height: buttonSize + "px",
                    backgroundColor: color ? (0, _bb.BB).ColorConverter.toRgbaStr(color) : "transparent",
                    lineHeight: buttonSize + 1 + "px"
                },
                onClick: (e)=>{
                    if (this.selectedIndex === i) {
                        if (color && color.a === 1) this.colorInput.showPicker ? this.colorInput.showPicker() : this.colorInput.click();
                        return;
                    }
                    e.preventDefault();
                    this.selectedIndex = i;
                    update();
                    p.onChange(this.colorArr[i]); // color may change
                }
            });
            if (color && color.a === 0) colorButton.style.backgroundImage = "url(" + checkerUrl + ")";
            const setIsSelected = (b)=>{
                colorButton.classList.toggle("kl-color-option--active", b);
            };
            this.buttonArr.push({
                el: colorButton,
                setIsSelected
            });
        })(i);
        this.rootEl.append((0, _c.c)(",w-0,h-0,overflow-hidden", [
            this.colorInput
        ]));
        const update = ()=>{
            for(let i = 0; i < this.buttonArr.length; i++)this.buttonArr[i].setIsSelected(i === this.selectedIndex);
        };
        update();
        this.updateCheckerboard = ()=>{
            const checkerUrl = (0, _bb.BB).createCheckerDataUrl(5, undefined, (0, _theme.theme).isDark());
            this.buttonArr.forEach((button, i)=>{
                const color = this.colorArr[i];
                if (color && color.a === 0) button.el.style.backgroundImage = "url(" + checkerUrl + ")";
            });
        };
        (0, _theme.theme).addIsDarkListener(this.updateCheckerboard);
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    getValue() {
        return this.colorArr[this.selectedIndex];
    }
    destroy() {
        this.rootEl.remove();
        this.buttonArr.forEach((item)=>{
            (0, _bb.BB).destroyEl(item.el);
        });
        this.buttonArr.splice(0, this.buttonArr.length);
        (0, _theme.theme).removeIsDarkListener(this.updateCheckerboard);
        this.colorInput.onchange = null;
        this.colorInput.oninput = null;
    }
}

},{"../../../bb/bb":"dcQKo","../../../theme/theme":"4G3JB","../../../bb/color/color":"iVNo9","../../../bb/base/c":"eg9k9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hNLP6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * selectable options
 */ parcelHelpers.export(exports, "Options", ()=>Options);
var _bb = require("../../../bb/bb");
class Options {
    getIndex() {
        for(let i = 0; i < this.optionArr.length; i++){
            if (this.optionArr[i].id === this.selectedId) return i;
        }
        return -1;
    }
    update() {
        for(let i = 0; i < this.optionArr.length; i++)this.optionArr[i].el.classList.toggle("kl-option-selected", this.optionArr[i].id === this.selectedId);
    }
    // ---- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el();
        const wrapperEl = (0, _bb.BB).el({
            parent: this.rootEl,
            className: "kl-option-wrapper",
            css: {
                display: "flex"
            }
        });
        if (p.onChange) this.onChange = p.onChange;
        this.optionArr = [];
        this.selectedId = "initialId" in p && p.initId !== undefined ? p.initId : p.optionArr[0].id;
        const createOption = (o)=>{
            const classArr = [
                "kl-option"
            ];
            if (p.isSmall) classArr.push("kl-option--small");
            if (typeof o.label !== "string") {
                classArr.push("kl-option--custom-el");
                (0, _bb.BB).css(o.label, {
                    display: "block",
                    pointerEvents: "none"
                });
            }
            const optionObj = {
                id: o.id,
                el: (0, _bb.BB).el({
                    parent: wrapperEl,
                    content: o.label,
                    className: classArr.join(" "),
                    onClick: ()=>{
                        if (this.selectedId !== optionObj.id) {
                            this.selectedId = optionObj.id;
                            this.update();
                            this.onChange && this.onChange(this.selectedId);
                        }
                    }
                })
            };
            if (o.title) optionObj.el.title = o.title;
            this.optionArr.push(optionObj);
        };
        for(let i = 0; i < p.optionArr.length; i++)createOption(p.optionArr[i]);
        this.update();
        if (p.changeOnInit) setTimeout(()=>{
            this.onChange && this.onChange(this.selectedId);
        }, 0);
    }
    getElement() {
        return this.rootEl;
    }
    getValue() {
        return this.selectedId;
    }
    next() {
        this.selectedId = this.optionArr[(this.getIndex() + 1) % this.optionArr.length].id;
        this.update();
        this.onChange && this.onChange(this.selectedId);
    }
    previous() {
        this.selectedId = this.optionArr[(this.optionArr.length + this.getIndex() - 1) % this.optionArr.length].id;
        this.update();
        this.onChange && this.onChange(this.selectedId);
    }
    destroy() {
        this.rootEl.remove();
        this.optionArr.forEach((item)=>{
            (0, _bb.BB).destroyEl(item.el);
        });
        this.optionArr.splice(0, this.optionArr.length);
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ke842":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * display little messages at the top of KlWorkspace
 */ parcelHelpers.export(exports, "StatusOverlay", ()=>StatusOverlay);
var _bb = require("../../../bb/bb");
var _angleSvg = require("/src/app/img/ui/angle.svg");
var _angleSvgDefault = parcelHelpers.interopDefault(_angleSvg);
class StatusOverlay {
    updateUiState() {
        if (this.uiState === "left") this.el.style.left = "271px";
        else this.el.style.removeProperty("left");
    }
    // --- public ---
    constructor(){
        this.isWide = false // tool space hidden
        ;
        this.uiState = "right";
        this.el = (0, _bb.BB).el({
            className: "top-overlay g-root",
            onClick: (0, _bb.BB).handleClick
        });
        this.updateUiState();
        this.innerEl = (0, _bb.BB).el({
            className: "top-overlay--inner"
        });
        this.angleIm = new Image();
        this.angleIm.src = (0, _angleSvgDefault.default);
        (0, _bb.BB).css(this.angleIm, {
            verticalAlign: "bottom",
            width: "20px",
            height: "20px",
            marginLeft: "5px",
            borderRadius: "10px"
        });
        this.innerInnerEl = document.createElement("div");
        this.innerInnerEl.style.display = "inline-block";
        this.innerEl.append(this.innerInnerEl, this.angleIm);
        this.el.append(this.innerEl);
        document.body.append(this.el);
        this.el.style.display = "none";
    }
    setWide(b) {
        this.isWide = b;
        if (!this.el) return;
        if (this.isWide) {
            this.el.style.width = "100%";
            this.el.style.left = "";
        } else {
            this.el.style.removeProperty("width");
            this.el.style.left = this.uiState === "left" ? "271px" : "";
        }
    }
    setUiState(state) {
        this.uiState = state;
        this.updateUiState();
    }
    out(msg, doPulse) {
        if (typeof msg === "string") {
            this.angleIm.style.display = "none";
            this.innerInnerEl.innerHTML = msg;
        } else if (msg.type === "transform") {
            this.angleIm.style.display = "inline-block";
            this.angleIm.style.transform = "rotate(" + msg.angleDeg + "deg)";
            if (msg.angleDeg % 90 === 0) this.angleIm.style.boxShadow = "inset 0 0 0 1px rgba(255, 255, 255, 0.7)";
            else this.angleIm.style.boxShadow = "";
            this.innerInnerEl.innerHTML = Math.round(msg.scale * 100) + "%";
        } else this.angleIm.style.display = "none";
        if (doPulse) {
            this.innerEl.style.animation = "";
            setTimeout(()=>this.innerEl.style.animation = "topOverlayPulse 0.5s ease-out", 20);
            clearTimeout(this.timeout3);
            this.timeout3 = setTimeout(()=>this.innerEl.style.animation = "", 520);
        }
        clearTimeout(this.timeout);
        clearTimeout(this.timeout2);
        this.el.style.animationName = doPulse ? "consoleInFast" : "consoleIn";
        this.el.style.opacity = "1";
        this.timeout = setTimeout(()=>{
            this.el.style.opacity = "0";
            this.el.style.animationName = "consoleOut";
            this.timeout2 = setTimeout(()=>{
                this.el.style.display = "none";
            }, 450);
        }, 1200);
        this.el.style.display = "flex";
    }
}

},{"../../../bb/bb":"dcQKo","/src/app/img/ui/angle.svg":"sK9n5","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"sK9n5":[function(require,module,exports) {
module.exports = require("fb5d8eb5abce74d5").getBundleURL("d3gnI") + "angle.8be0f182.svg" + "?" + Date.now();

},{"fb5d8eb5abce74d5":"lgJ39"}],"aTBXS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * element that lets you crop an image and copy it via right click
 */ parcelHelpers.export(exports, "CropCopy", ()=>CropCopy);
var _bb = require("../../../bb/bb");
var _preview = require("../project-viewport/preview");
var _transformationMatrix = require("transformation-matrix");
var _createTransformMatrix = require("../project-viewport/utils/create-transform-matrix");
var _math = require("../../../bb/math/math");
var _language = require("../../../language/language");
var _editCropSvg = require("/src/app/img/ui/edit-crop.svg");
var _editCropSvgDefault = parcelHelpers.interopDefault(_editCropSvg);
var _eventChain = require("../../../bb/input/event-chain/event-chain");
var _onePointerLimiter = require("../../../bb/input/event-chain/one-pointer-limiter");
class CropCopy {
    resetCrop() {
        this.crop = {
            x: 0,
            y: 0,
            width: this.canvas.width,
            height: this.canvas.height
        };
    }
    getViewportSelectionRect() {
        const transform = this.preview.getTransform();
        const mat = (0, _createTransformMatrix.createTransformMatrix)(transform);
        const p = (0, _transformationMatrix.applyToPoint)(mat, this.crop);
        return {
            x: p.x,
            y: p.y,
            width: this.crop.width * transform.scale,
            height: this.crop.height * transform.scale
        };
    }
    updateCroppedCanvas() {
        this.croppedCanvas.width = Math.round(this.crop.width);
        this.croppedCanvas.height = Math.round(this.crop.height);
        const ctx = (0, _bb.BB).ctx(this.croppedCanvas);
        ctx.drawImage(this.canvas, Math.round(-this.crop.x), Math.round(-this.crop.y));
        if (this.croppedImage) this.croppedImage.src = this.croppedCanvas.toDataURL("image/png");
        this.onChange && this.onChange(this.croppedCanvas.width, this.croppedCanvas.height);
    }
    updateSelectionRect() {
        const rect = this.getViewportSelectionRect();
        (0, _bb.BB).css(this.selectionRectEl, {
            left: rect.x + "px",
            top: rect.y + "px",
            width: rect.width + "px",
            height: rect.height + "px",
            display: this.isReset() ? "none" : ""
        });
        this.onChange && this.onChange(Math.round(this.crop.width), Math.round(this.crop.height));
    }
    // ---- public ----
    constructor(param){
        this.crop = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
        } // canvas coordinates
        ;
        this.mode = "edit";
        this.rootEl = (0, _bb.BB).el({
            className: "kl-edit-crop-preview",
            css: {
                position: "relative",
                height: param.height + "px",
                width: param.width + "px",
                overflow: "hidden"
            }
        });
        if (param.onChange) this.onChange = param.onChange;
        this.canvas = param.canvas;
        this.resetCrop();
        const isInsideSelectionRect = (p)=>{
            return (0, _bb.BB).isInsideRect(p, this.getViewportSelectionRect());
        };
        this.croppedCanvas = (0, _bb.BB).canvas();
        this.eventTarget = this.croppedCanvas;
        if (!param.isNotCopy) {
            this.croppedImage = new Image();
            this.eventTarget = this.croppedImage;
        }
        (0, _bb.BB).css(this.eventTarget, {
            height: param.height + "px",
            width: param.width + "px"
        });
        this.rootEl.append(this.eventTarget);
        this.updateCroppedCanvas();
        this.preview = new (0, _preview.Preview)({
            width: param.width,
            height: param.height - 2,
            project: {
                width: param.canvas.width,
                height: param.canvas.height,
                layers: [
                    {
                        image: param.canvas,
                        opacity: 1,
                        isVisible: true,
                        mixModeStr: "source-over",
                        hasClipping: false
                    }
                ]
            },
            hasEditMode: true,
            onModeChange: (mode)=>{
                this.mode = mode;
                this.preview.getElement().style.pointerEvents = mode === "edit" ? "none" : "";
                this.rootEl.title = mode === "edit" ? (0, _language.LANG)("crop-drag-to-crop") : "";
            },
            onTransformChange: ()=>this.updateSelectionRect(),
            padding: 20,
            hasBorder: false,
            editIcon: (0, _editCropSvgDefault.default)
        });
        (0, _bb.BB).css(this.preview.getElement(), {
            position: "absolute",
            left: "0",
            top: "0",
            overflow: "hidden",
            pointerEvents: "none"
        });
        this.preview.render();
        this.rootEl.append(this.preview.getElement());
        this.selectionRectEl = (0, _bb.BB).el({
            parent: this.preview.getElement(),
            className: "kl-edit-crop-preview__sel"
        });
        this.updateSelectionRect();
        //gen crop from viewport points
        const genCrop = (p1, p2)=>{
            const mat = (0, _createTransformMatrix.createTransformMatrix)(this.preview.getTransform());
            const inverseMat = (0, _transformationMatrix.inverse)(mat);
            const topLeftP = {
                x: Math.min(p1.x, p2.x),
                y: Math.min(p1.y, p2.y)
            };
            const bottomRightP = {
                x: Math.max(p1.x, p2.x),
                y: Math.max(p1.y, p2.y)
            };
            const origTopLeftP = (0, _transformationMatrix.applyToPoint)(inverseMat, topLeftP);
            const origBottomRightP = (0, _transformationMatrix.applyToPoint)(inverseMat, bottomRightP);
            origTopLeftP.x = (0, _math.clamp)(Math.floor(origTopLeftP.x), 0, this.canvas.width);
            origTopLeftP.y = (0, _math.clamp)(Math.floor(origTopLeftP.y), 0, this.canvas.height);
            origBottomRightP.x = (0, _math.clamp)(Math.ceil(origBottomRightP.x), 0, this.canvas.width);
            origBottomRightP.y = (0, _math.clamp)(Math.ceil(origBottomRightP.y), 0, this.canvas.height);
            return {
                x: origTopLeftP.x,
                y: origTopLeftP.y,
                width: origBottomRightP.x - origTopLeftP.x,
                height: origBottomRightP.y - origTopLeftP.y
            };
        };
        let startP;
        let startCrop = null;
        let isDragging = false;
        let didMove = false;
        let updateCropTimeout;
        const pointerChain = new (0, _eventChain.EventChain)({
            chainArr: [
                new (0, _onePointerLimiter.OnePointerLimiter)()
            ]
        });
        pointerChain.setChainOut((event)=>{
            if (event.type === "pointerdown" && event.button === "left") {
                event.eventPreventDefault();
                isDragging = true;
                startP = {
                    x: event.relX,
                    y: event.relY
                };
                if (!this.isReset() && isInsideSelectionRect(startP)) startCrop = {
                    x: this.crop.x,
                    y: this.crop.y,
                    width: this.crop.width,
                    height: this.crop.height
                };
                else this.crop = genCrop(startP, startP);
            } else if (event.type === "pointermove" && event.button === "left") {
                event.eventPreventDefault();
                didMove = true;
                if (startCrop) {
                    const transform = this.preview.getTransform();
                    this.crop.x = startCrop.x + Math.round((event.relX - startP.x) / transform.scale);
                    this.crop.y = startCrop.y + Math.round((event.relY - startP.y) / transform.scale);
                    this.crop.x = (0, _bb.BB).clamp(this.crop.x, 0, this.canvas.width - this.crop.width);
                    this.crop.y = (0, _bb.BB).clamp(this.crop.y, 0, this.canvas.height - this.crop.height);
                } else this.crop = genCrop(startP, {
                    x: event.relX,
                    y: event.relY
                });
                this.updateSelectionRect();
            } else if (event.type === "pointerup" && startP) {
                event.eventPreventDefault();
                isDragging = false;
                startCrop = null;
                startP = null;
                if (this.crop.width === 0 || this.crop.height === 0 || !didMove) {
                    this.resetCrop();
                    this.updateSelectionRect();
                }
                didMove = false;
                updateCropTimeout = setTimeout(()=>this.updateCroppedCanvas(), 1);
            }
        });
        this.pointerListener = new (0, _bb.BB).PointerListener({
            target: this.eventTarget,
            fixScribble: true,
            onWheel: (event)=>{
                this.preview.onWheel(event);
            },
            onPointer: (event)=>{
                if (this.mode === "hand") {
                    event.eventPreventDefault();
                    this.preview.onPointer(event);
                    return;
                }
                pointerChain.chainIn(event);
            },
            maxPointers: 2
        });
        this.keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr, e)=>{
                if (isDragging) return;
                let doUpdate = false;
                const transform = this.preview.getTransform();
                const stepSize = Math.max(1, 1 / transform.scale);
                const shiftIsPressed = this.keyListener.isPressed("shift");
                if (keyStr === "left") {
                    if (shiftIsPressed) this.crop.width = (0, _bb.BB).clamp(this.crop.width - stepSize, 1, this.canvas.width - this.crop.x);
                    else this.crop.x = (0, _bb.BB).clamp(this.crop.x - stepSize, 0, this.canvas.width - this.crop.width);
                    doUpdate = true;
                }
                if (keyStr === "right") {
                    if (shiftIsPressed) this.crop.width = (0, _bb.BB).clamp(this.crop.width + stepSize, 1, this.canvas.width - this.crop.x);
                    else this.crop.x = (0, _bb.BB).clamp(this.crop.x + stepSize, 0, this.canvas.width - this.crop.width);
                    doUpdate = true;
                }
                if (keyStr === "up") {
                    if (shiftIsPressed) this.crop.height = (0, _bb.BB).clamp(this.crop.height - stepSize, 1, this.canvas.height - this.crop.y);
                    else this.crop.y = (0, _bb.BB).clamp(this.crop.y - stepSize, 0, this.canvas.height - this.crop.height);
                    doUpdate = true;
                }
                if (keyStr === "down") {
                    if (shiftIsPressed) this.crop.height = (0, _bb.BB).clamp(this.crop.height + stepSize, 1, this.canvas.height - this.crop.y);
                    else this.crop.y = (0, _bb.BB).clamp(this.crop.y + stepSize, 0, this.canvas.height - this.crop.height);
                    doUpdate = true;
                }
                if (doUpdate) {
                    e.preventDefault();
                    this.updateSelectionRect();
                    clearTimeout(updateCropTimeout);
                    updateCropTimeout = setTimeout(()=>this.updateCroppedCanvas(), 100);
                }
            }
        });
    }
    // ---- interface ----
    getEl() {
        return this.rootEl;
    }
    reset() {
        this.resetCrop();
        this.updateCroppedCanvas();
        this.updateSelectionRect();
    }
    destroy() {
        this.rootEl.remove();
        this.eventTarget.style.removeProperty("width");
        this.eventTarget.style.removeProperty("height");
        this.keyListener.destroy();
        this.pointerListener.destroy();
        this.preview.destroy();
    }
    isReset() {
        return this.crop.x === 0 && this.crop.y === 0 && this.crop.width === this.canvas.width && this.crop.height === this.canvas.height;
    }
    getRect() {
        return (0, _bb.BB).copyObj(this.crop);
    }
    getCroppedCanvas() {
        return this.croppedCanvas;
    }
}

},{"../../../bb/bb":"dcQKo","../project-viewport/preview":"iWTRk","transformation-matrix":"3I2Wq","../project-viewport/utils/create-transform-matrix":"6WuHP","../../../bb/math/math":"7w6MZ","../../../language/language":"iiYGN","/src/app/img/ui/edit-crop.svg":"tY4Ae","../../../bb/input/event-chain/event-chain":"gQC7e","../../../bb/input/event-chain/one-pointer-limiter":"d988z","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iWTRk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "Preview", ()=>Preview);
var _c = require("../../../bb/base/c");
var _projectViewport = require("./project-viewport");
var _bb = require("../../../bb/bb");
var _pointerListener = require("../../../bb/input/pointer-listener");
var _toolZoomInSvg = require("/src/app/img/ui/tool-zoom-in.svg");
var _toolZoomInSvgDefault = parcelHelpers.interopDefault(_toolZoomInSvg);
var _toolZoomOutSvg = require("/src/app/img/ui/tool-zoom-out.svg");
var _toolZoomOutSvgDefault = parcelHelpers.interopDefault(_toolZoomOutSvg);
var _viewportResetSvg = require("/src/app/img/ui/viewport-reset.svg");
var _viewportResetSvgDefault = parcelHelpers.interopDefault(_viewportResetSvg);
var _toolHandSvg = require("/src/app/img/ui/tool-hand.svg");
var _toolHandSvgDefault = parcelHelpers.interopDefault(_toolHandSvg);
var _editPencilSvg = require("/src/app/img/ui/edit-pencil.svg");
var _editPencilSvgDefault = parcelHelpers.interopDefault(_editPencilSvg);
var _eventChain = require("../../../bb/input/event-chain/event-chain");
var _doubleTapper = require("../../../bb/input/event-chain/double-tapper");
var _css = require("@emotion/css");
var _createTransformMatrix = require("./utils/create-transform-matrix");
var _zoomByStep = require("./utils/zoom-by-step");
var _pinchZoomer = require("../../../bb/input/event-chain/pinch-zoomer");
var _language = require("../../../language/language");
var _transformationMatrix = require("transformation-matrix");
var _createTransform = require("./utils/create-transform");
var _toMetaTransform = require("./utils/to-meta-transform");
var _options = require("../components/options");
const DEFAULT_PADDING = 10;
class Preview {
    requestRerender() {
        this.doRender = true;
    }
    resetOrZoom(x, y) {
        if (this.isReset) {
            this.isReset = false;
            const canvasP = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)((0, _createTransformMatrix.createTransformMatrix)(this.viewport.getTransform())), {
                x,
                y
            });
            this.viewport.setTransform((0, _createTransform.createTransform)({
                x: this.width / 2,
                y: this.height / 2
            }, canvasP, 1, 0));
            this.requestRerender();
        } else this.reset();
    }
    reset() {
        const fit = (0, _bb.BB).fitInto(this.project.width, this.project.height, this.width - this.padding * 2, this.height - this.padding * 2);
        const scale = fit.width / this.project.width;
        this.viewport.setTransform((0, _createTransform.createTransform)({
            x: this.width / 2,
            y: this.height / 2
        }, {
            x: this.project.width / 2,
            y: this.project.height / 2
        }, scale, 0));
        this.isReset = true;
        this.requestRerender();
    }
    transformCanvas(t) {
        if (t.type === "translate") {
            const old = this.viewport.getTransform();
            if (t.x === 0 && t.y === 0) return;
            this.viewport.setTransform({
                ...old,
                x: old.x + t.x,
                y: old.y + t.y
            });
        } else if (t.type === "zoom") {
            const old = this.viewport.getTransform();
            const viewportRect = this.viewport.getElement().getBoundingClientRect();
            t.vX = t.vX ?? viewportRect.width / 2;
            t.vY = t.vY ?? viewportRect.height / 2;
            const metaTransform = (0, _toMetaTransform.toMetaTransform)(old, {
                x: t.vX,
                y: t.vY
            });
            metaTransform.scale *= t.fac;
            this.viewport.setTransform((0, _createTransform.createTransform)(metaTransform.viewportP, metaTransform.canvasP, metaTransform.scale, metaTransform.angleDeg));
        }
        this.isReset = false;
        this.requestRerender();
    }
    // ---- public ----
    constructor(p){
        this.isReset = true;
        this.doRender = false;
        this.lastEmittedTransform = {
            x: 0,
            y: 0,
            scale: 0,
            angleDeg: 0
        };
        this.renderLoop = ()=>{
            this.animationFrameId = requestAnimationFrame(this.renderLoop);
            if (this.doRender) {
                this.doRender = false;
                this.viewport.render();
                const viewportTransform = this.viewport.getTransform();
                if (this.onTransformChange && JSON.stringify(this.lastEmittedTransform) !== JSON.stringify(viewportTransform)) {
                    this.onTransformChange(viewportTransform);
                    this.lastEmittedTransform = viewportTransform;
                }
            }
        };
        this.onWheel = (e)=>{
            const viewportRect = this.viewport.getElement().getBoundingClientRect();
            const vX = e.pageX - viewportRect.x;
            const vY = e.pageY - viewportRect.y;
            const oldScale = this.viewport.getTransform().scale;
            const newScale = (0, _zoomByStep.zoomByStep)(oldScale, -e.deltaY / 2);
            this.transformCanvas({
                type: "zoom",
                vX,
                vY,
                fac: newScale / oldScale
            });
        };
        this.width = p.width;
        this.height = p.height;
        this.project = p.project;
        this.onTransformChange = p.onTransformChange;
        this.padding = p.padding ?? DEFAULT_PADDING;
        const fit = (0, _bb.BB).fitInto(this.project.width, this.project.height, this.width - this.padding * 2, this.height - this.padding * 2);
        const scale = fit.width / this.project.width;
        this.viewport = new (0, _projectViewport.ProjectViewport)({
            width: this.width,
            height: this.height,
            transform: (0, _createTransform.createTransform)({
                x: this.width / 2,
                y: this.height / 2
            }, {
                x: this.project.width / 2,
                y: this.project.height / 2
            }, scale, 0),
            project: this.project,
            useNativeResolution: false,
            drawBackground: true
        });
        const doubleTapper = new (0, _doubleTapper.DoubleTapper)({
            onDoubleTap: (e)=>{
                const m = (0, _createTransformMatrix.createTransformMatrix)(this.viewport.getTransform());
                const tl = (0, _transformationMatrix.applyToPoint)(m, {
                    x: 0,
                    y: 0
                });
                const br = (0, _transformationMatrix.applyToPoint)(m, {
                    x: this.project.width,
                    y: this.project.height
                });
                const isInside = (0, _bb.BB).isInsideRect({
                    x: e.relX,
                    y: e.relY
                }, {
                    x: tl.x,
                    y: tl.y,
                    width: br.x - tl.x,
                    height: br.y - tl.y
                });
                if (!this.isReset || isInside) this.resetOrZoom(e.relX, e.relY);
            },
            isInstant: true
        });
        let oldTransform = undefined;
        const pinchZoomer = new (0, _pinchZoomer.PinchZoomer)({
            onPinch: (e)=>{
                if (e.type === "move") {
                    if (!oldTransform) oldTransform = this.viewport.getTransform();
                    const metaTransform = (0, _toMetaTransform.toMetaTransform)(oldTransform, {
                        x: e.downRelX,
                        y: e.downRelY
                    });
                    metaTransform.scale *= e.scale;
                    metaTransform.viewportP.x += e.relX - e.downRelX;
                    metaTransform.viewportP.y += e.relY - e.downRelY;
                    this.viewport.setTransform((0, _createTransform.createTransform)(metaTransform.viewportP, metaTransform.canvasP, metaTransform.scale, metaTransform.angleDeg));
                    this.requestRerender();
                    this.isReset = false;
                } else if (e.type === "end") oldTransform = undefined;
            }
        });
        this.pointerChain = new (0, _eventChain.EventChain)({
            chainArr: [
                pinchZoomer,
                doubleTapper
            ]
        });
        this.pointerChain.setChainOut((e)=>{
            if (e.button && [
                "left",
                "middle"
            ].includes(e.button)) // debugOut(JSON.stringify(e));
            this.transformCanvas({
                type: "translate",
                x: e.dX,
                y: e.dY
            });
        });
        this.viewport.getElement().classList.add((0, _css.css)({
            cursor: "grab",
            ":active": {
                cursor: "grabbing"
            }
        }));
        (0, _bb.BB).css(this.viewport.getElement(), {
            userSelect: "none",
            touchAction: "none"
        });
        this.viewport.getElement().addEventListener("touchend", (e)=>{
            e.preventDefault();
            return false;
        });
        this.viewport.getElement().addEventListener("contextmenu", (e)=>{
            e.preventDefault();
            return false;
        });
        this.viewport.getElement().addEventListener("dragstart", (e)=>{
            e.preventDefault();
            return false;
        });
        this.viewportPointerListener = new (0, _pointerListener.PointerListener)({
            target: this.viewport.getElement(),
            onPointer: (e)=>{
                this.pointerChain.chainIn(e);
            },
            onWheel: this.onWheel,
            maxPointers: 2
        });
        this.viewport.getElement().addEventListener("wheel", (e)=>{
            e.preventDefault();
        });
        if (p.hasEditMode) this.modeToggle = new (0, _options.Options)({
            optionArr: [
                "edit",
                "hand"
            ].map((id)=>{
                const el = (0, _bb.BB).el({
                    className: "dark-invert",
                    css: {
                        width: "28px",
                        height: "28px",
                        backgroundSize: "contain",
                        margin: "5px",
                        backgroundImage: `url(${id === "edit" ? p.editIcon ?? (0, _editPencilSvgDefault.default) : (0, _toolHandSvgDefault.default)})`,
                        backgroundPosition: "center",
                        backgroundRepeat: "no-repeat"
                    }
                });
                return {
                    id,
                    label: el,
                    title: id === "edit" ? (0, _language.LANG)("tab-edit") : (0, _language.LANG)("tool-hand")
                };
            }),
            initId: "edit",
            onChange: (val)=>{
                p.onModeChange && p.onModeChange(val);
            }
        });
        const elCss = (0, _css.css)(p.hasBorder === false ? {} : {
            borderTop: "1px solid #7f7f7f",
            borderBottom: "1px solid #7f7f7f",
            ".kl-theme-dark &": {
                borderTop: "1px solid #636363",
                borderBottom: "1px solid #636363"
            }
        });
        // pointer-events: auto - So the canvas can be ignored, while the buttons still work.
        this.rootEl = (0, _c.c)({
            className: elCss,
            css: {
                position: "relative"
            }
        }, [
            this.viewport.getElement(),
            ...this.modeToggle ? [
                (0, _c.c)(",pos-absolute,left-5,top-5,z-1,pointer-auto", [
                    this.modeToggle.getElement()
                ])
            ] : [],
            (0, _c.c)(",pos-absolute,right-5,bottom-5,flex,flexCol,gap-5,z-1,pointer-auto", [
                (0, _c.c)({
                    tagName: "button",
                    title: (0, _language.LANG)("hand-reset"),
                    onClick: ()=>{
                        this.reset();
                    },
                    content: `<img alt="reset" height="20" src="${(0, _viewportResetSvgDefault.default)}">`,
                    noRef: true
                }),
                (0, _c.c)({
                    tagName: "button",
                    title: (0, _language.LANG)("zoom-in"),
                    onClick: ()=>{
                        const oldScale = this.viewport.getTransform().scale;
                        const newScale = (0, _zoomByStep.zoomByStep)(oldScale, 1);
                        this.transformCanvas({
                            type: "zoom",
                            fac: newScale / oldScale
                        });
                    },
                    content: `<img alt="zoom-in" height="20" src="${(0, _toolZoomInSvgDefault.default)}">`,
                    noRef: true
                }),
                (0, _c.c)({
                    tagName: "button",
                    title: (0, _language.LANG)("zoom-out"),
                    onClick: ()=>{
                        const oldScale = this.viewport.getTransform().scale;
                        const newScale = (0, _zoomByStep.zoomByStep)(oldScale, -1);
                        this.transformCanvas({
                            type: "zoom",
                            fac: newScale / oldScale
                        });
                    },
                    content: `<img alt="zoom-out" height="20" src="${(0, _toolZoomOutSvgDefault.default)}">`,
                    noRef: true
                })
            ])
        ]);
        this.renderLoop();
    }
    render() {
        this.requestRerender();
    }
    setTransform(transform) {
        this.viewport.setTransform(transform);
        this.requestRerender();
        this.isReset = false;
    }
    getTransform() {
        return this.viewport.getTransform();
    }
    onPointer(event) {
        this.pointerChain.chainIn(event);
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.animationFrameId !== undefined && cancelAnimationFrame(this.animationFrameId);
        this.viewport.destroy();
        this.viewportPointerListener.destroy();
        this.rootEl.remove();
        this.modeToggle && this.modeToggle.destroy();
    }
}

},{"../../../bb/base/c":"eg9k9","./project-viewport":"6Wqv3","../../../bb/bb":"dcQKo","../../../bb/input/pointer-listener":"5fbd0","/src/app/img/ui/tool-zoom-in.svg":"cnuMH","/src/app/img/ui/tool-zoom-out.svg":"9Sixr","/src/app/img/ui/viewport-reset.svg":"kuqpf","/src/app/img/ui/tool-hand.svg":"anjr6","/src/app/img/ui/edit-pencil.svg":"93UFg","../../../bb/input/event-chain/event-chain":"gQC7e","../../../bb/input/event-chain/double-tapper":"7kjBa","@emotion/css":"gyRZs","./utils/create-transform-matrix":"6WuHP","./utils/zoom-by-step":"2W8z6","../../../bb/input/event-chain/pinch-zoomer":"T8qtt","../../../language/language":"iiYGN","transformation-matrix":"3I2Wq","./utils/create-transform":"4syvJ","./utils/to-meta-transform":"4hKAd","../components/options":"hNLP6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Wqv3":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 *
 * Scale - size of one project-canvas pixel compared to CSS pixel
 *      -> 1 means 1 pixel in the drawing is the size of a CSS pixel
 *      -> independent of device pixel ratio, or what resolution the viewport
 *          canvas may actually have.
 * Translate - translates in CSS pixels
 * Viewport origin is top left (same as canvas)
 *
 * Order of transformations (matrix multiplication is reversed): translate, rotate, scale
 */ parcelHelpers.export(exports, "ProjectViewport", ()=>ProjectViewport);
var _bb = require("../../../bb/bb");
var _base = require("../../../bb/base/base");
var _theme = require("../../../theme/theme");
var _transformationMatrix = require("transformation-matrix");
var _createTransformMatrix = require("./utils/create-transform-matrix");
function fixScale(scale, pixels) {
    return Math.round(pixels * scale) / pixels;
}
class ProjectViewport {
    // ---- public ----
    constructor(p){
        this.doResize = true;
        this.onIsDark = ()=>{
            this.pattern = (0, _base.throwIfNull)(this.ctx.createPattern((0, _bb.BB).createCheckerCanvas(10, (0, _theme.theme).isDark()), "repeat"));
            this.render();
        };
        this.oldDPR = devicePixelRatio;
        this.resizeListener = ()=>{
            if (devicePixelRatio !== this.oldDPR) {
                this.canvas.style.imageRendering = Math.round(devicePixelRatio) !== devicePixelRatio ? "" : "pixelated";
                this.oldDPR = devicePixelRatio;
            }
        };
        this.width = p.width;
        this.height = p.height;
        this.project = p.project;
        this.useNativeResolution = !!p.useNativeResolution;
        this.drawBackground = !!p.drawBackground;
        this.doFillParent = !!p.fillParent;
        this.transform = {
            ...p.transform
        };
        this.resFactor = this.useNativeResolution ? devicePixelRatio : 1;
        this.canvas = (0, _bb.BB).canvas(this.width * this.resFactor, this.height * this.resFactor);
        this.ctx = (0, _bb.BB).ctx(this.canvas);
        (0, _bb.BB).css(this.canvas, {
            width: this.doFillParent ? "100%" : this.width + "px",
            height: this.doFillParent ? "100%" : this.height + "px",
            imageRendering: Math.round(devicePixelRatio) !== devicePixelRatio ? undefined : "pixelated",
            display: "block"
        });
        window.addEventListener("resize", this.resizeListener);
        this.pattern = (0, _base.throwIfNull)(this.ctx.createPattern((0, _bb.BB).createCheckerCanvas(10, (0, _theme.theme).isDark()), "repeat"));
        (0, _theme.theme).addIsDarkListener(this.onIsDark);
    // this.render();
    }
    render() {
        const isDark = (0, _theme.theme).isDark();
        const transform = {
            ...this.transform,
            x: this.transform.x,
            y: this.transform.y,
            scale: this.transform.scale
        };
        if (this.doResize) {
            this.doResize = false;
            this.resFactor = this.useNativeResolution ? devicePixelRatio : 1;
            this.canvas.width = Math.round(this.width * this.resFactor);
            this.canvas.height = Math.round(this.height * this.resFactor);
        }
        const renderedTransform = {
            x: Math.round(transform.x),
            y: Math.round(transform.y),
            scaleX: fixScale(transform.scale, this.project.width),
            scaleY: fixScale(transform.scale, this.project.height),
            angleDeg: transform.angleDeg
        };
        const renderedMat = (0, _createTransformMatrix.createTransformMatrix)(renderedTransform);
        this.ctx.save();
        this.ctx.imageSmoothingEnabled = false;
        if (this.drawBackground) {
            this.ctx.fillStyle = isDark ? "rgb(33, 33, 33)" : "rgb(158,158,158)";
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        } else {
            this.ctx.fillStyle = this.pattern;
            this.ctx.fillRect(0, 0, this.width, this.height);
        }
        // this.ctx.scale(this.resFactor, this.resFactor);
        this.ctx.translate(renderedTransform.x, renderedTransform.y);
        this.ctx.scale(renderedTransform.scaleX, renderedTransform.scaleY);
        this.ctx.rotate(renderedTransform.angleDeg / 180 * Math.PI);
        if (this.drawBackground) {
            this.ctx.save();
            this.ctx.fillStyle = (0, _theme.theme).isDark() ? "rgba(255,255,255,0.25)" : "rgba(0,0,0,0.2)";
            const scaledPixelX = 1 / renderedTransform.scaleX;
            const scaledPixelY = 1 / renderedTransform.scaleY;
            this.ctx.fillRect(-scaledPixelX, -scaledPixelY, this.project.width + scaledPixelX * 2, this.project.height + scaledPixelY * 2);
            this.ctx.fillStyle = this.pattern;
            this.pattern.setTransform((0, _transformationMatrix.inverse)(renderedMat));
            this.ctx.fillRect(0, 0, this.project.width, this.project.height);
            this.ctx.restore();
        }
        this.project.layers.forEach((layer)=>{
            if (!layer.isVisible || !layer.opacity) return;
            this.ctx.save();
            this.ctx.globalCompositeOperation = layer.mixModeStr;
            this.ctx.globalAlpha = layer.opacity;
            let image = {};
            if (typeof layer.image === "function") {
                const res = layer.image(renderedTransform, this.canvas.width, this.canvas.height);
                if ("image" in res && "transform" in res) {
                    image = res.image;
                    this.ctx.setTransform((0, _transformationMatrix.compose)(renderedMat, res.transform));
                } else image = res;
            } else image = layer.image;
            this.ctx.drawImage(image, 0, 0); // , this.project.width, this.project.height);
            this.ctx.restore();
        });
        this.ctx.restore();
    }
    setSize(width, height) {
        this.doResize = true;
        this.width = width;
        this.height = height;
        (0, _bb.BB).css(this.canvas, {
            width: this.doFillParent ? "100%" : this.width + "px",
            height: this.doFillParent ? "100%" : this.height + "px"
        });
    }
    setTransform(transform) {
        this.transform = {
            ...transform
        };
    }
    getTransform() {
        return {
            ...this.transform
        };
    }
    setUseNativeResolution(b) {
        this.useNativeResolution = b;
        this.doResize = true;
    }
    getUseNativeResolution() {
        return this.useNativeResolution;
    }
    getElement() {
        return this.canvas;
    }
    destroy() {
        (0, _bb.BB).freeCanvas(this.canvas);
        (0, _theme.theme).removeIsDarkListener(this.onIsDark);
        window.removeEventListener("resize", this.resizeListener);
    }
}

},{"../../../bb/bb":"dcQKo","../../../bb/base/base":"k6nNY","../../../theme/theme":"4G3JB","transformation-matrix":"3I2Wq","./utils/create-transform-matrix":"6WuHP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3I2Wq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
var _applyToPoint = require("./applyToPoint");
parcelHelpers.exportAll(_applyToPoint, exports);
var _fromObject = require("./fromObject");
parcelHelpers.exportAll(_fromObject, exports);
var _fromString = require("./fromString");
parcelHelpers.exportAll(_fromString, exports);
var _identity = require("./identity");
parcelHelpers.exportAll(_identity, exports);
var _inverse = require("./inverse");
parcelHelpers.exportAll(_inverse, exports);
var _isAffineMatrix = require("./isAffineMatrix");
parcelHelpers.exportAll(_isAffineMatrix, exports);
var _rotate = require("./rotate");
parcelHelpers.exportAll(_rotate, exports);
var _scale = require("./scale");
parcelHelpers.exportAll(_scale, exports);
var _shear = require("./shear");
parcelHelpers.exportAll(_shear, exports);
var _skew = require("./skew");
parcelHelpers.exportAll(_skew, exports);
var _toString = require("./toString");
parcelHelpers.exportAll(_toString, exports);
var _transform = require("./transform");
parcelHelpers.exportAll(_transform, exports);
var _translate = require("./translate");
parcelHelpers.exportAll(_translate, exports);
var _fromTriangles = require("./fromTriangles");
parcelHelpers.exportAll(_fromTriangles, exports);
var _smoothMatrix = require("./smoothMatrix");
parcelHelpers.exportAll(_smoothMatrix, exports);
var _fromDefinition = require("./fromDefinition");
parcelHelpers.exportAll(_fromDefinition, exports);
var _fromTransformAttribute = require("./fromTransformAttribute");
parcelHelpers.exportAll(_fromTransformAttribute, exports);
var _decompose = require("./decompose");
parcelHelpers.exportAll(_decompose, exports);
var _flip = require("./flip");
parcelHelpers.exportAll(_flip, exports);
var _fromMovingPoints = require("./fromMovingPoints");
parcelHelpers.exportAll(_fromMovingPoints, exports);

},{"./applyToPoint":"6HIJo","./fromObject":"k1z74","./fromString":"baNlK","./identity":"fxqHX","./inverse":"2VFSl","./isAffineMatrix":"7bPBE","./rotate":"4qSDX","./scale":"k8rob","./shear":"eaCmL","./skew":"dB2mz","./toString":"gzYQ5","./transform":"7y0OC","./translate":"M54fd","./fromTriangles":"hQysT","./smoothMatrix":"kEXHW","./fromDefinition":"8h2Cd","./fromTransformAttribute":"1jfER","./decompose":"cSrxf","./flip":"bAFnL","./fromMovingPoints":"8bq7D","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6HIJo":[function(require,module,exports) {
/**
 * Calculate a point transformed with an affine matrix
 * @param matrix {Matrix} Affine Matrix
 * @param  point {Point} Point
 * @returns {Point} Point
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "applyToPoint", ()=>applyToPoint);
/**
 * Calculate an array of points transformed with an affine matrix
 * @param matrix {Matrix} Affine Matrix
 * @param points {Point[]} Array of point
 * @returns {Point[]} Array of point
 */ parcelHelpers.export(exports, "applyToPoints", ()=>applyToPoints);
function applyToPoint(matrix, point) {
    return Array.isArray(point) ? [
        matrix.a * point[0] + matrix.c * point[1] + matrix.e,
        matrix.b * point[0] + matrix.d * point[1] + matrix.f
    ] : {
        x: matrix.a * point.x + matrix.c * point.y + matrix.e,
        y: matrix.b * point.x + matrix.d * point.y + matrix.f
    };
}
function applyToPoints(matrix, points) {
    return points.map((point)=>applyToPoint(matrix, point));
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k1z74":[function(require,module,exports) {
/**
 * Extract an affine matrix from an object that contains a,b,c,d,e,f keys
 * Any value could be a float or a string that contains a float
 * @param object {Object} Object that contains a,b,c,d,e,f keys
 * @return {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fromObject", ()=>fromObject);
function fromObject(object) {
    return {
        a: parseFloat(object.a),
        b: parseFloat(object.b),
        c: parseFloat(object.c),
        d: parseFloat(object.d),
        e: parseFloat(object.e),
        f: parseFloat(object.f)
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"baNlK":[function(require,module,exports) {
/**
 * @ignore
 * @type {RegExp}
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parse a string formatted as matrix(a,b,c,d,e,f)
 * @param string {string} String with an affine matrix
 * @returns {Matrix} Affine Matrix
 *
 * @example
 * > fromString('matrix(1,2,3,4,5,6)')
 * {a: 1, b: 2, c: 3, d: 4, c: 5, e: 6}
 */ parcelHelpers.export(exports, "fromString", ()=>fromString);
const matrixRegex = /^matrix\(\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*,\s*([0-9_+-.e]+)\s*\)$/i;
function fromString(string) {
    const parsed = string.match(matrixRegex);
    if (parsed === null || parsed.length < 7) throw new Error(`'${string}' is not a matrix`);
    return {
        a: parseFloat(parsed[1]),
        b: parseFloat(parsed[2]),
        c: parseFloat(parsed[3]),
        d: parseFloat(parsed[4]),
        e: parseFloat(parsed[5]),
        f: parseFloat(parsed[6])
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fxqHX":[function(require,module,exports) {
/**
 * Identity matrix
 * @returns {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "identity", ()=>identity);
function identity() {
    return {
        a: 1,
        c: 0,
        e: 0,
        b: 0,
        d: 1,
        f: 0
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2VFSl":[function(require,module,exports) {
/**
 * Calculate a matrix that is the inverse of the provided matrix
 * @param matrix {Matrix} Affine Matrix
 * @returns {Matrix} Inverted Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "inverse", ()=>inverse);
function inverse(matrix) {
    // http://www.wolframalpha.com/input/?i=Inverse+%5B%7B%7Ba,c,e%7D,%7Bb,d,f%7D,%7B0,0,1%7D%7D%5D
    const { a, b, c, d, e, f } = matrix;
    const denom = a * d - b * c;
    return {
        a: d / denom,
        b: b / -denom,
        c: c / -denom,
        d: a / denom,
        e: (d * e - c * f) / -denom,
        f: (b * e - a * f) / denom
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7bPBE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Check if the object contain an affine matrix
 * @param object {Object} Generic Plain Object
 * @return {boolean} True if is an object and contains an affine matrix
 */ parcelHelpers.export(exports, "isAffineMatrix", ()=>isAffineMatrix);
var _utils = require("./utils");
function isAffineMatrix(object) {
    return (0, _utils.isObject)(object) && "a" in object && (0, _utils.isNumeric)(object.a) && "b" in object && (0, _utils.isNumeric)(object.b) && "c" in object && (0, _utils.isNumeric)(object.c) && "d" in object && (0, _utils.isNumeric)(object.d) && "e" in object && (0, _utils.isNumeric)(object.e) && "f" in object && (0, _utils.isNumeric)(object.f);
}

},{"./utils":"iclPO","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iclPO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "isUndefined", ()=>isUndefined);
parcelHelpers.export(exports, "isNumeric", ()=>isNumeric);
parcelHelpers.export(exports, "isObject", ()=>isObject);
parcelHelpers.export(exports, "matchesShape", ()=>matchesShape);
function isUndefined(val) {
    return typeof val === "undefined";
}
function isNumeric(n) {
    return typeof n === "number" && !Number.isNaN(n) && Number.isFinite(n);
}
function isObject(obj) {
    return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
function matchesShape(obj, keys) {
    return keys.every((key)=>key in obj);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4qSDX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculate a rotation matrix
 * @param angle {number} Angle in radians
 * @param [cx] {number} If (cx,cy) are supplied the rotate is about this point
 * @param [cy] {number} If (cx,cy) are supplied the rotate is about this point
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "rotate", ()=>rotate);
/**
 * Calculate a rotation matrix with a DEG angle
 * @param angle {number} Angle in degree
 * @param [cx] {number} If (cx,cy) are supplied the rotate is about this point
 * @param [cy] {number} If (cx,cy) are supplied the rotate is about this point
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "rotateDEG", ()=>rotateDEG);
var _utils = require("./utils");
var _translate = require("./translate");
var _transform = require("./transform");
const { cos, sin, PI } = Math;
function rotate(angle, cx, cy) {
    const cosAngle = cos(angle);
    const sinAngle = sin(angle);
    const rotationMatrix = {
        a: cosAngle,
        c: -sinAngle,
        e: 0,
        b: sinAngle,
        d: cosAngle,
        f: 0
    };
    if ((0, _utils.isUndefined)(cx) || (0, _utils.isUndefined)(cy)) return rotationMatrix;
    return (0, _transform.transform)([
        (0, _translate.translate)(cx, cy),
        rotationMatrix,
        (0, _translate.translate)(-cx, -cy)
    ]);
}
function rotateDEG(angle, cx, cy) {
    return rotate(angle * PI / 180, cx, cy);
}

},{"./utils":"iclPO","./translate":"M54fd","./transform":"7y0OC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"M54fd":[function(require,module,exports) {
/**
 * Calculate a translate matrix
 * @param tx {number} Translation on axis x
 * @param [ty = 0] {number} Translation on axis y
 * @returns {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "translate", ()=>translate);
function translate(tx, ty = 0) {
    return {
        a: 1,
        c: 0,
        e: tx,
        b: 0,
        d: 1,
        f: ty
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7y0OC":[function(require,module,exports) {
/**
 * Merge multiple matrices into one
 * @param matrices {...Matrix | Matrix[]} Matrices listed as separate parameters or in an array
 * @returns {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "transform", ()=>transform);
/**
 * Merge multiple matrices into one
 * @param matrices {...Matrix | Matrix[]} Matrices listed as separate parameters or in an array
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "compose", ()=>compose);
function transform(...matrices) {
    matrices = Array.isArray(matrices[0]) ? matrices[0] : matrices;
    const multiply = (m1, m2)=>{
        return {
            a: m1.a * m2.a + m1.c * m2.b,
            c: m1.a * m2.c + m1.c * m2.d,
            e: m1.a * m2.e + m1.c * m2.f + m1.e,
            b: m1.b * m2.a + m1.d * m2.b,
            d: m1.b * m2.c + m1.d * m2.d,
            f: m1.b * m2.e + m1.d * m2.f + m1.f
        };
    };
    switch(matrices.length){
        case 0:
            throw new Error("no matrices provided");
        case 1:
            return matrices[0];
        case 2:
            return multiply(matrices[0], matrices[1]);
        default:
            {
                const [m1, m2, ...rest] = matrices;
                const m = multiply(m1, m2);
                return transform(m, ...rest);
            }
    }
}
function compose(...matrices) {
    return transform(...matrices);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k8rob":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculate a scaling matrix
 * @param sx {number} Scaling on axis x
 * @param [sy = sx] {number} Scaling on axis y (default sx)
 * @param [cx] {number} If (cx,cy) are supplied the scaling is about this point
 * @param [cy] {number} If (cx,cy) are supplied the scaling is about this point
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "scale", ()=>scale);
var _utils = require("./utils");
var _translate = require("./translate");
var _transform = require("./transform");
function scale(sx, sy, cx, cy) {
    if ((0, _utils.isUndefined)(sy)) sy = sx;
    const scaleMatrix = {
        a: sx,
        c: 0,
        e: 0,
        b: 0,
        d: sy,
        f: 0
    };
    if ((0, _utils.isUndefined)(cx) || (0, _utils.isUndefined)(cy)) return scaleMatrix;
    return (0, _transform.transform)([
        (0, _translate.translate)(cx, cy),
        scaleMatrix,
        (0, _translate.translate)(-cx, -cy)
    ]);
}

},{"./utils":"iclPO","./translate":"M54fd","./transform":"7y0OC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eaCmL":[function(require,module,exports) {
/**
 * Calculate a shear matrix
 * @param shx {number} Shear on axis x
 * @param shy {number} Shear on axis y
 * @returns {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "shear", ()=>shear);
function shear(shx, shy) {
    return {
        a: 1,
        c: shx,
        e: 0,
        b: shy,
        d: 1,
        f: 0
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dB2mz":[function(require,module,exports) {
// https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Calculate a skew matrix
 * @param ax {number} Skew on axis x
 * @param ay {number} Skew on axis y
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "skew", ()=>skew);
/**
 * Calculate a skew matrix using DEG angles
 * @param ax {number} Skew on axis x
 * @param ay {number} Skew on axis y
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "skewDEG", ()=>skewDEG);
const { tan } = Math;
function skew(ax, ay) {
    return {
        a: 1,
        c: tan(ax),
        e: 0,
        b: tan(ay),
        d: 1,
        f: 0
    };
}
function skewDEG(ax, ay) {
    return skew(ax * Math.PI / 180, ay * Math.PI / 180);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gzYQ5":[function(require,module,exports) {
/**
 * Serialize an affine matrix to a string that can be used with CSS or SVG
 * @param matrix {Matrix} Affine Matrix
 * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toCSS", ()=>toCSS);
/**
 * Serialize an affine matrix to a string that can be used with CSS or SVG
 * @param matrix {Matrix} Affine Matrix
 * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)
 */ parcelHelpers.export(exports, "toSVG", ()=>toSVG);
/**
 * Serialize an affine matrix to a string that can be used with CSS or SVG
 * @param matrix {Matrix} Affine Matrix
 * @returns {string} String that contains an affine matrix formatted as matrix(a,b,c,d,e,f)
 */ parcelHelpers.export(exports, "toString", ()=>toString);
function toCSS(matrix) {
    return toString(matrix);
}
function toSVG(matrix) {
    return toString(matrix);
}
function toString(matrix) {
    return `matrix(${matrix.a},${matrix.b},${matrix.c},${matrix.d},${matrix.e},${matrix.f})`;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hQysT":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Returns a matrix that transforms a triangle t1 into another triangle t2, or throws an exception if it is impossible.
 * @param t1 {Point[]} Array of points containing the three points for the first triangle
 * @param t2 {Point[]} Array of points containing the three points for the second triangle
 * @returns {Matrix} Matrix which transforms t1 to t2
 * @throws Exception if the matrix becomes not invertible
 */ parcelHelpers.export(exports, "fromTriangles", ()=>fromTriangles);
var _inverse = require("./inverse");
var _transform = require("./transform");
var _smoothMatrix = require("./smoothMatrix");
function fromTriangles(t1, t2) {
    // point p = first point of the triangle
    const px1 = t1[0].x != null ? t1[0].x : t1[0][0];
    const py1 = t1[0].y != null ? t1[0].y : t1[0][1];
    const px2 = t2[0].x != null ? t2[0].x : t2[0][0];
    const py2 = t2[0].y != null ? t2[0].y : t2[0][1];
    // point q = second point of the triangle
    const qx1 = t1[1].x != null ? t1[1].x : t1[1][0];
    const qy1 = t1[1].y != null ? t1[1].y : t1[1][1];
    const qx2 = t2[1].x != null ? t2[1].x : t2[1][0];
    const qy2 = t2[1].y != null ? t2[1].y : t2[1][1];
    // point r = third point of the triangle
    const rx1 = t1[2].x != null ? t1[2].x : t1[2][0];
    const ry1 = t1[2].y != null ? t1[2].y : t1[2][1];
    const rx2 = t2[2].x != null ? t2[2].x : t2[2][0];
    const ry2 = t2[2].y != null ? t2[2].y : t2[2][1];
    const r1 = {
        a: px1 - rx1,
        b: py1 - ry1,
        c: qx1 - rx1,
        d: qy1 - ry1,
        e: rx1,
        f: ry1
    };
    const r2 = {
        a: px2 - rx2,
        b: py2 - ry2,
        c: qx2 - rx2,
        d: qy2 - ry2,
        e: rx2,
        f: ry2
    };
    const inverseR1 = (0, _inverse.inverse)(r1);
    const affineMatrix = (0, _transform.transform)([
        r2,
        inverseR1
    ]);
    // round the matrix elements to smooth the finite inversion
    return (0, _smoothMatrix.smoothMatrix)(affineMatrix);
}

},{"./inverse":"2VFSl","./transform":"7y0OC","./smoothMatrix":"kEXHW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kEXHW":[function(require,module,exports) {
/**
 * Rounds all elements of the given matrix using the given precision
 * @param matrix {Matrix} An affine matrix to round
 * @param [precision] {number} A precision to use for Math.round. Defaults to 10000000000 (meaning which rounds to the 10th digit after the comma).
 * @returns {Matrix} The rounded Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "smoothMatrix", ()=>smoothMatrix);
function smoothMatrix(matrix, precision = 10000000000) {
    return {
        a: Math.round(matrix.a * precision) / precision,
        b: Math.round(matrix.b * precision) / precision,
        c: Math.round(matrix.c * precision) / precision,
        d: Math.round(matrix.d * precision) / precision,
        e: Math.round(matrix.e * precision) / precision,
        f: Math.round(matrix.f * precision) / precision
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8h2Cd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Converts array of matrix descriptor to array of matrix
 * @param definitionOrArrayOfDefinition {Object[]} Array of object describing the matrix
 * @returns {Matrix[]} Array of matrix
 *
 * @example
 * > fromDefinition([
 *  { type: 'matrix', a:1, b:2, c:3, d:4, e:5, f:6 },
 *  { type: 'translate', tx: 10, ty: 20 },
 *  { type: 'scale', sx: 2, sy: 4 },
 *  { type: 'rotate', angle: 90, cx: 50, cy: 25 },
 *  { type: 'skewX', angle: 45 },
 *  { type: 'skewY',  angle: 45 },
 *  { type: 'shear', shx: 10, shy: 20}
 * ])
 *
 * [
 *  { a: 1, b: 2, c: 3, d: 4, e: 5, f: 6 },
 *  { a: 1, c: 0, e: 10, b: 0, d: 1, f: 20 },
 *  { a: 2, c: 0, e: 0, b: 0, d: 4, f: 0 },
 *  { a: 6.123, c: -1, e: 0, b: 1, d: 6.123, f: 0 },
 *  { a: 1, c: 0.99.., e: 0, b: 0, d: 1, f: 0 },
 *  { a: 1, c: 0, e: 0, b: 0.99, d: 1, f: 0 },
 *  { a: 1, c: 10, e: 0, b: 20, d: 1, f: 0 }
 * ]
 **/ parcelHelpers.export(exports, "fromDefinition", ()=>fromDefinition);
var _fromObject = require("./fromObject");
var _translate = require("./translate");
var _scale = require("./scale");
var _rotate = require("./rotate");
var _skew = require("./skew");
var _shear = require("./shear");
function fromDefinition(definitionOrArrayOfDefinition) {
    return Array.isArray(definitionOrArrayOfDefinition) ? definitionOrArrayOfDefinition.map(mapper) : mapper(definitionOrArrayOfDefinition);
    function mapper(descriptor) {
        switch(descriptor.type){
            case "matrix":
                if ("a" in descriptor && "b" in descriptor && "c" in descriptor && "d" in descriptor && "e" in descriptor && "f" in descriptor) return (0, _fromObject.fromObject)(descriptor);
                else throw new Error("MISSING_MANDATORY_PARAM");
            case "translate":
                if (!("tx" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
                if ("ty" in descriptor) return (0, _translate.translate)(descriptor.tx, descriptor.ty);
                return (0, _translate.translate)(descriptor.tx);
            case "scale":
                if (!("sx" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
                if ("sy" in descriptor) return (0, _scale.scale)(descriptor.sx, descriptor.sy);
                return (0, _scale.scale)(descriptor.sx);
            case "rotate":
                if (!("angle" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
                if ("cx" in descriptor && "cy" in descriptor) return (0, _rotate.rotateDEG)(descriptor.angle, descriptor.cx, descriptor.cy);
                return (0, _rotate.rotateDEG)(descriptor.angle);
            case "skewX":
                if (!("angle" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
                return (0, _skew.skewDEG)(descriptor.angle, 0);
            case "skewY":
                if (!("angle" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
                return (0, _skew.skewDEG)(0, descriptor.angle);
            case "shear":
                if (!("shx" in descriptor && "shy" in descriptor)) throw new Error("MISSING_MANDATORY_PARAM");
                return (0, _shear.shear)(descriptor.shx, descriptor.shy);
            default:
                throw new Error("UNSUPPORTED_DESCRIPTOR");
        }
    }
}

},{"./fromObject":"k1z74","./translate":"M54fd","./scale":"k8rob","./rotate":"4qSDX","./skew":"dB2mz","./shear":"eaCmL","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1jfER":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Parser for SVG Trasform Attribute http://www.w3.org/TR/SVG/coords.html#TransformAttribute <br/>
 * Warning: This should be considered BETA until it is released a stable version of pegjs.
 * @param transformString {string} Transform string as defined by w3 Consortium
 * @returns {MatrixDescriptor[]} Array of MatrixDescriptor
 *
 * @example
 * > fromTransformAttribute('translate(-10,-10) scale(2,2) translate(10,10)')
 * [
 *  { type: 'translate', tx: -10, ty: -10},
 *  { type: 'scale', sx: 2, sy: 2 },
 *  { type: 'translate', tx: 10, ty: 10}
 * ]
 *
 * > compose(fromDefinition(fromTransformAttribute('translate(-10, -10) scale(10, 10)')))
 * { a: 10, c: 0, e: -10, b: 0, d: 10, f: -10 }
 */ parcelHelpers.export(exports, "fromTransformAttribute", ()=>fromTransformAttribute);
var _fromTransformAttributeAutogenerated = require("./fromTransformAttribute.autogenerated");
function fromTransformAttribute(transformString) {
    return (0, _fromTransformAttributeAutogenerated.parse)(transformString);
}

},{"./fromTransformAttribute.autogenerated":"aU0df","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aU0df":[function(require,module,exports) {
// Generated by Peggy 3.0.0.
//
// https://peggyjs.org/
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SyntaxError", ()=>peg$SyntaxError);
parcelHelpers.export(exports, "parse", ()=>peg$parse);
function peg$subclass(child, parent) {
    function C() {
        this.constructor = child;
    }
    C.prototype = parent.prototype;
    child.prototype = new C();
}
function peg$SyntaxError(message, expected, found, location) {
    var self = Error.call(this, message);
    // istanbul ignore next Check is a necessary evil to support older environments
    if (Object.setPrototypeOf) Object.setPrototypeOf(self, peg$SyntaxError.prototype);
    self.expected = expected;
    self.found = found;
    self.location = location;
    self.name = "SyntaxError";
    return self;
}
peg$subclass(peg$SyntaxError, Error);
function peg$padEnd(str, targetLength, padString) {
    padString = padString || " ";
    if (str.length > targetLength) return str;
    targetLength -= str.length;
    padString += padString.repeat(targetLength);
    return str + padString.slice(0, targetLength);
}
peg$SyntaxError.prototype.format = function(sources) {
    var str = "Error: " + this.message;
    if (this.location) {
        var src = null;
        var k;
        for(k = 0; k < sources.length; k++)if (sources[k].source === this.location.source) {
            src = sources[k].text.split(/\r\n|\n|\r/g);
            break;
        }
        var s = this.location.start;
        var offset_s = this.location.source && typeof this.location.source.offset === "function" ? this.location.source.offset(s) : s;
        var loc = this.location.source + ":" + offset_s.line + ":" + offset_s.column;
        if (src) {
            var e = this.location.end;
            var filler = peg$padEnd("", offset_s.line.toString().length, " ");
            var line = src[s.line - 1];
            var last = s.line === e.line ? e.column : line.length + 1;
            var hatLen = last - s.column || 1;
            str += "\n --> " + loc + "\n" + filler + " |\n" + offset_s.line + " | " + line + "\n" + filler + " | " + peg$padEnd("", s.column - 1, " ") + peg$padEnd("", hatLen, "^");
        } else str += "\n at " + loc;
    }
    return str;
};
peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
            return '"' + literalEscape(expectation.text) + '"';
        },
        class: function(expectation) {
            var escapedParts = expectation.parts.map(function(part) {
                return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
            });
            return "[" + (expectation.inverted ? "^" : "") + escapedParts.join("") + "]";
        },
        any: function() {
            return "any character";
        },
        end: function() {
            return "end of input";
        },
        other: function(expectation) {
            return expectation.description;
        }
    };
    function hex(ch) {
        return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
        });
    }
    function classEscape(s) {
        return s.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
            return "\\x0" + hex(ch);
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
            return "\\x" + hex(ch);
        });
    }
    function describeExpectation(expectation) {
        return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }
    function describeExpected(expected) {
        var descriptions = expected.map(describeExpectation);
        var i, j;
        descriptions.sort();
        if (descriptions.length > 0) {
            for(i = 1, j = 1; i < descriptions.length; i++)if (descriptions[i - 1] !== descriptions[i]) {
                descriptions[j] = descriptions[i];
                j++;
            }
            descriptions.length = j;
        }
        switch(descriptions.length){
            case 1:
                return descriptions[0];
            case 2:
                return descriptions[0] + " or " + descriptions[1];
            default:
                return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
        }
    }
    function describeFound(found) {
        return found ? '"' + literalEscape(found) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};
function peg$parse(input, options) {
    options = options !== undefined ? options : {};
    var peg$FAILED = {};
    var peg$source = options.grammarSource;
    var peg$startRuleFunctions = {
        transformList: peg$parsetransformList
    };
    var peg$startRuleFunction = peg$parsetransformList;
    var peg$c0 = "matrix";
    var peg$c1 = "(";
    var peg$c2 = ")";
    var peg$c3 = "translate";
    var peg$c4 = "scale";
    var peg$c5 = "rotate";
    var peg$c6 = "skewX";
    var peg$c7 = "skewY";
    var peg$c8 = ",";
    var peg$c9 = ".";
    var peg$r0 = /^[eE]/;
    var peg$r1 = /^[+\-]/;
    var peg$r2 = /^[0-9]/;
    var peg$r3 = /^[ \t\r\n]/;
    var peg$e0 = peg$literalExpectation("matrix", false);
    var peg$e1 = peg$literalExpectation("(", false);
    var peg$e2 = peg$literalExpectation(")", false);
    var peg$e3 = peg$literalExpectation("translate", false);
    var peg$e4 = peg$literalExpectation("scale", false);
    var peg$e5 = peg$literalExpectation("rotate", false);
    var peg$e6 = peg$literalExpectation("skewX", false);
    var peg$e7 = peg$literalExpectation("skewY", false);
    var peg$e8 = peg$literalExpectation(",", false);
    var peg$e9 = peg$otherExpectation("fractionalConstant");
    var peg$e10 = peg$literalExpectation(".", false);
    var peg$e11 = peg$classExpectation([
        "e",
        "E"
    ], false, false);
    var peg$e12 = peg$classExpectation([
        "+",
        "-"
    ], false, false);
    var peg$e13 = peg$classExpectation([
        [
            "0",
            "9"
        ]
    ], false, false);
    var peg$e14 = peg$classExpectation([
        " ",
        "	",
        "\r",
        "\n"
    ], false, false);
    var peg$f0 = function(ts) {
        return ts;
    };
    var peg$f1 = function(t, ts) {
        return t.concat(ts);
    };
    var peg$f2 = function(a, b, c, d, e, f) {
        return [
            {
                type: "matrix",
                a: a,
                b: b,
                c: c,
                d: d,
                e: e,
                f: f
            }
        ];
    };
    var peg$f3 = function(tx, ty) {
        var t = {
            type: "translate",
            tx: tx
        };
        if (ty) t.ty = ty;
        return [
            t
        ];
    };
    var peg$f4 = function(sx, sy) {
        var s = {
            type: "scale",
            sx: sx
        };
        if (sy) s.sy = sy;
        return [
            s
        ];
    };
    var peg$f5 = function(angle, c) {
        var r = {
            type: "rotate",
            angle: angle
        };
        if (c) {
            r.cx = c[0];
            r.cy = c[1];
        }
        return [
            r
        ];
    };
    var peg$f6 = function(angle) {
        return [
            {
                type: "skewX",
                angle: angle
            }
        ];
    };
    var peg$f7 = function(angle) {
        return [
            {
                type: "skewY",
                angle: angle
            }
        ];
    };
    var peg$f8 = function(f) {
        return parseFloat(f.join(""));
    };
    var peg$f9 = function(i) {
        return parseInt(i.join(""));
    };
    var peg$f10 = function(n) {
        return n;
    };
    var peg$f11 = function(n1, n2) {
        return [
            n1,
            n2
        ];
    };
    var peg$f12 = function(ds) {
        return ds.join("");
    };
    var peg$f13 = function(f, e) {
        return [
            f,
            e || null
        ].join("");
    };
    var peg$f14 = function(d, e) {
        return [
            d,
            e
        ].join("");
    };
    var peg$f15 = function(d1, d2) {
        return [
            d1 ? d1.join("") : null,
            ".",
            d2.join("")
        ].join("");
    };
    var peg$f16 = function(d) {
        return d.join("");
    };
    var peg$f17 = function(s, d) {
        return [
            "e",
            s,
            d.join("")
        ].join("");
    };
    var peg$currPos = 0;
    var peg$savedPos = 0;
    var peg$posDetailsCache = [
        {
            line: 1,
            column: 1
        }
    ];
    var peg$maxFailPos = 0;
    var peg$maxFailExpected = [];
    var peg$silentFails = 0;
    var peg$result;
    if ("startRule" in options) {
        if (!(options.startRule in peg$startRuleFunctions)) throw new Error("Can't start parsing from rule \"" + options.startRule + '".');
        peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }
    function text() {
        return input.substring(peg$savedPos, peg$currPos);
    }
    function offset() {
        return peg$savedPos;
    }
    function range() {
        return {
            source: peg$source,
            start: peg$savedPos,
            end: peg$currPos
        };
    }
    function location() {
        return peg$computeLocation(peg$savedPos, peg$currPos);
    }
    function expected(description, location) {
        location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildStructuredError([
            peg$otherExpectation(description)
        ], input.substring(peg$savedPos, peg$currPos), location);
    }
    function error(message, location) {
        location = location !== undefined ? location : peg$computeLocation(peg$savedPos, peg$currPos);
        throw peg$buildSimpleError(message, location);
    }
    function peg$literalExpectation(text, ignoreCase) {
        return {
            type: "literal",
            text: text,
            ignoreCase: ignoreCase
        };
    }
    function peg$classExpectation(parts, inverted, ignoreCase) {
        return {
            type: "class",
            parts: parts,
            inverted: inverted,
            ignoreCase: ignoreCase
        };
    }
    function peg$anyExpectation() {
        return {
            type: "any"
        };
    }
    function peg$endExpectation() {
        return {
            type: "end"
        };
    }
    function peg$otherExpectation(description) {
        return {
            type: "other",
            description: description
        };
    }
    function peg$computePosDetails(pos) {
        var details = peg$posDetailsCache[pos];
        var p;
        if (details) return details;
        else {
            p = pos - 1;
            while(!peg$posDetailsCache[p])p--;
            details = peg$posDetailsCache[p];
            details = {
                line: details.line,
                column: details.column
            };
            while(p < pos){
                if (input.charCodeAt(p) === 10) {
                    details.line++;
                    details.column = 1;
                } else details.column++;
                p++;
            }
            peg$posDetailsCache[pos] = details;
            return details;
        }
    }
    function peg$computeLocation(startPos, endPos, offset) {
        var startPosDetails = peg$computePosDetails(startPos);
        var endPosDetails = peg$computePosDetails(endPos);
        var res = {
            source: peg$source,
            start: {
                offset: startPos,
                line: startPosDetails.line,
                column: startPosDetails.column
            },
            end: {
                offset: endPos,
                line: endPosDetails.line,
                column: endPosDetails.column
            }
        };
        if (offset && peg$source && typeof peg$source.offset === "function") {
            res.start = peg$source.offset(res.start);
            res.end = peg$source.offset(res.end);
        }
        return res;
    }
    function peg$fail(expected) {
        if (peg$currPos < peg$maxFailPos) return;
        if (peg$currPos > peg$maxFailPos) {
            peg$maxFailPos = peg$currPos;
            peg$maxFailExpected = [];
        }
        peg$maxFailExpected.push(expected);
    }
    function peg$buildSimpleError(message, location) {
        return new peg$SyntaxError(message, null, null, location);
    }
    function peg$buildStructuredError(expected, found, location) {
        return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
    }
    function peg$parsetransformList() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsewsp();
        while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parsewsp();
        }
        s2 = peg$parsetransforms();
        if (s2 === peg$FAILED) s2 = null;
        s3 = [];
        s4 = peg$parsewsp();
        while(s4 !== peg$FAILED){
            s3.push(s4);
            s4 = peg$parsewsp();
        }
        peg$savedPos = s0;
        s0 = peg$f0(s2);
        return s0;
    }
    function peg$parsetransforms() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$parsetransform();
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsecommaWsp();
            if (s3 !== peg$FAILED) while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsecommaWsp();
            }
            else s2 = peg$FAILED;
            if (s2 !== peg$FAILED) {
                s3 = peg$parsetransforms();
                if (s3 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f1(s1, s3);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) s0 = peg$parsetransform();
        return s0;
    }
    function peg$parsetransform() {
        var s0;
        s0 = peg$parsematrix();
        if (s0 === peg$FAILED) {
            s0 = peg$parsetranslate();
            if (s0 === peg$FAILED) {
                s0 = peg$parsescale();
                if (s0 === peg$FAILED) {
                    s0 = peg$parserotate();
                    if (s0 === peg$FAILED) {
                        s0 = peg$parseskewX();
                        if (s0 === peg$FAILED) s0 = peg$parseskewY();
                    }
                }
            }
        }
        return s0;
    }
    function peg$parsematrix() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c0) {
            s1 = peg$c0;
            peg$currPos += 6;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e0);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsecommaWsp();
                    if (s6 !== peg$FAILED) {
                        s7 = peg$parsenumber();
                        if (s7 !== peg$FAILED) {
                            s8 = peg$parsecommaWsp();
                            if (s8 !== peg$FAILED) {
                                s9 = peg$parsenumber();
                                if (s9 !== peg$FAILED) {
                                    s10 = peg$parsecommaWsp();
                                    if (s10 !== peg$FAILED) {
                                        s11 = peg$parsenumber();
                                        if (s11 !== peg$FAILED) {
                                            s12 = peg$parsecommaWsp();
                                            if (s12 !== peg$FAILED) {
                                                s13 = peg$parsenumber();
                                                if (s13 !== peg$FAILED) {
                                                    s14 = peg$parsecommaWsp();
                                                    if (s14 !== peg$FAILED) {
                                                        s15 = peg$parsenumber();
                                                        if (s15 !== peg$FAILED) {
                                                            s16 = [];
                                                            s17 = peg$parsewsp();
                                                            while(s17 !== peg$FAILED){
                                                                s16.push(s17);
                                                                s17 = peg$parsewsp();
                                                            }
                                                            if (input.charCodeAt(peg$currPos) === 41) {
                                                                s17 = peg$c2;
                                                                peg$currPos++;
                                                            } else {
                                                                s17 = peg$FAILED;
                                                                if (peg$silentFails === 0) peg$fail(peg$e2);
                                                            }
                                                            if (s17 !== peg$FAILED) {
                                                                peg$savedPos = s0;
                                                                s0 = peg$f2(s5, s7, s9, s11, s13, s15);
                                                            } else {
                                                                peg$currPos = s0;
                                                                s0 = peg$FAILED;
                                                            }
                                                        } else {
                                                            peg$currPos = s0;
                                                            s0 = peg$FAILED;
                                                        }
                                                    } else {
                                                        peg$currPos = s0;
                                                        s0 = peg$FAILED;
                                                    }
                                                } else {
                                                    peg$currPos = s0;
                                                    s0 = peg$FAILED;
                                                }
                                            } else {
                                                peg$currPos = s0;
                                                s0 = peg$FAILED;
                                            }
                                        } else {
                                            peg$currPos = s0;
                                            s0 = peg$FAILED;
                                        }
                                    } else {
                                        peg$currPos = s0;
                                        s0 = peg$FAILED;
                                    }
                                } else {
                                    peg$currPos = s0;
                                    s0 = peg$FAILED;
                                }
                            } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                            }
                        } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                        }
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsetranslate() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 9) === peg$c3) {
            s1 = peg$c3;
            peg$currPos += 9;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e3);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsecommaWspNumber();
                    if (s6 === peg$FAILED) s6 = null;
                    s7 = [];
                    s8 = peg$parsewsp();
                    while(s8 !== peg$FAILED){
                        s7.push(s8);
                        s8 = peg$parsewsp();
                    }
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s8 = peg$c2;
                        peg$currPos++;
                    } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e2);
                    }
                    if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f3(s5, s6);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsescale() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c4) {
            s1 = peg$c4;
            peg$currPos += 5;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e4);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsecommaWspNumber();
                    if (s6 === peg$FAILED) s6 = null;
                    s7 = [];
                    s8 = peg$parsewsp();
                    while(s8 !== peg$FAILED){
                        s7.push(s8);
                        s8 = peg$parsewsp();
                    }
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s8 = peg$c2;
                        peg$currPos++;
                    } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e2);
                    }
                    if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f4(s5, s6);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parserotate() {
        var s0, s1, s2, s3, s4, s5, s6, s7, s8;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 6) === peg$c5) {
            s1 = peg$c5;
            peg$currPos += 6;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e5);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = peg$parsecommaWspTwoNumbers();
                    if (s6 === peg$FAILED) s6 = null;
                    s7 = [];
                    s8 = peg$parsewsp();
                    while(s8 !== peg$FAILED){
                        s7.push(s8);
                        s8 = peg$parsewsp();
                    }
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s8 = peg$c2;
                        peg$currPos++;
                    } else {
                        s8 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e2);
                    }
                    if (s8 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f5(s5, s6);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseskewX() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c6) {
            s1 = peg$c6;
            peg$currPos += 5;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e6);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parsewsp();
                    while(s7 !== peg$FAILED){
                        s6.push(s7);
                        s7 = peg$parsewsp();
                    }
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s7 = peg$c2;
                        peg$currPos++;
                    } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e2);
                    }
                    if (s7 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f6(s5);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parseskewY() {
        var s0, s1, s2, s3, s4, s5, s6, s7;
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c7) {
            s1 = peg$c7;
            peg$currPos += 5;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e7);
        }
        if (s1 !== peg$FAILED) {
            s2 = [];
            s3 = peg$parsewsp();
            while(s3 !== peg$FAILED){
                s2.push(s3);
                s3 = peg$parsewsp();
            }
            if (input.charCodeAt(peg$currPos) === 40) {
                s3 = peg$c1;
                peg$currPos++;
            } else {
                s3 = peg$FAILED;
                if (peg$silentFails === 0) peg$fail(peg$e1);
            }
            if (s3 !== peg$FAILED) {
                s4 = [];
                s5 = peg$parsewsp();
                while(s5 !== peg$FAILED){
                    s4.push(s5);
                    s5 = peg$parsewsp();
                }
                s5 = peg$parsenumber();
                if (s5 !== peg$FAILED) {
                    s6 = [];
                    s7 = peg$parsewsp();
                    while(s7 !== peg$FAILED){
                        s6.push(s7);
                        s7 = peg$parsewsp();
                    }
                    if (input.charCodeAt(peg$currPos) === 41) {
                        s7 = peg$c2;
                        peg$currPos++;
                    } else {
                        s7 = peg$FAILED;
                        if (peg$silentFails === 0) peg$fail(peg$e2);
                    }
                    if (s7 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f7(s5);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsenumber() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        s1 = peg$currPos;
        s2 = peg$parsesign();
        if (s2 === peg$FAILED) s2 = null;
        s3 = peg$parsefloatingPointConstant();
        if (s3 !== peg$FAILED) {
            s2 = [
                s2,
                s3
            ];
            s1 = s2;
        } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
        }
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f8(s1);
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$currPos;
            s2 = peg$parsesign();
            if (s2 === peg$FAILED) s2 = null;
            s3 = peg$parseintegerConstant();
            if (s3 !== peg$FAILED) {
                s2 = [
                    s2,
                    s3
                ];
                s1 = s2;
            } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
            }
            if (s1 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$f9(s1);
            }
            s0 = s1;
        }
        return s0;
    }
    function peg$parsecommaWspNumber() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parsecommaWsp();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber();
            if (s2 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f10(s2);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsecommaWspTwoNumbers() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = peg$parsecommaWsp();
        if (s1 !== peg$FAILED) {
            s2 = peg$parsenumber();
            if (s2 !== peg$FAILED) {
                s3 = peg$parsecommaWsp();
                if (s3 !== peg$FAILED) {
                    s4 = peg$parsenumber();
                    if (s4 !== peg$FAILED) {
                        peg$savedPos = s0;
                        s0 = peg$f11(s2, s4);
                    } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                    }
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsecommaWsp() {
        var s0, s1, s2, s3, s4;
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parsewsp();
        if (s2 !== peg$FAILED) while(s2 !== peg$FAILED){
            s1.push(s2);
            s2 = peg$parsewsp();
        }
        else s1 = peg$FAILED;
        if (s1 !== peg$FAILED) {
            s2 = peg$parsecomma();
            if (s2 === peg$FAILED) s2 = null;
            s3 = [];
            s4 = peg$parsewsp();
            while(s4 !== peg$FAILED){
                s3.push(s4);
                s4 = peg$parsewsp();
            }
            s1 = [
                s1,
                s2,
                s3
            ];
            s0 = s1;
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsecomma();
            if (s1 !== peg$FAILED) {
                s2 = [];
                s3 = peg$parsewsp();
                while(s3 !== peg$FAILED){
                    s2.push(s3);
                    s3 = peg$parsewsp();
                }
                s1 = [
                    s1,
                    s2
                ];
                s0 = s1;
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parsecomma() {
        var s0;
        if (input.charCodeAt(peg$currPos) === 44) {
            s0 = peg$c8;
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e8);
        }
        return s0;
    }
    function peg$parseintegerConstant() {
        var s0, s1;
        s0 = peg$currPos;
        s1 = peg$parsedigitSequence();
        if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$f12(s1);
        }
        s0 = s1;
        return s0;
    }
    function peg$parsefloatingPointConstant() {
        var s0, s1, s2;
        s0 = peg$currPos;
        s1 = peg$parsefractionalConstant();
        if (s1 !== peg$FAILED) {
            s2 = peg$parseexponent();
            if (s2 === peg$FAILED) s2 = null;
            peg$savedPos = s0;
            s0 = peg$f13(s1, s2);
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedigitSequence();
            if (s1 !== peg$FAILED) {
                s2 = peg$parseexponent();
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f14(s1, s2);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        return s0;
    }
    function peg$parsefractionalConstant() {
        var s0, s1, s2, s3;
        peg$silentFails++;
        s0 = peg$currPos;
        s1 = peg$parsedigitSequence();
        if (s1 === peg$FAILED) s1 = null;
        if (input.charCodeAt(peg$currPos) === 46) {
            s2 = peg$c9;
            peg$currPos++;
        } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e10);
        }
        if (s2 !== peg$FAILED) {
            s3 = peg$parsedigitSequence();
            if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f15(s1, s3);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedigitSequence();
            if (s1 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 46) {
                    s2 = peg$c9;
                    peg$currPos++;
                } else {
                    s2 = peg$FAILED;
                    if (peg$silentFails === 0) peg$fail(peg$e10);
                }
                if (s2 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s0 = peg$f16(s1);
                } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                }
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        }
        peg$silentFails--;
        if (s0 === peg$FAILED) {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e9);
        }
        return s0;
    }
    function peg$parseexponent() {
        var s0, s1, s2, s3;
        s0 = peg$currPos;
        if (peg$r0.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e11);
        }
        if (s1 !== peg$FAILED) {
            s2 = peg$parsesign();
            if (s2 === peg$FAILED) s2 = null;
            s3 = peg$parsedigitSequence();
            if (s3 !== peg$FAILED) {
                peg$savedPos = s0;
                s0 = peg$f17(s2, s3);
            } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
            }
        } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
        }
        return s0;
    }
    function peg$parsesign() {
        var s0;
        if (peg$r1.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e12);
        }
        return s0;
    }
    function peg$parsedigitSequence() {
        var s0, s1;
        s0 = [];
        s1 = peg$parsedigit();
        if (s1 !== peg$FAILED) while(s1 !== peg$FAILED){
            s0.push(s1);
            s1 = peg$parsedigit();
        }
        else s0 = peg$FAILED;
        return s0;
    }
    function peg$parsedigit() {
        var s0;
        if (peg$r2.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e13);
        }
        return s0;
    }
    function peg$parsewsp() {
        var s0;
        if (peg$r3.test(input.charAt(peg$currPos))) {
            s0 = input.charAt(peg$currPos);
            peg$currPos++;
        } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) peg$fail(peg$e14);
        }
        return s0;
    }
    peg$result = peg$startRuleFunction();
    if (peg$result !== peg$FAILED && peg$currPos === input.length) return peg$result;
    else {
        if (peg$result !== peg$FAILED && peg$currPos < input.length) peg$fail(peg$endExpectation());
        throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cSrxf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Decompose a matrix into translation, scaling and rotation components, optionally
 * take horizontal and vertical flip in to consideration.
 * Note this function decomposes a matrix in rotation -> scaling -> translation order. I.e. for
 * certain translation T {tx, ty}, rotation R and scaling S { sx, sy }, it's only true for:
 *  decomposeTSR(compose(T, S, R)) === { translate: T, rotation: R, scale: S }
 * composing in a different order may yield a different decomposition result.
 * @param matrix {Matrix} Affine Matrix
 * @param  flipX {boolean} Whether the matrix contains vertical flip, i.e. mirrors on x-axis
 * @param  flipY {boolean} Whether the matrix contains horizontal flip, i.e. mirrors on y-axis
 * @returns {Transform} A transform object consisted by its translation, scaling
 * and rotation components.
 */ parcelHelpers.export(exports, "decomposeTSR", ()=>decomposeTSR);
var _scale = require("./scale");
var _transform = require("./transform");
function decomposeTSR(matrix, flipX = false, flipY = false) {
    // Remove flip from the matrix first - flip could be incorrectly interpreted as
    // rotations (e.g. flipX + flipY = rotate by 180 degrees).
    // Note flipX is a vertical flip, and flipY is a horizontal flip.
    if (flipX) {
        if (flipY) matrix = (0, _transform.compose)(matrix, (0, _scale.scale)(-1, -1));
        else matrix = (0, _transform.compose)(matrix, (0, _scale.scale)(1, -1));
    } else if (flipY) matrix = (0, _transform.compose)(matrix, (0, _scale.scale)(-1, 1));
    const a = matrix.a;
    const b = matrix.b;
    const c = matrix.c;
    const d = matrix.d;
    let scaleX, scaleY, rotation;
    if (a !== 0 || c !== 0) {
        const hypotAc = Math.hypot(a, c);
        scaleX = hypotAc;
        scaleY = (a * d - b * c) / hypotAc;
        const acos = Math.acos(a / hypotAc);
        rotation = c > 0 ? -acos : acos;
    } else if (b !== 0 || d !== 0) {
        const hypotBd = Math.hypot(b, d);
        scaleX = (a * d - b * c) / hypotBd;
        scaleY = hypotBd;
        const acos = Math.acos(b / hypotBd);
        rotation = Math.PI / 2 + (d > 0 ? -acos : acos);
    } else {
        scaleX = 0;
        scaleY = 0;
        rotation = 0;
    }
    // put the flip factors back
    if (flipY) scaleX = -scaleX;
    if (flipX) scaleY = -scaleY;
    return {
        translate: {
            tx: matrix.e,
            ty: matrix.f
        },
        scale: {
            sx: scaleX,
            sy: scaleY
        },
        rotation: {
            angle: rotation
        }
    };
}

},{"./scale":"k8rob","./transform":"7y0OC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bAFnL":[function(require,module,exports) {
/**
 * Tranformation matrix that mirrors on x-axis
 * @returns {Matrix} Affine Matrix
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "flipX", ()=>flipX);
/**
 * Tranformation matrix that mirrors on y-axis
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "flipY", ()=>flipY);
/**
 * Tranformation matrix that mirrors on origin
 * @returns {Matrix} Affine Matrix
 */ parcelHelpers.export(exports, "flipOrigin", ()=>flipOrigin);
function flipX() {
    return {
        a: 1,
        c: 0,
        e: 0,
        b: 0,
        d: -1,
        f: 0
    };
}
function flipY() {
    return {
        a: -1,
        c: 0,
        e: 0,
        b: 0,
        d: 1,
        f: 0
    };
}
function flipOrigin() {
    return {
        a: -1,
        c: 0,
        e: 0,
        b: 0,
        d: -1,
        f: 0
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bq7D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// https://manivannan-ai.medium.com/find-the-angle-between-three-points-from-2d-using-python-348c513e2cd
/**
 * Calculate a transformation matrix from a point that starts from A to A'
 * This approach can be associated to a pointer that moves on a device
 * @param {Point} startingPoint - Starting point (A)
 * @param {Point} endingPoint - Ending point (A')
 */ parcelHelpers.export(exports, "fromOneMovingPoint", ()=>fromOneMovingPoint);
/**
 * Calculate a transformation matrix about two points that move from positions A and B to A' and B'
 * This approach can be associated to a two finger gesture on a touch device
 * @param {Point} startingPoint1 - Starting Point (A)
 * @param {Point} startingPoint2 - Starting Point (B)
 * @param {Point} endingPoint1 - Ending point (A')
 * @param {Point} endingPoint2 - Ending Point (B')
 */ parcelHelpers.export(exports, "fromTwoMovingPoints", ()=>fromTwoMovingPoints);
var _translate = require("./translate");
var _applyToPoint = require("./applyToPoint");
var _rotate = require("./rotate");
var _scale = require("./scale");
var _transform = require("./transform");
function fromOneMovingPoint(startingPoint, endingPoint) {
    const tx = endingPoint.x - startingPoint.x;
    const ty = endingPoint.y - startingPoint.y;
    return (0, _translate.translate)(tx, ty);
}
function fromTwoMovingPoints(startingPoint1, startingPoint2, endingPoint1, endingPoint2) {
    // finds translation
    const translationMatrix = fromOneMovingPoint(startingPoint1, endingPoint1);
    const pointA = (0, _applyToPoint.applyToPoint)(translationMatrix, startingPoint2) // I have to translate this point
    ;
    const center = endingPoint1;
    const pointB = endingPoint2;
    // finds rotation matrix
    const angle = Math.atan2(pointB.y - center.y, pointB.x - center.x) - Math.atan2(pointA.y - center.y, pointA.x - center.x);
    const rotationMatrix = (0, _rotate.rotate)(angle, center.x, center.y);
    // finds scale matrix
    const d1 = Math.sqrt(Math.pow(pointA.x - center.x, 2) + Math.pow(pointA.y - center.y, 2));
    const d2 = Math.sqrt(Math.pow(pointB.x - center.x, 2) + Math.pow(pointB.y - center.y, 2));
    const scalingLevel = d2 / d1;
    const scalingMatrix = (0, _scale.scale)(scalingLevel, scalingLevel, center.x, center.y);
    return (0, _transform.compose)([
        translationMatrix,
        scalingMatrix,
        rotationMatrix
    ]);
}

},{"./translate":"M54fd","./applyToPoint":"6HIJo","./rotate":"4qSDX","./scale":"k8rob","./transform":"7y0OC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6WuHP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createTransformMatrix", ()=>createTransformMatrix);
var _transformationMatrix = require("transformation-matrix");
function createTransformMatrix(transform) {
    const scaleX = "scale" in transform ? transform.scale : transform.scaleX;
    const scaleY = "scale" in transform ? transform.scale : transform.scaleY;
    return (0, _transformationMatrix.compose)((0, _transformationMatrix.translate)(transform.x, transform.y), (0, _transformationMatrix.rotate)(transform.angleDeg / 180 * Math.PI), (0, _transformationMatrix.scale)(scaleX, scaleY));
}

},{"transformation-matrix":"3I2Wq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cnuMH":[function(require,module,exports) {
module.exports = require("e658bde1af3ff8b3").getBundleURL("d3gnI") + "tool-zoom-in.65ed57a3.svg" + "?" + Date.now();

},{"e658bde1af3ff8b3":"lgJ39"}],"9Sixr":[function(require,module,exports) {
module.exports = require("45f88ff49af63220").getBundleURL("d3gnI") + "tool-zoom-out.5ae00130.svg" + "?" + Date.now();

},{"45f88ff49af63220":"lgJ39"}],"kuqpf":[function(require,module,exports) {
module.exports = require("ac11e7885317fdf8").getBundleURL("d3gnI") + "viewport-reset.86073886.svg" + "?" + Date.now();

},{"ac11e7885317fdf8":"lgJ39"}],"anjr6":[function(require,module,exports) {
module.exports = require("5ff9a7487442bde9").getBundleURL("d3gnI") + "tool-hand.a8986b94.svg" + "?" + Date.now();

},{"5ff9a7487442bde9":"lgJ39"}],"93UFg":[function(require,module,exports) {
module.exports = require("8fc268745125b3c8").getBundleURL("d3gnI") + "edit-pencil.d49518db.svg" + "?" + Date.now();

},{"8fc268745125b3c8":"lgJ39"}],"2W8z6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "zoomByStep", ()=>zoomByStep);
function zoomByStep(oldScale, stepNum) {
    const step = Math.log2(oldScale);
    let newStep = step / Math.abs(stepNum);
    newStep += stepNum > 0 ? 1 : -1;
    newStep = Math.round(newStep);
    newStep *= Math.abs(stepNum);
    return Math.pow(2, newStep);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4syvJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createTransform", ()=>createTransform);
var _transformationMatrix = require("transformation-matrix");
function createTransform(viewportPoint, canvasPoint, scale, angleDeg) {
    const mat = (0, _transformationMatrix.compose)((0, _transformationMatrix.scale)(-scale, -scale), (0, _transformationMatrix.rotate)(angleDeg / 180 * Math.PI));
    const topLeftP = (0, _transformationMatrix.applyToPoint)(mat, canvasPoint);
    topLeftP.x += viewportPoint.x;
    topLeftP.y += viewportPoint.y;
    return {
        x: topLeftP.x,
        y: topLeftP.y,
        scale,
        angleDeg
    };
}

},{"transformation-matrix":"3I2Wq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4hKAd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toMetaTransform", ()=>toMetaTransform);
var _createTransformMatrix = require("./create-transform-matrix");
var _transformationMatrix = require("transformation-matrix");
function toMetaTransform(transform, viewportP) {
    const m = (0, _createTransformMatrix.createTransformMatrix)(transform);
    const canvasP = (0, _transformationMatrix.applyToPoint)((0, _transformationMatrix.inverse)(m), viewportP);
    return {
        viewportP,
        canvasP,
        scale: transform.scale,
        angleDeg: transform.angleDeg
    };
}

},{"./create-transform-matrix":"6WuHP","transformation-matrix":"3I2Wq","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"tY4Ae":[function(require,module,exports) {
module.exports = require("6d9a2594ceb42d64").getBundleURL("d3gnI") + "edit-crop.045a6cdf.svg" + "?" + Date.now();

},{"6d9a2594ceb42d64":"lgJ39"}],"9W8Vp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "clipboardDialog", ()=>clipboardDialog);
var _bb = require("../../../bb/bb");
var _showModal = require("./base/showModal");
var _cropCopy = require("../components/crop-copy");
var _language = require("../../../language/language");
function clipboardDialog(parent, fullCanvas, cropCallback, output, showCropButton) {
    let clipboardItemIsSupported = false;
    try {
        clipboardItemIsSupported = !!ClipboardItem;
    } catch (e) {}
    const div = document.createElement("div");
    const isSmall = window.innerWidth < 550 || window.innerHeight < 550;
    const topWrapper = (0, _bb.BB).el({
        content: (0, _language.LANG)("crop-drag-to-crop") + (clipboardItemIsSupported ? "" : "<br>" + (0, _language.LANG)("cropcopy-click-hold")),
        css: {
            textAlign: "center"
        }
    });
    div.append(topWrapper);
    const cropCopy = new (0, _cropCopy.CropCopy)({
        width: isSmall ? 340 : 540,
        height: isSmall ? 300 : 350,
        canvas: fullCanvas,
        isNotCopy: false,
        onChange: ()=>setTimeout(()=>updateBlob())
    });
    (0, _bb.BB).css(cropCopy.getEl(), {
        marginTop: "10px",
        marginLeft: "-20px"
    });
    div.append(cropCopy.getEl());
    let blob = undefined;
    // Safari doesn't allow any async operations between user interaction (click) and navigator.clipboard.write.
    // It throws "NotAllowedError: the request is not allowed by the user agent or the platform in the current context,
    // possibly because the user denied permission."
    // So, we try to prepare blob beforehand.
    let cropTimeout;
    function updateBlob() {
        if (!clipboardItemIsSupported) return;
        clearTimeout(cropTimeout);
        cropTimeout = setTimeout(()=>{
            cropCopy.getCroppedCanvas().toBlob((result)=>{
                blob = result ?? undefined;
            }, "image/png");
        }, 50);
    }
    async function toClipboard() {
        if (!blob) return;
        try {
            await navigator.clipboard.write([
                new ClipboardItem({
                    [blob.type]: blob
                })
            ]);
            setTimeout(function() {
                output.out((0, _language.LANG)("cropcopy-copied"), true);
            }, 200);
        } catch (err) {
            console.error(err.name, err.message);
            return;
        }
    }
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr, KeyEvent, comboStr) {
            if ([
                "ctrl+c",
                "cmd+c"
            ].includes(comboStr)) {
                toClipboard();
                closeFunc && closeFunc();
            }
        }
    });
    let closeFunc;
    function blur() {
        closeFunc && closeFunc();
    }
    window.addEventListener("blur", blur);
    const buttonArr = [];
    if (clipboardItemIsSupported) buttonArr.push((0, _language.LANG)("cropcopy-btn-copy"));
    if (showCropButton) buttonArr.push((0, _language.LANG)("cropcopy-btn-crop"));
    buttonArr.push("Cancel");
    (0, _showModal.showModal)({
        target: parent,
        message: "<b>" + (showCropButton ? `${(0, _language.LANG)("cropcopy-title-copy")} / ${(0, _language.LANG)("cropcopy-title-crop")}` : `${(0, _language.LANG)("cropcopy-title-copy")}`) + "</b>",
        div: div,
        style: isSmall ? {} : {
            width: "540px"
        },
        buttons: buttonArr,
        primaries: [
            (0, _language.LANG)("cropcopy-btn-copy")
        ],
        callback: function(result) {
            if (result === (0, _language.LANG)("cropcopy-btn-copy")) toClipboard();
            else if (result === (0, _language.LANG)("cropcopy-btn-crop")) {
                const rectObj = cropCopy.getRect();
                cropCallback({
                    left: Math.round(-rectObj.x),
                    right: Math.round(rectObj.x + rectObj.width - fullCanvas.width),
                    top: Math.round(-rectObj.y),
                    bottom: Math.round(rectObj.y + rectObj.height - fullCanvas.height)
                });
            }
            window.removeEventListener("blur", blur);
            (0, _bb.BB).freeCanvas(cropCopy.getCroppedCanvas());
            cropCopy.destroy();
            keyListener.destroy();
        },
        clickOnEnter: (0, _language.LANG)("cropcopy-btn-copy"),
        closeFunc: function(func) {
            closeFunc = func;
        }
    });
}

},{"../../../bb/bb":"dcQKo","./base/showModal":"hr9Po","../components/crop-copy":"aTBXS","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lykpU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "LayerManager", ()=>LayerManager);
var _bb = require("../../../../bb/bb");
var _klHistory = require("../../../history/kl-history");
var _select = require("../../components/select");
var _pointSlider = require("../../components/point-slider");
var _klCanvas = require("../../../canvas/kl-canvas");
var _language = require("../../../../language/language");
var _translateBlending = require("../../../canvas/translate-blending");
var _renameLayerDialog = require("./rename-layer-dialog");
var _mergeLayerDialog = require("./merge-layer-dialog");
var _theme = require("../../../../theme/theme");
var _base = require("../../../../bb/base/base");
var _browser = require("../../../../bb/base/browser");
var _c = require("../../../../bb/base/c");
var _dropdownMenu = require("../../components/dropdown-menu");
var _addLayerSvg = require("/src/app/img/ui/add-layer.svg");
var _addLayerSvgDefault = parcelHelpers.interopDefault(_addLayerSvg);
var _duplicateLayerSvg = require("/src/app/img/ui/duplicate-layer.svg");
var _duplicateLayerSvgDefault = parcelHelpers.interopDefault(_duplicateLayerSvg);
var _mergeLayersSvg = require("/src/app/img/ui/merge-layers.svg");
var _mergeLayersSvgDefault = parcelHelpers.interopDefault(_mergeLayersSvg);
var _removeLayerSvg = require("/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
var _renameLayerSvg = require("/src/app/img/ui/rename-layer.svg");
var _renameLayerSvgDefault = parcelHelpers.interopDefault(_renameLayerSvg);
var _caretDownSvg = require("/src/app/img/ui/caret-down.svg");
var _caretDownSvgDefault = parcelHelpers.interopDefault(_caretDownSvg);
const paddingLeft = 25;
class LayerManager {
    move(oldSpotIndex, newSpotIndex) {
        if (isNaN(oldSpotIndex) || isNaN(newSpotIndex)) throw "layermanager - invalid move";
        for(let i = 0; i < this.klCanvasLayerArr.length; i++)((i)=>{
            let posy = this.layerElArr[i].spot; // <- here
            if (this.layerElArr[i].spot === oldSpotIndex) posy = newSpotIndex;
            else {
                if (this.layerElArr[i].spot > oldSpotIndex) posy--;
                if (posy >= newSpotIndex) posy++;
            }
            this.layerElArr[i].spot = posy;
            this.layerElArr[i].posY = (this.layerHeight + this.layerSpacing) * (this.klCanvasLayerArr.length - posy - 1);
            this.layerElArr[i].style.top = this.layerElArr[i].posY + "px";
        })(i);
        if (oldSpotIndex === newSpotIndex) return;
        this.klCanvas.moveLayer(this.selectedSpotIndex, newSpotIndex - oldSpotIndex);
        this.klCanvasLayerArr = this.klCanvas.getLayers();
        this.selectedSpotIndex = newSpotIndex;
        this.mergeBtn.disabled = this.selectedSpotIndex === 0;
    }
    posToSpot(p) {
        let result = parseInt("" + (p / (this.layerHeight + this.layerSpacing) + 0.5));
        result = Math.min(this.klCanvasLayerArr.length - 1, Math.max(0, result));
        result = this.klCanvasLayerArr.length - result - 1;
        return result;
    }
    /**
     * update css position of all layers that are not being dragged, while dragging
     */ updateLayersVerticalPosition(id, newspot) {
        newspot = Math.min(this.klCanvasLayerArr.length - 1, Math.max(0, newspot));
        if (newspot === this.lastpos) return;
        for(let i = 0; i < this.klCanvasLayerArr.length; i++){
            if (this.layerElArr[i].spot === id) continue;
            let posy = this.layerElArr[i].spot;
            if (this.layerElArr[i].spot > id) posy--;
            if (posy >= newspot) posy++;
            this.layerElArr[i].posY = (this.layerHeight + this.layerSpacing) * (this.klCanvasLayerArr.length - posy - 1);
            this.layerElArr[i].style.top = this.layerElArr[i].posY + "px";
        }
        this.lastpos = newspot;
    }
    renameLayer(layerSpot) {
        (0, _renameLayerDialog.renameLayerDialog)(this.parentEl, this.klCanvas.getLayer(layerSpot).name, (newName)=>{
            if (newName === undefined || newName === this.klCanvas.getLayer(layerSpot).name) return;
            this.klCanvas.renameLayer(layerSpot, newName);
            this.createLayerList();
            (0, _klHistory.klHistory).pause(true);
            this.onSelect(layerSpot);
            (0, _klHistory.klHistory).pause(false);
        });
    }
    updateHeight() {
        this.layerListEl.style.height = this.layerElArr.length * 35 + "px";
    }
    createLayerList() {
        this.oldHistoryState = (0, _klHistory.klHistory).getState();
        this.klCanvasLayerArr = this.klCanvas.getLayers();
        const checkerImUrl = (0, _bb.BB).createCheckerDataUrl(4, undefined, (0, _theme.theme).isDark());
        const createLayerEntry = (index)=>{
            const klLayer = (0, _base.throwIfNull)(this.klCanvas.getLayer(index));
            const layerName = klLayer.name;
            const opacity = this.klCanvasLayerArr[index].opacity;
            const isVisible = klLayer.isVisible;
            const layercanvas = this.klCanvasLayerArr[index].context.canvas;
            const layer = (0, _bb.BB).el({
                className: "kl-layer"
            });
            this.layerElArr[index] = layer;
            layer.posY = (this.klCanvasLayerArr.length - 1) * 35 - index * 35;
            (0, _bb.BB).css(layer, {
                top: layer.posY + "px"
            });
            const innerLayer = (0, _bb.BB).el();
            (0, _bb.BB).css(innerLayer, {
                position: "relative"
            });
            const container1 = (0, _bb.BB).el();
            (0, _bb.BB).css(container1, {
                width: "270px",
                height: "34px"
            });
            const container2 = (0, _bb.BB).el();
            layer.append(innerLayer);
            innerLayer.append(container1, container2);
            layer.spot = index;
            //checkbox - visibility
            {
                const checkWrapper = (0, _bb.BB).el({
                    tagName: "label",
                    parent: container1,
                    title: (0, _language.LANG)("layers-visibility-toggle"),
                    css: {
                        display: "flex",
                        width: "25px",
                        height: "100%",
                        justifyContent: "right",
                        alignItems: "center",
                        cursor: "pointer"
                    }
                });
                const check = (0, _bb.BB).el({
                    tagName: "input",
                    parent: checkWrapper,
                    custom: {
                        type: "checkbox",
                        tabindex: "-1"
                    },
                    css: {
                        display: "block",
                        cursor: "pointer",
                        margin: "0",
                        marginRight: "5px"
                    }
                });
                check.checked = isVisible;
                check.onchange = ()=>{
                    this.klCanvas.setLayerIsVisible(layer.spot, check.checked);
                    this.createLayerList();
                    if (layer.spot === this.selectedSpotIndex) {
                        (0, _klHistory.klHistory).pause(true);
                        this.onSelect(this.selectedSpotIndex);
                        (0, _klHistory.klHistory).pause(false);
                    }
                };
                // prevent layer getting dragged
                const preventFunc = (e)=>{
                    e.preventDefault();
                    e.stopPropagation();
                };
                if (0, _browser.hasPointerEvents) checkWrapper.onpointerdown = preventFunc;
                else checkWrapper.onmousedown = preventFunc;
            }
            //thumb
            {
                const thumbDimensions = (0, _bb.BB).fitInto(layercanvas.width, layercanvas.height, 30, 30, 1);
                layer.thumb = (0, _bb.BB).canvas(thumbDimensions.width, thumbDimensions.height);
                const thc = (0, _bb.BB).ctx(layer.thumb);
                thc.save();
                if (layer.thumb.width > layercanvas.width) thc.imageSmoothingEnabled = false;
                thc.drawImage(layercanvas, 0, 0, layer.thumb.width, layer.thumb.height);
                thc.restore();
                (0, _bb.BB).css(layer.thumb, {
                    position: "absolute",
                    left: (32 - layer.thumb.width) / 2 + paddingLeft + "px",
                    top: (32 - layer.thumb.height) / 2 + 1 + "px"
                });
                layer.thumb.style.backgroundImage = "url(" + checkerImUrl + ")";
            }
            layer.label = (0, _bb.BB).el({
                className: "kl-layer__label"
            });
            layer.layerName = layerName;
            layer.label.append(layer.layerName);
            (0, _bb.BB).css(layer.label, {
                position: "absolute",
                left: 38 + paddingLeft + "px",
                top: "1px",
                fontSize: "13px",
                width: "170px",
                height: "20px",
                overflow: "hidden",
                whiteSpace: "nowrap"
            });
            layer.label.ondblclick = ()=>{
                this.renameLayer(layer.spot);
            };
            layer.opacityLabel = (0, _bb.BB).el({
                className: "kl-layer__opacity-label"
            });
            layer.opacity = opacity;
            layer.opacityLabel.append(parseInt("" + layer.opacity * 100) + "%");
            (0, _bb.BB).css(layer.opacityLabel, {
                position: "absolute",
                left: 189 + paddingLeft + "px",
                top: "1px",
                fontSize: "13px",
                textAlign: "right",
                width: "50px",
                transition: "color 0.2s ease-in-out",
                textDecoration: isVisible ? undefined : "line-through"
            });
            let oldOpacity;
            const opacitySlider = new (0, _pointSlider.PointSlider)({
                init: layer.opacity,
                width: 200,
                pointSize: 14,
                callback: (sliderValue, isFirst, isLast)=>{
                    if (isFirst) {
                        oldOpacity = this.klCanvas.getLayer(layer.spot).opacity;
                        (0, _klHistory.klHistory).pause(true);
                        return;
                    }
                    if (isLast) {
                        (0, _klHistory.klHistory).pause(false);
                        if (oldOpacity !== sliderValue) this.klCanvas.layerOpacity(layer.spot, sliderValue);
                        return;
                    }
                    layer.opacityLabel.innerHTML = Math.round(sliderValue * 100) + "%";
                    this.klCanvas.layerOpacity(layer.spot, sliderValue);
                }
            });
            (0, _bb.BB).css(opacitySlider.getEl(), {
                position: "absolute",
                left: 39 + paddingLeft + "px",
                top: "17px"
            });
            layer.opacitySlider = opacitySlider;
            //larger layer preview - hover
            layer.thumb.onpointerover = (e)=>{
                if (e.buttons !== 0 && (!e.pointerType || e.pointerType !== "touch")) return;
                const thumbDimensions = (0, _bb.BB).fitInto(layercanvas.width, layercanvas.height, 250, 250, 1);
                if (this.largeThumbCanvas.width !== thumbDimensions.width || this.largeThumbCanvas.height !== thumbDimensions.height) {
                    this.largeThumbCanvas.width = thumbDimensions.width;
                    this.largeThumbCanvas.height = thumbDimensions.height;
                }
                const ctx = (0, _bb.BB).ctx(this.largeThumbCanvas);
                ctx.save();
                if (this.largeThumbCanvas.width > layercanvas.width) ctx.imageSmoothingEnabled = false;
                ctx.imageSmoothingQuality = "high";
                ctx.clearRect(0, 0, this.largeThumbCanvas.width, this.largeThumbCanvas.height);
                ctx.drawImage(layercanvas, 0, 0, this.largeThumbCanvas.width, this.largeThumbCanvas.height);
                ctx.restore();
                (0, _bb.BB).css(this.largeThumbDiv, {
                    top: e.clientY - this.largeThumbCanvas.height / 2 + "px",
                    opacity: "0"
                });
                if (!this.largeThumbInDocument) {
                    document.body.append(this.largeThumbDiv);
                    this.largeThumbInDocument = true;
                }
                clearTimeout(this.largeThumbInTimeout);
                this.largeThumbInTimeout = setTimeout(()=>{
                    (0, _bb.BB).css(this.largeThumbDiv, {
                        opacity: "1"
                    });
                }, 20);
                clearTimeout(this.largeThumbTimeout);
            };
            layer.thumb.onpointerout = ()=>{
                clearTimeout(this.largeThumbInTimeout);
                (0, _bb.BB).css(this.largeThumbDiv, {
                    opacity: "0"
                });
                clearTimeout(this.largeThumbTimeout);
                this.largeThumbTimeout = setTimeout(()=>{
                    if (!this.largeThumbInDocument) return;
                    this.largeThumbDiv.remove();
                    this.largeThumbInDocument = false;
                }, 300);
            };
            container1.append(layer.thumb, layer.label, layer.opacityLabel, opacitySlider.getEl());
            let dragstart = false;
            let freshSelection = false;
            //events for moving layers up and down
            const dragEventHandler = (event)=>{
                if (event.type === "pointerdown" && event.button === "left") {
                    (0, _bb.BB).css(layer, {
                        transition: "box-shadow 0.3s ease-in-out"
                    });
                    layer.style.zIndex = "1";
                    this.lastpos = layer.spot;
                    freshSelection = false;
                    if (!layer.isSelected) {
                        freshSelection = true;
                        this.activateLayer(layer.spot);
                    }
                    dragstart = true;
                } else if (event.type === "pointermove" && event.button === "left") {
                    if (dragstart) {
                        dragstart = false;
                        (0, _bb.BB).css(layer, {
                            boxShadow: "1px 3px 5px rgba(0,0,0,0.4)"
                        });
                    }
                    layer.posY += event.dY;
                    const corrected = Math.max(0, Math.min((this.klCanvasLayerArr.length - 1) * 35, layer.posY));
                    layer.style.top = corrected + "px";
                    this.updateLayersVerticalPosition(layer.spot, this.posToSpot(layer.posY));
                }
                if (event.type === "pointerup") {
                    (0, _bb.BB).css(layer, {
                        transition: "all 0.1s linear"
                    });
                    setTimeout(()=>{
                        (0, _bb.BB).css(layer, {
                            boxShadow: ""
                        });
                    }, 20);
                    layer.posY = Math.max(0, Math.min((this.klCanvasLayerArr.length - 1) * 35, layer.posY));
                    layer.style.zIndex = "";
                    const newSpot = this.posToSpot(layer.posY);
                    const oldSpot = layer.spot;
                    this.move(layer.spot, newSpot);
                    if (oldSpot != newSpot) {
                        (0, _klHistory.klHistory).pause(true);
                        this.onSelect(this.selectedSpotIndex);
                        (0, _klHistory.klHistory).pause(false);
                    }
                    if (oldSpot === newSpot && freshSelection) this.onSelect(this.selectedSpotIndex);
                    freshSelection = false;
                }
            };
            layer.pointerListener = new (0, _bb.BB).PointerListener({
                target: container1,
                onPointer: dragEventHandler
            });
            this.layerListEl.append(layer);
        };
        this.layerElArr = [];
        while(this.layerListEl.firstChild){
            const child = this.layerListEl.firstChild;
            child.pointerListener.destroy();
            child.opacitySlider.destroy();
            child.remove();
        }
        for(let i = 0; i < this.klCanvasLayerArr.length; i++)createLayerEntry(i);
        this.activateLayer(this.selectedSpotIndex);
        this.updateHeight();
    }
    updateButtons() {
        const maxReached = this.klCanvasLayerArr.length === (0, _klCanvas.MAX_LAYERS);
        const oneLayer = this.klCanvasLayerArr.length === 1;
        this.addBtn.disabled = maxReached;
        this.removeBtn.disabled = oneLayer;
        this.duplicateBtn.disabled = maxReached;
        this.mergeBtn.disabled = this.selectedSpotIndex === 0;
        this.moreDropdown.setEnabled("merge-all", !oneLayer);
    }
    // ---- public ----
    constructor(klCanvas, onSelect, parentEl, uiState){
        this.lastpos = 0;
        this.layerHeight = 35;
        this.layerSpacing = 0;
        this.parentEl = parentEl;
        this.klCanvas = klCanvas;
        this.layerElArr = [];
        this.layerHeight = 35;
        this.layerSpacing = 0;
        const width = 270;
        this.onSelect = onSelect;
        this.uiState = uiState;
        this.largeThumbDiv = (0, _bb.BB).el({
            onClick: (0, _bb.BB).handleClick,
            css: {
                position: "absolute",
                top: "500px",
                background: "#aaa",
                boxShadow: "1px 1px 3px rgba(0,0,0,0.3)",
                pointerEvents: "none",
                padding: "0",
                border: "1px solid #aaa",
                transition: "opacity 0.3s ease-out",
                userSelect: "none"
            }
        });
        this.setUiState(uiState);
        (0, _bb.BB).createCheckerDataUrl(4, (url)=>{
            this.largeThumbDiv.style.backgroundImage = "url(" + url + ")";
        }, (0, _theme.theme).isDark());
        this.largeThumbCanvas = (0, _bb.BB).canvas(200, 200);
        this.largeThumbCanvas.style.display = "block";
        this.largeThumbDiv.append(this.largeThumbCanvas);
        this.largeThumbInDocument = false;
        this.klCanvasLayerArr = this.klCanvas.getLayers();
        this.selectedSpotIndex = this.klCanvasLayerArr.length - 1;
        this.rootEl = (0, _bb.BB).el({
            css: {
                marginRight: "10px",
                marginBottom: "10px",
                marginLeft: "10px",
                marginTop: "10px",
                cursor: "default"
            }
        });
        const listDiv = (0, _bb.BB).el({
            css: {
                width: width + "px",
                position: "relative",
                margin: "0 -10px",
                zIndex: "0"
            }
        });
        this.layerListEl = (0, _bb.BB).el({
            parent: listDiv
        });
        this.addBtn = (0, _bb.BB).el({
            tagName: "button"
        });
        this.duplicateBtn = (0, _bb.BB).el({
            tagName: "button"
        });
        this.mergeBtn = (0, _bb.BB).el({
            tagName: "button"
        });
        this.removeBtn = (0, _bb.BB).el({
            tagName: "button"
        });
        const renameBtn = (0, _bb.BB).el({
            tagName: "button"
        });
        this.moreDropdown = new (0, _dropdownMenu.DropdownMenu)({
            button: (0, _bb.BB).el({
                content: `<img src="${(0, _caretDownSvgDefault.default)}" width="13"/>`,
                css: {
                    display: "flex",
                    justifyContent: "center",
                    opacity: "0.9"
                }
            }),
            buttonTitle: (0, _language.LANG)("more"),
            items: [
                [
                    "merge-all",
                    (0, _language.LANG)("layers-merge-all")
                ]
            ],
            onItemClick: (id)=>{
                if (id === "merge-all") {
                    const newIndex = this.klCanvas.mergeAll();
                    if (newIndex === false) return;
                    this.klCanvasLayerArr = this.klCanvas.getLayers();
                    this.selectedSpotIndex = newIndex;
                    this.createLayerList();
                    (0, _klHistory.klHistory).pause(true);
                    this.onSelect(this.selectedSpotIndex);
                    (0, _klHistory.klHistory).pause(false);
                    this.updateButtons();
                }
            }
        });
        this.updateButtons();
        const createButtons = ()=>{
            const div = (0, _bb.BB).el();
            const async = ()=>{
                (0, _bb.BB).makeUnfocusable(this.addBtn);
                (0, _bb.BB).makeUnfocusable(this.duplicateBtn);
                (0, _bb.BB).makeUnfocusable(this.mergeBtn);
                (0, _bb.BB).makeUnfocusable(this.removeBtn);
                (0, _bb.BB).makeUnfocusable(renameBtn);
                this.addBtn.style.cssFloat = "left";
                this.duplicateBtn.style.cssFloat = "left";
                this.mergeBtn.style.cssFloat = "left";
                this.removeBtn.style.cssFloat = "left";
                renameBtn.style.cssFloat = "left";
                this.addBtn.title = (0, _language.LANG)("layers-new");
                this.duplicateBtn.title = (0, _language.LANG)("layers-duplicate");
                this.removeBtn.title = (0, _language.LANG)("layers-remove");
                this.mergeBtn.title = (0, _language.LANG)("layers-merge");
                renameBtn.title = (0, _language.LANG)("layers-rename-title");
                this.addBtn.style.paddingLeft = "5px";
                this.addBtn.style.paddingRight = "3px";
                this.removeBtn.style.paddingLeft = "5px";
                this.removeBtn.style.paddingRight = "3px";
                this.duplicateBtn.style.paddingLeft = "5px";
                this.duplicateBtn.style.paddingRight = "3px";
                this.mergeBtn.style.paddingLeft = "5px";
                this.mergeBtn.style.paddingRight = "3px";
                renameBtn.style.height = "30px";
                renameBtn.style.lineHeight = "20px";
                this.addBtn.innerHTML = "<img src='" + (0, _addLayerSvgDefault.default) + "' height='20'/>";
                this.duplicateBtn.innerHTML = "<img src='" + (0, _duplicateLayerSvgDefault.default) + "' height='20'/>";
                this.mergeBtn.innerHTML = "<img src='" + (0, _mergeLayersSvgDefault.default) + "' height='20'/>";
                this.removeBtn.innerHTML = "<img src='" + (0, _removeLayerSvgDefault.default) + "' height='20'/>";
                renameBtn.innerHTML = "<img src='" + (0, _renameLayerSvgDefault.default) + "' height='20'/>";
                div.append((0, _c.c)(",flex,gap-5,mb-10", [
                    this.addBtn,
                    this.removeBtn,
                    this.duplicateBtn,
                    this.mergeBtn,
                    renameBtn,
                    (0, _c.c)(",grow-1"),
                    this.moreDropdown.getElement()
                ]));
                this.addBtn.onclick = ()=>{
                    if (this.klCanvas.addLayer(this.selectedSpotIndex) === false) return;
                    this.klCanvasLayerArr = this.klCanvas.getLayers();
                    this.selectedSpotIndex = this.selectedSpotIndex + 1;
                    this.createLayerList();
                    (0, _klHistory.klHistory).pause(true);
                    this.onSelect(this.selectedSpotIndex);
                    (0, _klHistory.klHistory).pause(false);
                    this.updateButtons();
                };
                this.duplicateBtn.onclick = ()=>{
                    if (this.klCanvas.duplicateLayer(this.selectedSpotIndex) === false) return;
                    this.klCanvasLayerArr = this.klCanvas.getLayers();
                    this.selectedSpotIndex++;
                    this.createLayerList();
                    (0, _klHistory.klHistory).pause(true);
                    this.onSelect(this.selectedSpotIndex);
                    (0, _klHistory.klHistory).pause(false);
                    this.updateButtons();
                };
                this.removeBtn.onclick = ()=>{
                    if (this.layerElArr.length <= 1) return;
                    this.klCanvas.removeLayer(this.selectedSpotIndex);
                    if (this.selectedSpotIndex > 0) this.selectedSpotIndex--;
                    this.klCanvasLayerArr = this.klCanvas.getLayers();
                    this.createLayerList();
                    (0, _klHistory.klHistory).pause(true);
                    this.onSelect(this.selectedSpotIndex);
                    (0, _klHistory.klHistory).pause(false);
                    this.updateButtons();
                };
                this.mergeBtn.onclick = ()=>{
                    if (this.selectedSpotIndex <= 0) return;
                    (0, _mergeLayerDialog.mergeLayerDialog)(this.parentEl, {
                        topCanvas: this.klCanvasLayerArr[this.selectedSpotIndex].context.canvas,
                        bottomCanvas: this.klCanvasLayerArr[this.selectedSpotIndex - 1].context.canvas,
                        topOpacity: this.klCanvas.getLayer(this.selectedSpotIndex).opacity,
                        mixModeStr: this.klCanvasLayerArr[this.selectedSpotIndex].mixModeStr,
                        callback: (mode)=>{
                            this.klCanvas.mergeLayers(this.selectedSpotIndex, this.selectedSpotIndex - 1, mode);
                            this.klCanvasLayerArr = this.klCanvas.getLayers();
                            this.selectedSpotIndex--;
                            this.createLayerList();
                            (0, _klHistory.klHistory).pause(true);
                            this.onSelect(this.selectedSpotIndex);
                            (0, _klHistory.klHistory).pause(false);
                            this.updateButtons();
                        }
                    });
                };
                renameBtn.onclick = ()=>{
                    this.renameLayer(this.selectedSpotIndex);
                };
            };
            setTimeout(async, 1);
            return div;
        };
        this.rootEl.append(createButtons());
        let modeWrapper;
        modeWrapper = (0, _bb.BB).el({
            content: (0, _language.LANG)("layers-blending") + "&nbsp;",
            css: {
                fontSize: "15px"
            }
        });
        this.modeSelect = new (0, _select.Select)({
            optionArr: [
                "source-over",
                undefined,
                "darken",
                "multiply",
                "color-burn",
                undefined,
                "lighten",
                "screen",
                "color-dodge",
                undefined,
                "overlay",
                "soft-light",
                "hard-light",
                undefined,
                "difference",
                "exclusion",
                undefined,
                "hue",
                "saturation",
                "color",
                "luminosity"
            ].map((item)=>{
                return item ? [
                    item,
                    (0, _translateBlending.translateBlending)(item)
                ] : undefined;
            }),
            onChange: (val)=>{
                this.klCanvas.setMixMode(this.selectedSpotIndex, val);
                this.update(this.selectedSpotIndex);
            },
            css: {
                marginBottom: "10px"
            }
        });
        modeWrapper.append(this.modeSelect.getElement());
        this.rootEl.append(modeWrapper);
        this.rootEl.append(listDiv);
        //updating the thumbs in interval
        //don't update when: manager not visible || layer didn't change || is drawing
        setInterval(()=>{
            if (this.rootEl.style.display !== "block") return;
            const historyState = (0, _klHistory.klHistory).getState();
            if (historyState === this.oldHistoryState) return;
            this.oldHistoryState = historyState;
            for(let i = 0; i < this.layerElArr.length; i++)if (this.selectedSpotIndex === this.layerElArr[i].spot && this.klCanvasLayerArr[this.layerElArr[i].spot]) {
                const ctx = (0, _bb.BB).ctx(this.layerElArr[i].thumb);
                ctx.save();
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                if (this.klCanvasLayerArr[this.layerElArr[i].spot].context.canvas.width < this.layerElArr[i].thumb.width) ctx.imageSmoothingEnabled = false;
                ctx.drawImage(this.klCanvasLayerArr[this.layerElArr[i].spot].context.canvas, 0, 0, this.layerElArr[i].thumb.width, this.layerElArr[i].thumb.height);
                ctx.restore();
            }
        }, 1);
        (0, _theme.theme).addIsDarkListener(()=>{
            this.createLayerList();
        });
        this.createLayerList();
    }
    // ---- interface ----
    update(activeLayerSpotIndex) {
        this.klCanvasLayerArr = this.klCanvas.getLayers();
        if (activeLayerSpotIndex || activeLayerSpotIndex === 0) this.selectedSpotIndex = activeLayerSpotIndex;
        this.updateButtons();
        setTimeout(()=>this.createLayerList(), 1);
    }
    getSelected() {
        return this.selectedSpotIndex;
    }
    activateLayer(spotIndex) {
        if (spotIndex < 0 || spotIndex > this.layerElArr.length - 1) throw "invalid spotIndex " + spotIndex + ", layerElArr.length " + this.layerElArr.length;
        this.selectedSpotIndex = spotIndex;
        this.modeSelect.setValue(this.klCanvasLayerArr[this.selectedSpotIndex].mixModeStr);
        for(let i = 0; i < this.layerElArr.length; i++){
            const layer = this.layerElArr[i];
            const isSelected = this.selectedSpotIndex === layer.spot;
            (0, _bb.BB).css(layer, {
                boxShadow: ""
            });
            layer.classList.toggle("kl-layer--selected", isSelected);
            layer.opacitySlider.setActive(isSelected);
            layer.isSelected = isSelected;
        }
        this.mergeBtn.disabled = this.selectedSpotIndex === 0;
    }
    setUiState(stateStr) {
        this.uiState = stateStr;
        if (this.uiState === "left") (0, _bb.BB).css(this.largeThumbDiv, {
            left: "280px",
            right: ""
        });
        else (0, _bb.BB).css(this.largeThumbDiv, {
            left: "",
            right: "280px"
        });
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../../bb/bb":"dcQKo","../../../history/kl-history":"klzEn","../../components/select":"jmugN","../../components/point-slider":"3j9Hm","../../../canvas/kl-canvas":"l78MY","../../../../language/language":"iiYGN","../../../canvas/translate-blending":"6hHQR","./rename-layer-dialog":"3gjCf","./merge-layer-dialog":"9Py2f","../../../../theme/theme":"4G3JB","../../../../bb/base/base":"k6nNY","../../../../bb/base/browser":"jZRZU","../../../../bb/base/c":"eg9k9","../../components/dropdown-menu":"27IEf","/src/app/img/ui/add-layer.svg":"dRtih","/src/app/img/ui/duplicate-layer.svg":"1jmou","/src/app/img/ui/merge-layers.svg":"6z8Dr","/src/app/img/ui/remove-layer.svg":"bxKFW","/src/app/img/ui/rename-layer.svg":"3N21W","/src/app/img/ui/caret-down.svg":"E9FPv","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l78MY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "MAX_LAYERS", ()=>MAX_LAYERS);
/**
 * The image/canvas that the user paints on
 * Has layers. layers have names and opacity.
 *
 * Interacts with the history you specify (for undo/redo)
 */ parcelHelpers.export(exports, "KlCanvas", ()=>KlCanvas);
var _bb = require("../../bb/bb");
var _floodFill = require("../image-operations/flood-fill");
var _shapeTool = require("../image-operations/shape-tool");
var _renderText = require("../image-operations/render-text");
var _klHistory = require("../history/kl-history");
var _drawProject = require("./draw-project");
var _language = require("../../language/language");
var _gradientTool = require("../image-operations/gradient-tool");
var _base = require("../../bb/base/base");
// TODO remove in 2026
// workaround for chrome bug https://bugs.chromium.org/p/chromium/issues/detail?id=1281185
// reported 2021-13 (v96), fixed 2022-02 (v99)
// affects: source-in, source-out, destination-in, destination-atop
function workaroundForChromium1281185(ctx) {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,0.01)";
    ctx.fillRect(-0.9999999, -0.9999999, 1, 1);
    ctx.restore();
}
const allowedMixModes = [
    "source-over",
    "darken",
    "multiply",
    "color-burn",
    "lighten",
    "screen",
    "color-dodge",
    "overlay",
    "soft-light",
    "hard-light",
    "difference",
    "exclusion",
    "hue",
    "saturation",
    "color",
    "luminosity"
];
const MAX_LAYERS = 16;
class KlCanvas {
    init(w, h) {
        if (!w || !h || isNaN(w) || isNaN(h) || w < 1 || h < 1) throw new Error("init - invalid canvas size: " + w + ", " + h);
        this.width = w;
        this.height = h;
    }
    emitChange() {
        // some changes don't get captured by the history - e.g. changing opacity as the user drags the slider
        this.changeListenerArr.forEach((item)=>item());
    }
    updateIndices() {
        this.layerCanvasArr.forEach((item, index)=>{
            item.index = index;
        });
    }
    // ---- public ----
    constructor(params, layerNrOffset = 0){
        this.layerNrOffset = layerNrOffset;
        this.isDestroyed = false;
        this.layerCanvasArr = [];
        this.pickCanvas = (0, _bb.BB).canvas(1, 1);
        this.history = new (0, _klHistory.DecoyKlHistory)();
        if ("copy" in params) {
            this.width = 1;
            this.height = 1;
        } else if ("width" in params && "height" in params) {
            this.width = params.width;
            this.height = params.height;
        } else {
            this.width = 1;
            this.height = 1;
        }
        this.init(this.width, this.height);
        this.changeListenerArr = [];
        if ("copy" in params) try {
            this.copy(params.copy);
        } catch (e) {
            this.destroy();
            throw e;
        }
        else if ("projectObj" in params) {
            const inLayers = [
                ...params.projectObj.layers
            ];
            this.init(params.projectObj.width, params.projectObj.height);
            if (!inLayers.length) throw new Error("project.layers needs at least 1 layer");
            for(let i = 0; i < inLayers.length; i++){
                const mixModeStr = inLayers[i].mixModeStr;
                if (mixModeStr && !allowedMixModes.includes(mixModeStr)) throw new Error("unknown mixModeStr " + inLayers[i].mixModeStr);
                this.addLayer();
                this.layerOpacity(i, inLayers[i].opacity);
                this.layerCanvasArr[i].name = inLayers[i].name;
                this.layerCanvasArr[i].isVisible = inLayers[i].isVisible;
                this.layerCanvasArr[i].mixModeStr = mixModeStr || "source-over";
                (0, _bb.BB).ctx(this.layerCanvasArr[i]).drawImage(inLayers[i].image, 0, 0);
            }
        }
        this.updateIndices();
    }
    setHistory(h) {
        this.history = h;
    }
    /**
     * Resets canvas -> 1 layer, 100% opacity,
     * unless layers provided.
     * @param p
     */ reset(p) {
        if (!p.width || !p.height || p.width < 1 || p.height < 1 || isNaN(p.width) || isNaN(p.height)) throw new Error("invalid canvas size");
        this.history.pause(true);
        this.width = p.width;
        this.height = p.height;
        this.layerCanvasArr.splice(1, Math.max(0, this.layerCanvasArr.length - 1));
        if (p.layers) for(let i = 0; i < p.layers.length; i++){
            const item = p.layers[i];
            if (!this.layerCanvasArr[i]) this.addLayer();
            this.layerCanvasArr[i].name = item.name;
            this.layerCanvasArr[i].isVisible = item.isVisible;
            this.layerCanvasArr[i].width = this.width;
            this.layerCanvasArr[i].height = this.height;
            this.layerCanvasArr[i].mixModeStr = item.mixModeStr ? item.mixModeStr : "source-over";
            (0, _bb.BB).ctx(this.layerCanvasArr[i]).drawImage(item.image, 0, 0);
            this.layerOpacity(i, item.opacity);
        }
        else {
            this.layerCanvasArr[0].name = p.layerName ? p.layerName : (0, _language.LANG)("layers-layer") + " 1";
            this.layerCanvasArr[0].isVisible = true;
            this.layerCanvasArr[0].width = this.width;
            this.layerCanvasArr[0].height = this.height;
            this.layerCanvasArr[0].mixModeStr = "source-over";
            this.layerOpacity(0, 1);
            if (p.color) this.layerFill(0, p.color);
            else if (p.image) (0, _bb.BB).ctx(this.layerCanvasArr[0]).drawImage(p.image, 0, 0);
        }
        this.updateIndices();
        this.history.pause(false);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "reset",
            params: [
                p
            ]
        });
        return this.layerCanvasArr.length - 1;
    }
    isLayerLimitReached() {
        return this.layerCanvasArr.length >= MAX_LAYERS;
    }
    getWidth() {
        return this.width;
    }
    getHeight() {
        return this.height;
    }
    copy(toCopyCanvas) {
        if (toCopyCanvas.getWidth() < 1 || toCopyCanvas.getHeight() < 1 || isNaN(toCopyCanvas.getWidth()) || isNaN(toCopyCanvas.getHeight())) throw new Error("invalid canvas size");
        // keep existing canvases
        const origLayers = toCopyCanvas.getLayers();
        while(this.layerCanvasArr.length > origLayers.length)this.removeLayer(this.layerCanvasArr.length - 1);
        if (toCopyCanvas.getWidth() != this.width || toCopyCanvas.getHeight() != this.height) this.init(toCopyCanvas.getWidth(), toCopyCanvas.getHeight());
        for(let i = 0; i < origLayers.length; i++){
            if (i >= this.layerCanvasArr.length) this.addLayer();
            else {
                this.layerCanvasArr[i].width = this.width;
                this.layerCanvasArr[i].height = this.height;
            }
            this.layerOpacity(i, origLayers[i].opacity);
            this.layerCanvasArr[i].name = origLayers[i].name;
            this.layerCanvasArr[i].isVisible = origLayers[i].isVisible;
            this.layerCanvasArr[i].mixModeStr = origLayers[i].mixModeStr;
            (0, _bb.BB).ctx(this.layerCanvasArr[i]).drawImage(origLayers[i].context.canvas, 0, 0);
        }
        this.updateIndices();
    }
    getLayerCount() {
        return this.layerCanvasArr.length;
    }
    resize(w, h, algorithm = "smooth") {
        if (!w || !h || w === this.width && h === this.height || isNaN(w) || isNaN(h) || w < 1 || h < 1) return false;
        w = Math.max(w, 1);
        h = Math.max(h, 1);
        let tmp1, tmp2;
        if (algorithm === "pixelated") {
            tmp1 = (0, _bb.BB).canvas(w, h);
            const tmp1Ctx = (0, _bb.BB).ctx(tmp1);
            tmp1Ctx.imageSmoothingEnabled = false;
            for(let i = 0; i < this.layerCanvasArr.length; i++){
                if (i > 0) tmp1Ctx.clearRect(0, 0, w, h);
                const layerCanvas = this.layerCanvasArr[i];
                tmp1Ctx.drawImage(layerCanvas, 0, 0, w, h);
                layerCanvas.width = w;
                layerCanvas.height = h;
                const layerContext = (0, _bb.BB).ctx(layerCanvas);
                layerContext.drawImage(tmp1, 0, 0);
            }
        } else if (algorithm === "smooth") {
            tmp1 = (0, _bb.BB).canvas();
            tmp2 = (0, _bb.BB).canvas();
            for(let i = 0; i < this.layerCanvasArr.length; i++)(0, _bb.BB).resizeCanvas(this.layerCanvasArr[i], w, h, tmp1, tmp2);
        } else throw new Error("unknown resize algorithm");
        this.width = w;
        this.height = h;
        return true;
    }
    /**
     * crop / extend
     * @param p
     */ resizeCanvas(p) {
        const newW = Math.round(p.left) + this.width + Math.round(p.right);
        const newH = Math.round(p.top) + this.height + Math.round(p.bottom);
        const offX = Math.round(p.left);
        const offY = Math.round(p.top);
        if (isNaN(newW) || isNaN(newH) || newW < 1 || newH < 1) throw new Error("KlCanvas.resizeCanvas - invalid canvas size");
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            const ctemp = (0, _bb.BB).canvas(this.width, this.height);
            const layerCanvas = this.layerCanvasArr[i];
            const layerCtx = (0, _bb.BB).ctx(this.layerCanvasArr[i]);
            (0, _bb.BB).ctx(ctemp).drawImage(layerCanvas, 0, 0);
            this.layerCanvasArr[i].width = newW;
            this.layerCanvasArr[i].height = newH;
            layerCtx.save();
            if (i === 0 && p.fillColor) {
                layerCtx.fillStyle = (0, _bb.BB).ColorConverter.toRgbStr(p.fillColor);
                layerCtx.fillRect(0, 0, newW, newH);
                layerCtx.clearRect(offX, offY, this.width, this.height);
            }
            layerCtx.drawImage(ctemp, offX, offY);
            layerCtx.restore();
        }
        this.width = newW;
        this.height = newH;
    }
    /**
     * will be inserted on top of selected
     * @param selected
     */ addLayer(selected) {
        if (this.isLayerLimitReached()) return false;
        const canvas = (0, _bb.BB).canvas(this.width, this.height);
        if (!canvas.getContext("2d")) throw new Error("kl-create-canvas-error");
        canvas.isVisible = true;
        canvas.mixModeStr = "source-over";
        if (selected === undefined) {
            this.layerCanvasArr[this.layerCanvasArr.length] = canvas;
            selected = Math.max(0, this.layerCanvasArr.length - 1);
        } else {
            this.layerCanvasArr.splice(selected + 1, 0, canvas);
            selected++;
        }
        canvas.name = (0, _language.LANG)("layers-layer") + " " + (this.layerCanvasArr.length + this.layerNrOffset);
        this.history.pause(true);
        this.layerOpacity(selected, 1);
        this.history.pause(false);
        this.updateIndices();
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "addLayer",
            params: [
                selected - 1
            ]
        });
        return selected;
    }
    duplicateLayer(i) {
        if (!this.layerCanvasArr[i] || this.isLayerLimitReached()) return false;
        const canvas = (0, _bb.BB).canvas(this.width, this.height);
        this.layerCanvasArr.splice(i + 1, 0, canvas);
        canvas.name = this.layerCanvasArr[i].name + " " + (0, _language.LANG)("layers-copy");
        canvas.isVisible = this.layerCanvasArr[i].isVisible;
        canvas.mixModeStr = this.layerCanvasArr[i].mixModeStr;
        // 2023-04-30 workaround for https://bugs.webkit.org/show_bug.cgi?id=256151
        // todo replace with simple drawImage eventually when fixed
        (0, _bb.BB).ctx(canvas).putImageData((0, _bb.BB).ctx(this.layerCanvasArr[i]).getImageData(0, 0, this.width, this.height), 0, 0);
        this.history.pause(true);
        this.layerOpacity(i + 1, this.layerCanvasArr[i].opacity);
        this.history.pause(false);
        this.updateIndices();
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "duplicateLayer",
            params: [
                i
            ]
        });
        return i + 1;
    }
    getLayerContext(i, doReturnNull) {
        if (this.layerCanvasArr[i]) return (0, _bb.BB).ctx(this.layerCanvasArr[i]);
        if (doReturnNull) return null;
        throw new Error("layer of index " + i + " not found (in " + this.layerCanvasArr.length + " layers)");
    }
    removeLayer(i) {
        if (this.layerCanvasArr[i]) {
            this.layerCanvasArr.splice(i, 1);
            this.updateIndices();
        } else return false;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "removeLayer",
            params: [
                i
            ]
        });
        return Math.max(0, i - 1);
    }
    renameLayer(i, name) {
        if (this.layerCanvasArr[i]) this.layerCanvasArr[i].name = name;
        else return false;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "renameLayer",
            params: [
                i,
                name
            ]
        });
        return true;
    }
    layerOpacity(layerIndex, opacity) {
        if (!this.layerCanvasArr[layerIndex]) return;
        opacity = Math.max(0, Math.min(1, opacity));
        this.layerCanvasArr[layerIndex].opacity = opacity;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "layerOpacity",
            params: [
                layerIndex,
                opacity
            ]
        });
        this.emitChange();
    }
    setLayerIsVisible(layerIndex, isVisible) {
        if (this.layerCanvasArr[layerIndex]) this.layerCanvasArr[layerIndex].isVisible = isVisible;
        else throw new Error(`layer ${layerIndex} undefined`);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "setLayerIsVisible",
            params: [
                layerIndex,
                isVisible
            ]
        });
    }
    moveLayer(i, d) {
        if (d === 0) return;
        if (this.layerCanvasArr[i]) {
            const temp = this.layerCanvasArr[i];
            this.layerCanvasArr.splice(i, 1);
            const targetIndex = Math.max(0, Math.min(i + d, this.layerCanvasArr.length));
            this.layerCanvasArr.splice(targetIndex, 0, temp);
            this.updateIndices();
            this.history.push({
                tool: [
                    "canvas"
                ],
                action: "moveLayer",
                params: [
                    i,
                    d
                ]
            });
            return targetIndex;
        }
    }
    mergeLayers(layerBottomIndex, layerTopIndex, mixModeStr) {
        if (!this.layerCanvasArr[layerBottomIndex] || !this.layerCanvasArr[layerTopIndex] || layerBottomIndex === layerTopIndex) return;
        //order messed up
        if (layerBottomIndex > layerTopIndex) {
            const temp = layerBottomIndex;
            layerBottomIndex = layerTopIndex;
            layerTopIndex = temp;
        }
        const topOpacity = this.layerCanvasArr[layerTopIndex].opacity;
        if (topOpacity !== 0 && topOpacity) {
            const ctx = (0, _bb.BB).ctx(this.layerCanvasArr[layerBottomIndex]);
            ctx.save();
            if (mixModeStr === "as-alpha") {
                (0, _bb.BB).convertToAlphaChannelCanvas(this.layerCanvasArr[layerTopIndex]);
                ctx.globalCompositeOperation = "destination-in";
                ctx.globalAlpha = topOpacity;
                (0, _bb.BB).ctx(this.layerCanvasArr[layerBottomIndex]).drawImage(this.layerCanvasArr[layerTopIndex], 0, 0);
            } else {
                if (mixModeStr) ctx.globalCompositeOperation = mixModeStr;
                ctx.globalAlpha = topOpacity;
                (0, _bb.BB).ctx(this.layerCanvasArr[layerBottomIndex]).drawImage(this.layerCanvasArr[layerTopIndex], 0, 0);
            }
            ctx.restore();
            mixModeStr && workaroundForChromium1281185(ctx);
        }
        this.updateIndices();
        this.history.pause(true);
        this.removeLayer(layerTopIndex);
        this.history.pause(false);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "mergeLayers",
            params: [
                layerBottomIndex,
                layerTopIndex,
                mixModeStr
            ]
        });
        return layerBottomIndex;
    }
    mergeAll() {
        if (this.layerCanvasArr.length === 1) return false;
        // draw all on bottom layer
        const ctx = (0, _bb.BB).ctx(this.layerCanvasArr[0]);
        for(let i = 1; i < this.layerCanvasArr.length; i++){
            const current = this.layerCanvasArr[i];
            if (!current.isVisible || current.opacity === 0) continue;
            ctx.save();
            ctx.globalCompositeOperation = current.mixModeStr;
            ctx.globalAlpha = current.opacity;
            ctx.drawImage(current, 0, 0);
            ctx.restore();
        }
        this.history.pause(true);
        // remove upper layers
        for(let i = this.layerCanvasArr.length - 1; i > 0; i--)this.removeLayer(i);
        // rename first layer to "layer 1"
        this.renameLayer(0, (0, _language.LANG)("layers-layer") + " 1");
        this.history.pause(false);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "mergeAll",
            params: []
        });
        return 0;
    }
    rotate(deg) {
        while(deg < 0)deg += 360;
        deg %= 360;
        if (deg % 90 != 0 || deg === 0) return;
        const temp = (0, _bb.BB).canvas();
        if (deg === 0 || deg === 180) {
            temp.width = this.width;
            temp.height = this.height;
        } else if (deg === 90 || deg === 270) {
            temp.width = this.height;
            temp.height = this.width;
        }
        const ctx = (0, _bb.BB).ctx(temp);
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            ctx.clearRect(0, 0, temp.width, temp.height);
            ctx.save();
            ctx.translate(temp.width / 2, temp.height / 2);
            ctx.rotate(deg * Math.PI / 180);
            if (deg === 180) ctx.drawImage(this.layerCanvasArr[i], -temp.width / 2, -temp.height / 2);
            else if (deg === 90 || deg === 270) ctx.drawImage(this.layerCanvasArr[i], -temp.height / 2, -temp.width / 2);
            this.layerCanvasArr[i].width = temp.width;
            this.layerCanvasArr[i].height = temp.height;
            (0, _bb.BB).ctx(this.layerCanvasArr[i]).clearRect(0, 0, this.layerCanvasArr[i].width, this.layerCanvasArr[i].height);
            (0, _bb.BB).ctx(this.layerCanvasArr[i]).drawImage(temp, 0, 0);
            ctx.restore();
        }
        this.width = temp.width;
        this.height = temp.height;
    }
    flip(isHorizontal, isVertical, layerIndex) {
        if (!isHorizontal && !isVertical) return;
        const temp = (0, _bb.BB).canvas(this.width, this.height);
        temp.width = this.width;
        temp.height = this.height;
        const tempCtx = (0, _bb.BB).ctx(temp);
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            if ((layerIndex || layerIndex === 0) && i !== layerIndex) continue;
            tempCtx.save();
            tempCtx.clearRect(0, 0, temp.width, temp.height);
            tempCtx.translate(temp.width / 2, temp.height / 2);
            tempCtx.scale(isHorizontal ? -1 : 1, isVertical ? -1 : 1);
            tempCtx.drawImage(this.layerCanvasArr[i], -temp.width / 2, -temp.height / 2);
            tempCtx.restore();
            (0, _bb.BB).ctx(this.layerCanvasArr[i]).clearRect(0, 0, this.layerCanvasArr[i].width, this.layerCanvasArr[i].height);
            (0, _bb.BB).ctx(this.layerCanvasArr[i]).drawImage(temp, 0, 0);
        }
    }
    layerFill(layerIndex, colorObj, compositeOperation) {
        const ctx = (0, _bb.BB).ctx(this.layerCanvasArr[layerIndex]);
        ctx.save();
        if (compositeOperation) ctx.globalCompositeOperation = compositeOperation;
        ctx.fillStyle = "rgba(" + colorObj.r + "," + colorObj.g + "," + colorObj.b + ",1)";
        ctx.fillRect(0, 0, this.layerCanvasArr[layerIndex].width, this.layerCanvasArr[layerIndex].height);
        ctx.restore();
        // workaround for chrome bug https://bugs.chromium.org/p/chromium/issues/detail?id=1281185
        // TODO remove if chrome updated
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,0.01)";
        ctx.fillRect(-0.9999999, -0.9999999, 1, 1);
        ctx.restore();
        /*if (!document.getElementById('testocanvas')) {
            layerCanvasArr[layerIndex].id = 'testocanvas';
            document.body.append(layerCanvasArr[layerIndex]);
            BB.css(layerCanvasArr[layerIndex], {
                position: 'fixed',
                left: '0',
                top: '0',
                zIndex: '1111111',
                transform: 'scale(0.2)',
                border: '10px solid red',
            });
        }
        if (!document.getElementById('testocanvas')) {
            let c = document.createElement('canvas');
            c.width = 1000;
            c.height = 1000;
            let ctx2 = c.getContext('2d');
            ctx2.drawImage(layerCanvasArr[layerIndex], 0, 0);
            c.id = 'testocanvas';
            document.body.append(c);
            BB.css(c, {
                position: 'fixed',
                left: '0',
                top: '0',
                zIndex: '1111111',
                transform: 'scale(0.2)',
                border: '10px solid red',
            });
        }*/ this.history.push({
            tool: [
                "canvas"
            ],
            action: "layerFill",
            params: [
                layerIndex,
                colorObj,
                compositeOperation
            ]
        });
    }
    floodFill(layerIndex, x, y, rgb, opacity, tolerance, sampleStr, grow, isContiguous) {
        if (x < 0 || y < 0 || x >= this.width || y >= this.height || opacity === 0) return;
        tolerance = Math.round(tolerance);
        if (![
            "above",
            "current",
            "all"
        ].includes(sampleStr)) throw new Error("invalid sampleStr");
        let result;
        let targetCtx;
        let targetImageData;
        if (sampleStr === "all") {
            const srcCanvas = this.layerCanvasArr.length === 1 ? this.layerCanvasArr[0] : this.getCompleteCanvas(1);
            const srcCtx = (0, _bb.BB).ctx(srcCanvas);
            const srcImageData = srcCtx.getImageData(0, 0, this.width, this.height);
            const srcData = srcImageData.data;
            result = (0, _floodFill.floodFillBits)(srcData, this.width, this.height, x, y, tolerance, Math.round(grow), isContiguous);
            targetCtx = (0, _bb.BB).ctx(this.layerCanvasArr[layerIndex]);
            targetImageData = targetCtx.getImageData(0, 0, this.width, this.height);
        } else {
            const srcIndex = sampleStr === "above" ? layerIndex + 1 : layerIndex;
            if (srcIndex >= this.layerCanvasArr.length) return;
            const srcCtx = (0, _bb.BB).ctx(this.layerCanvasArr[srcIndex]);
            const srcImageData = srcCtx.getImageData(0, 0, this.width, this.height);
            const srcData = srcImageData.data;
            result = (0, _floodFill.floodFillBits)(srcData, this.width, this.height, x, y, tolerance, Math.round(grow), isContiguous);
            targetCtx = layerIndex === srcIndex ? srcCtx : (0, _bb.BB).ctx(this.layerCanvasArr[layerIndex]);
            targetImageData = layerIndex === srcIndex ? srcImageData : targetCtx.getImageData(0, 0, this.width, this.height);
        }
        const targetData = targetImageData.data;
        if (rgb) {
            if (opacity === 1) {
                for(let i = 0; i < this.width * this.height; i++)if (result.data[i] === 255) {
                    targetData[i * 4] = rgb.r;
                    targetData[i * 4 + 1] = rgb.g;
                    targetData[i * 4 + 2] = rgb.b;
                    targetData[i * 4 + 3] = 255;
                }
            } else {
                for(let i = 0; i < this.width * this.height; i++)if (result.data[i] === 255) {
                    targetData[i * 4] = (0, _bb.BB).mix(targetData[i * 4], rgb.r, opacity);
                    targetData[i * 4 + 1] = (0, _bb.BB).mix(targetData[i * 4 + 1], rgb.g, opacity);
                    targetData[i * 4 + 2] = (0, _bb.BB).mix(targetData[i * 4 + 2], rgb.b, opacity);
                    targetData[i * 4 + 3] = (0, _bb.BB).mix(targetData[i * 4 + 3], 255, opacity);
                }
            }
        } else if (opacity === 1) {
            for(let i = 0; i < this.width * this.height; i++)if (result.data[i] === 255) targetData[i * 4 + 3] = 0;
        } else {
            for(let i = 0; i < this.width * this.height; i++)if (result.data[i] === 255) targetData[i * 4 + 3] = (0, _bb.BB).mix(targetData[i * 4 + 3], 0, opacity);
        }
        targetCtx.putImageData(targetImageData, 0, 0);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "replaceLayer",
            params: [
                layerIndex,
                targetImageData
            ]
        });
    }
    /**
     * draw shape via BB.drawShape
     * @param layerIndex
     * @param shapeObj
     */ drawShape(layerIndex, shapeObj) {
        if (shapeObj.x1 === shapeObj.x2 && shapeObj.y1 === shapeObj.y2) return;
        (0, _shapeTool.drawShape)((0, _bb.BB).ctx(this.layerCanvasArr[layerIndex]), shapeObj);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "drawShape",
            params: [
                layerIndex,
                (0, _bb.BB).copyObj(shapeObj)
            ]
        });
    }
    drawGradient(layerIndex, gradientObj) {
        (0, _gradientTool.drawGradient)((0, _bb.BB).ctx(this.layerCanvasArr[layerIndex]), gradientObj);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "drawGradient",
            params: [
                layerIndex,
                (0, _bb.BB).copyObj(gradientObj)
            ]
        });
    }
    text(layerIndex, p) {
        (0, _renderText.renderText)(this.layerCanvasArr[layerIndex], (0, _bb.BB).copyObj(p));
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "text",
            params: [
                layerIndex,
                (0, _bb.BB).copyObj(p)
            ]
        });
    }
    replaceLayer(layerIndex, imageData) {
        const ctx = (0, _bb.BB).ctx(this.layerCanvasArr[layerIndex]);
        ctx.putImageData(imageData, 0, 0);
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "replaceLayer",
            params: [
                layerIndex,
                imageData
            ]
        });
    }
    clearLayer(layerIndex) {
        const ctx = (0, _bb.BB).ctx(this.layerCanvasArr[layerIndex]);
        ctx.save();
        ctx.clearRect(0, 0, this.layerCanvasArr[layerIndex].width, this.layerCanvasArr[layerIndex].height);
        ctx.restore();
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "clearLayer",
            params: [
                layerIndex
            ]
        });
    }
    getLayers() {
        return this.layerCanvasArr.map((item)=>{
            return {
                context: (0, _bb.BB).ctx(item),
                isVisible: item.isVisible,
                opacity: item.opacity,
                name: item.name,
                mixModeStr: item.mixModeStr
            };
        });
    }
    getLayersFast() {
        return this.layerCanvasArr.map((item)=>{
            return {
                canvas: item,
                isVisible: item.isVisible,
                opacity: item.opacity,
                name: item.name,
                mixModeStr: item.mixModeStr
            };
        });
    }
    getLayerIndex(canvasObj, doReturnNull) {
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            if (this.layerCanvasArr[i] === canvasObj) return i;
        }
        if (!doReturnNull) throw new Error("layer not found (in " + this.layerCanvasArr.length + " layers)");
        return null;
    }
    getLayer(index, doReturnNull) {
        if (this.layerCanvasArr[index]) return {
            context: (0, _bb.BB).ctx(this.layerCanvasArr[index]),
            isVisible: this.layerCanvasArr[index].isVisible,
            opacity: this.layerCanvasArr[index].opacity,
            name: this.layerCanvasArr[index].name,
            id: index
        };
        if (!doReturnNull) throw new Error("layer of index " + index + " not found (in " + this.layerCanvasArr.length + " layers)");
        return null;
    }
    getColorAt(x, y) {
        x = Math.floor(x);
        y = Math.floor(y);
        const ctx = (0, _bb.BB).ctx(this.pickCanvas);
        ctx.save();
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, 1, 1);
        for(let i = 0; i < this.layerCanvasArr.length; i++){
            const layer = this.layerCanvasArr[i];
            if (!layer.isVisible || layer.opacity === 0) continue;
            ctx.globalAlpha = layer.opacity;
            ctx.globalCompositeOperation = layer.mixModeStr;
            ctx.drawImage(layer, -x, -y);
        }
        ctx.restore();
        const imData = ctx.getImageData(0, 0, 1, 1);
        return new (0, _bb.BB).RGB(imData.data[0], imData.data[1], imData.data[2]);
    }
    getCompleteCanvas(factor) {
        return (0, _drawProject.drawProject)(this.getProject(), factor);
    }
    getProject() {
        return {
            width: this.width,
            height: this.height,
            layers: this.layerCanvasArr.map((layer)=>{
                return {
                    name: layer.name,
                    isVisible: layer.isVisible,
                    opacity: layer.opacity,
                    mixModeStr: layer.mixModeStr,
                    image: layer
                };
            })
        };
    }
    addChangeListener(func) {
        if (this.changeListenerArr.includes(func)) return;
        this.changeListenerArr.push(func);
    }
    removeChangeListener(func) {
        for(let i = 0; i < this.changeListenerArr.length; i++)if (this.changeListenerArr[i] === func) {
            this.changeListenerArr.splice(i, 1);
            return;
        }
    }
    setMixMode(layerIndex, mixModeStr) {
        if (!this.layerCanvasArr[layerIndex]) throw new Error("invalid layer");
        this.layerCanvasArr[layerIndex].mixModeStr = mixModeStr;
        this.history.push({
            tool: [
                "canvas"
            ],
            action: "setMixMode",
            params: [
                layerIndex,
                "" + mixModeStr
            ]
        });
    }
    /**
     * Set composite drawing step for KlCanvasWorkspace.
     * To apply temporary manipulations to a layer.
     *
     * @param layerIndex
     * @param compositeObj
     */ setComposite(layerIndex, compositeObj) {
        if (!this.layerCanvasArr[layerIndex]) throw new Error("invalid layer");
        this.layerCanvasArr[layerIndex].compositeObj = (0, _base.nullToUndefined)(compositeObj);
    }
    destroy() {
        if (this.isDestroyed) return;
        this.layerCanvasArr.forEach((canvas)=>{
            (0, _bb.BB).freeCanvas(canvas);
        });
        this.layerCanvasArr = [];
        this.isDestroyed = true;
    }
}

},{"../../bb/bb":"dcQKo","../image-operations/flood-fill":"j0xrQ","../image-operations/shape-tool":"90Wty","../image-operations/render-text":"fEvNY","../history/kl-history":"klzEn","./draw-project":"6Yf6D","../../language/language":"iiYGN","../image-operations/gradient-tool":"jhX3B","../../bb/base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"j0xrQ":[function(require,module,exports) {
/**
 * Flood fill. Tried https://github.com/binarymax/floodfill.js/, but it implemented tolerance wrong, and had bugs.
 * So, my own implementation. can handle tolerance, grow, opacity.
 * Needs to be optimized.
 */ /**
 * Set values in data within rect to 254, unless they're 255
 *
 * @param data Uint8Array
 * @param width int
 * @param x0 int
 * @param y0 int
 * @param x1 int >x0
 * @param y1 int >y0
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Does flood fill, and returns that. an array - 0 not filled. 255 filled

 * @param rgbaArr Uint8ClampedArray rgba
 * @param width int
 * @param height int
 * @param x int
 * @param y int
 * @param tolerance int 0 - 255
 * @param grow int >= 0
 * @param isContiguous boolean
 */ parcelHelpers.export(exports, "floodFillBits", ()=>floodFillBits);
function fillRect(data, width, x0, y0, x1, y1) {
    for(let x = x0; x <= x1; x++)for(let y = y0; y <= y1; y++){
        if (data[y * width + x] === 255) continue;
        data[y * width + x] = 254;
    }
}
let mx, my;
/**
 * Get index i moved by dX, dY. in array with dimensions width height.
 * Returns null if outside bounds.
 *
 * @param width int
 * @param height int
 * @param i int
 * @param dX int
 * @param dY int
 */ function moveIndex(width, height, i, dX, dY) {
    mx = i % width + dX;
    my = Math.floor(i / width) + dY;
    if (mx < 0 || my < 0 || mx >= width || my >= height) return undefined;
    return my * width + mx;
}
/**
 * If pixel can be filled (within tolerance) will be set 255 and returns true.
 * returns false if already filled, or i is null
 *
 * @param srcArr Uint8ClampedArray rgba
 * @param targetArr Uint8Array
 * @param width int
 * @param height int
 * @param initRgba rgba
 * @param tolerance int 0 - 255
 * @param i int - srcArr index
 * @returns {boolean}
 */ function testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, i) {
    if (i === undefined || targetArr[i] === 255) return false;
    if (srcArr[i * 4] === initRgba[0] && srcArr[i * 4 + 1] === initRgba[1] && srcArr[i * 4 + 2] === initRgba[2] && srcArr[i * 4 + 3] === initRgba[3]) {
        targetArr[i] = 255;
        return true;
    }
    if (tolerance > 0 && Math.abs(srcArr[i * 4] - initRgba[0]) <= tolerance && Math.abs(srcArr[i * 4 + 1] - initRgba[1]) <= tolerance && Math.abs(srcArr[i * 4 + 2] - initRgba[2]) <= tolerance && Math.abs(srcArr[i * 4 + 3] - initRgba[3]) <= tolerance) {
        targetArr[i] = 255;
        return true;
    }
    return false;
}
/**
 *
 * @param srcArr Uint8ClampedArray rgba
 * @param targetArr Uint8Array
 * @param width int
 * @param height int
 * @param px int
 * @param py int
 * @param tolerance int 0 - 255
 * @param grow int >= 0
 * @param isContiguous boolean
 */ function floodFill(srcArr, targetArr, width, height, px, py, tolerance, grow, isContiguous) {
    const initRgba = [
        srcArr[(py * width + px) * 4],
        srcArr[(py * width + px) * 4 + 1],
        srcArr[(py * width + px) * 4 + 2],
        srcArr[(py * width + px) * 4 + 3]
    ];
    if (isContiguous) {
        const q = [];
        q.push(py * width + px);
        targetArr[py * width + px] = 255;
        let i, e;
        while(q.length){
            i = q.pop(); // a test would slow down the code
            // queue up unfilled neighbors
            e = moveIndex(width, height, i, -1, 0); // left
            // test will return false if e is undefined -> only numbers will be pushed to q
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
            e = moveIndex(width, height, i, 1, 0); // right
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
            e = moveIndex(width, height, i, 0, -1); // up
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
            e = moveIndex(width, height, i, 0, 1); // bottom
            testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, e) && q.push(e);
        }
    } else for(let i = 0; i < width * height; i++)testAndFill(srcArr, targetArr, width, height, initRgba, tolerance, i);
    // grow
    if (grow === 0) return;
    // how does it grow? it finds all pixel at the edge.
    // then depending on what kind of edge it is, it draws a rectangle into target
    // the rectangle has the value 254, or else it will mess it all up.
    // after it's all done, replaces it with 255
    let x0, x1, y0, y1;
    let l, tl, t, tr, r, br, b, bl; // left, top left, top, top right, etc.
    for(let x = 0; x < width; x++)for(let y = 0; y < height; y++){
        if (targetArr[y * width + x] !== 255) continue;
        // bounds of rectangle
        x0 = x;
        x1 = x;
        y0 = y;
        y1 = y;
        l = targetArr[y * width + x - 1] !== 255;
        tl = targetArr[(y - 1) * width + x - 1] !== 255;
        t = targetArr[(y - 1) * width + x] !== 255;
        tr = targetArr[(y - 1) * width + x + 1] !== 255;
        r = targetArr[y * width + x + 1] !== 255;
        br = targetArr[(y + 1) * width + x + 1] !== 255;
        b = targetArr[(y + 1) * width + x] !== 255;
        bl = targetArr[(y + 1) * width + x - 1] !== 255;
        if (l) x0 = x - grow;
        if (l && tl && t) {
            x0 = x - grow;
            y0 = y - grow;
        }
        if (t) y0 = Math.min(y0, y - grow);
        if (t && tr && r) {
            y0 = Math.min(y0, y - grow);
            x1 = x + grow;
        }
        if (r) x1 = Math.max(x1, x + grow);
        if (r && br && b) {
            x1 = Math.max(x1, x + grow);
            y1 = Math.max(y1, y + grow);
        }
        if (b) y1 = Math.max(y1, y + grow);
        if (b && bl && l) {
            x0 = Math.min(x0, x - grow);
            y1 = Math.max(y1, y + grow);
        }
        if (!l && !tl && !t && !tr && !r && !br && !b && !bl) continue;
        fillRect(targetArr, width, Math.max(0, x0), Math.max(0, y0), Math.min(width - 1, x1), Math.min(height - 1, y1));
    }
    for(let i = 0; i < width * height; i++)if (targetArr[i] === 254) targetArr[i] = 255;
}
function floodFillBits(rgbaArr, width, height, x, y, tolerance, grow, isContiguous) {
    x = Math.round(x);
    y = Math.round(y);
    const resultArr = new Uint8Array(new ArrayBuffer(width * height));
    floodFill(rgbaArr, resultArr, width, height, x, y, tolerance, grow, isContiguous);
    return {
        data: resultArr
    };
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"90Wty":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Input processor for shape tool.
 * Coordinates are in canvas space.
 * angleRad is the angle of the canvas.
 */ parcelHelpers.export(exports, "ShapeTool", ()=>ShapeTool);
/**
 * Draw a shape (rectangle, ellipse, line)
 */ parcelHelpers.export(exports, "drawShape", ()=>drawShape);
var _bb = require("../../bb/bb");
class ShapeTool {
    // ---- public ----
    constructor(p){
        this.downX = 0;
        this.downY = 0;
        this.downAngleRad = 0;
        this.onShape = p.onShape;
    }
    onDown(x, y, angleRad) {
        this.downX = x;
        this.downY = y;
        this.downAngleRad = angleRad;
    }
    onMove(x, y) {
        this.onShape(false, this.downX, this.downY, x, y, this.downAngleRad);
    }
    onUp(x, y) {
        this.onShape(true, this.downX, this.downY, x, y, this.downAngleRad);
    }
}
function drawShape(ctx, shapeObj) {
    shapeObj = {
        // defaults
        angleRad: 0,
        isOutwards: false,
        opacity: 1,
        isEraser: false,
        doLockAlpha: false,
        ...(0, _bb.BB).copyObj(shapeObj)
    };
    if ([
        "rect",
        "ellipse",
        "line"
    ].includes(shapeObj.type)) {
        if (shapeObj.angleRad === undefined) throw new Error("angleRad undefined");
        const lineWidth = shapeObj.lineWidth === undefined ? -1 : Math.round(shapeObj.lineWidth);
        const angleDeg = shapeObj.angleRad * 180 / Math.PI;
        // --- prep color ---
        if (!shapeObj.isEraser && shapeObj.fillRgb === undefined && shapeObj.strokeRgb === undefined) throw new Error("fillRgb and strokeRgb undefined");
        const colorRGB = shapeObj.isEraser ? {
            r: 255,
            g: 255,
            b: 255
        } : shapeObj.fillRgb ? shapeObj.fillRgb : shapeObj.strokeRgb;
        // --- prep canvas ---
        ctx.save();
        if (shapeObj.opacity) ctx.globalAlpha = shapeObj.opacity;
        if (shapeObj.isEraser) ctx.globalCompositeOperation = "destination-out";
        if (shapeObj.doLockAlpha) ctx.globalCompositeOperation = "source-atop";
        ctx.rotate(-shapeObj.angleRad);
        if (shapeObj.fillRgb) ctx.fillStyle = (0, _bb.BB).ColorConverter.toRgbStr(colorRGB);
        else if (shapeObj.strokeRgb) {
            ctx.strokeStyle = (0, _bb.BB).ColorConverter.toRgbStr(colorRGB);
            ctx.lineWidth = lineWidth;
        }
        let x1 = shapeObj.x1;
        let y1 = shapeObj.y1;
        let x2 = shapeObj.x2;
        let y2 = shapeObj.y2;
        // --- angle snapping ---
        if (shapeObj.isAngleSnap) {
            const r1 = (0, _bb.BB).rotate(x1, y1, shapeObj.angleRad / Math.PI * 180);
            const r2 = (0, _bb.BB).rotate(x2, y2, shapeObj.angleRad / Math.PI * 180);
            const pAngleDeg = (0, _bb.BB).pointsToAngleDeg(r1, r2) + 90;
            const pAngleDegSnapped = Math.round(pAngleDeg / 45) * 45;
            const rotated = (0, _bb.BB).rotateAround({
                x: x1,
                y: y1
            }, {
                x: x2,
                y: y2
            }, pAngleDegSnapped - pAngleDeg);
            x2 = rotated.x;
            y2 = rotated.y;
            // needs to be perfect if p1->p2 aligns with canvas x- or y-axis
            if ((angleDeg + pAngleDegSnapped) % 90 === 0) {
                if (Math.round((angleDeg - pAngleDegSnapped) / 90) % 2 === 0) x2 = x1;
                else y2 = y1;
            }
        }
        let x = x1;
        let y = y1;
        let dX = x2 - x1;
        let dY = y2 - y1;
        // --- 1:1 ratio ---
        if (shapeObj.type !== "line" && shapeObj.isFixedRatio) {
            let r1 = (0, _bb.BB).rotate(shapeObj.x1, shapeObj.y1, shapeObj.angleRad / Math.PI * 180);
            let r2 = (0, _bb.BB).rotate(shapeObj.x2, shapeObj.y2, shapeObj.angleRad / Math.PI * 180);
            const rx = r1.x;
            const ry = r1.y;
            let rdX = r2.x - r1.x;
            let rdY = r2.y - r1.y;
            if (Math.abs(rdX) < Math.abs(rdY)) rdY = Math.abs(rdX) * (rdY < 0 ? -1 : 1);
            else rdX = Math.abs(rdY) * (rdX < 0 ? -1 : 1);
            r2.x = rx + rdX;
            r2.y = ry + rdY;
            r1 = (0, _bb.BB).rotate(r1.x, r1.y, -shapeObj.angleRad / Math.PI * 180);
            r2 = (0, _bb.BB).rotate(r2.x, r2.y, -shapeObj.angleRad / Math.PI * 180);
            x1 = r1.x;
            y1 = r1.y;
            x2 = r2.x;
            y2 = r2.y;
            x = x1;
            y = y1;
            dX = x2 - x1;
            dY = y2 - y1;
        }
        // outwards modifier
        if (shapeObj.isOutwards) {
            x -= dX;
            y -= dY;
            dX *= 2;
            dY *= 2;
            x1 = x;
            y1 = y;
            x2 = x + dX;
            y2 = y + dY;
        }
        let p1;
        let p2;
        if (shapeObj.type === "line") {
            // rounded
            const x1r = Math.round(x1);
            const y1r = Math.round(y1);
            const x2r = Math.round(x2);
            const y2r = Math.round(y2);
            // floored
            const x1f = Math.floor(x1);
            const y1f = Math.floor(y1);
            const x2f = Math.floor(x2);
            const y2f = Math.floor(y2);
            if (lineWidth % 2 === 0) {
                if (y1r === y2r) {
                    p1 = {
                        x: x1f,
                        y: y1r
                    };
                    p2 = {
                        x: x2f,
                        y: y2r
                    };
                    if (x1f < x2f) p2.x += 1;
                    else p1.x += 1;
                } else if (x1r === x2r) {
                    p1 = {
                        x: x1r,
                        y: y1f
                    };
                    p2 = {
                        x: x2r,
                        y: y2f
                    };
                    if (y1f < y2f) p2.y += 1;
                    else p1.y += 1;
                } else {
                    p1 = {
                        x: x1,
                        y: y1
                    };
                    p2 = {
                        x: x2,
                        y: y2
                    };
                }
            } else {
                p1 = {
                    x: x1f,
                    y: y1f
                };
                p2 = {
                    x: x2f,
                    y: y2f
                };
                if (y1f === y2f) {
                    if (x1f < x2f) p2.x += 1;
                    else p1.x += 1;
                    p1.y += 0.5;
                    p2.y += 0.5;
                } else if (x1f === x2f) {
                    if (y1f < y2f) p2.y += 1;
                    else p1.y += 1;
                    p1.x += 0.5;
                    p2.x += 0.5;
                } else {
                    p1.x = x1;
                    p1.y = y1;
                    p2.x = x2;
                    p2.y = y2;
                }
            }
            p1 = (0, _bb.BB).rotate(p1.x, p1.y, shapeObj.angleRad / Math.PI * 180);
            p2 = (0, _bb.BB).rotate(p2.x, p2.y, shapeObj.angleRad / Math.PI * 180);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        } else if (shapeObj.type === "rect") {
            // floored
            const x1f = Math.floor(x1);
            const y1f = Math.floor(y1);
            const x2f = Math.floor(x2);
            const y2f = Math.floor(y2);
            if (angleDeg % 90 === 0) {
                if (shapeObj.fillRgb) {
                    if (x1 % 1 === 0) x1 += 1;
                    if (y1 % 1 === 0) y1 += 1;
                    if (x2 % 1 === 0) x2 += 1;
                    if (y2 % 1 === 0) y2 += 1;
                    p1 = {
                        x: x1 < x2 ? x1f : x2f,
                        y: y1 < y2 ? y1f : y2f
                    };
                    p2 = {
                        x: Math.ceil((x1 < x2 ? x2 : x1) - p1.x),
                        y: Math.ceil((y1 < y2 ? y2 : y1) - p1.y)
                    };
                    p2.x = p1.x + p2.x;
                    p2.y = p1.y + p2.y;
                } else if (lineWidth % 2 === 0) {
                    p1 = {
                        x: x1f,
                        y: y1f
                    };
                    p2 = {
                        x: x2f,
                        y: y2f
                    };
                } else {
                    p1 = {
                        x: x1f + 0.5,
                        y: y1f + 0.5
                    };
                    p2 = {
                        x: x2f + 0.5,
                        y: y2f + 0.5
                    };
                }
            } else {
                p1 = {
                    x: x1,
                    y: y1
                };
                p2 = {
                    x: x2,
                    y: y2
                };
            }
            p1 = (0, _bb.BB).rotate(p1.x, p1.y, shapeObj.angleRad / Math.PI * 180);
            p2 = (0, _bb.BB).rotate(p2.x, p2.y, shapeObj.angleRad / Math.PI * 180);
            p2.x = p2.x - p1.x;
            p2.y = p2.y - p1.y;
            if (shapeObj.fillRgb) ctx.fillRect(p1.x, p1.y, p2.x, p2.y);
            else ctx.strokeRect(p1.x, p1.y, p2.x, p2.y);
        } else {
            p1 = (0, _bb.BB).rotate(x1, y1, shapeObj.angleRad / Math.PI * 180);
            p2 = (0, _bb.BB).rotate(x2, y2, shapeObj.angleRad / Math.PI * 180);
            x = p1.x;
            y = p1.y;
            dX = p2.x - p1.x;
            dY = p2.y - p1.y;
            ctx.beginPath();
            ctx.ellipse(x + dX / 2, y + dY / 2, Math.abs(dX / 2), Math.abs(dY / 2), 0, 0, Math.PI * 2);
            if (shapeObj.fillRgb) ctx.fill();
            else ctx.stroke();
        }
        ctx.restore();
    } else throw new Error("unknown shape");
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fEvNY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Draws text on a canvas.
 * Return bounds, relative to p.x, p.y.
 *
 * @param canvas
 * @param p
 */ parcelHelpers.export(exports, "renderText", ()=>renderText);
var _bb = require("../../bb/bb");
function textMetricToRect(metrics, align) {
    // fallback for older browsers
    const ascent = metrics.fontBoundingBoxAscent ?? metrics.actualBoundingBoxAscent;
    const descent = metrics.fontBoundingBoxDescent ?? metrics.actualBoundingBoxDescent;
    if (align === "left") return {
        x: 0,
        y: -ascent,
        width: metrics.width,
        height: ascent + descent
    };
    if (align === "right") return {
        x: -metrics.width,
        y: -ascent,
        width: metrics.width,
        height: ascent + descent
    };
    // center
    return {
        x: -metrics.width / 2,
        y: -ascent,
        width: metrics.width,
        height: ascent + descent
    };
}
function renderText(canvas, p) {
    p = (0, _bb.BB).copyObj(p);
    // setup context
    const ctx = (0, _bb.BB).ctx(canvas);
    ctx.save();
    ctx.textAlign = p.align;
    ctx.letterSpacing = p.letterSpacing ? p.letterSpacing + "px" : "0";
    // font
    const fontArr = [
        p.size + "px " + (p.font ? p.font : "sans-serif")
    ];
    if (p.isBold) fontArr.unshift("bold");
    if (p.isItalic) fontArr.unshift("italic");
    ctx.font = fontArr.join(" ");
    // fill
    ctx.fillStyle = p.fill ? (0, _bb.BB).ColorConverter.toRgbaStr(p.fill.color) : "transparent";
    // stroke
    ctx.strokeStyle = p.stroke ? (0, _bb.BB).ColorConverter.toRgbaStr(p.stroke.color) : "transparent";
    if (p.stroke) {
        ctx.lineWidth = p.stroke.lineWidth;
        ctx.lineJoin = "round";
    }
    ctx.translate(p.x, p.y);
    ctx.rotate(-p.angleRad);
    const lines = p.text.split("\n").map((line)=>line.replaceAll("	", "    "));
    // bounds
    const bounds = {
        x1: 0,
        y1: 0,
        x2: 0,
        y2: 0
    };
    {
        let isFirst = true;
        lines.forEach((line, lineIndex)=>{
            const metrics = ctx.measureText(line);
            const x = 0;
            const y = p.size * (p.lineHeight ?? 1) * lineIndex;
            const mRect = textMetricToRect(metrics, p.align);
            if (isFirst) {
                isFirst = false;
                bounds.x1 = x + mRect.x;
                bounds.y1 = y + mRect.y;
                bounds.x2 = x + mRect.x + mRect.width;
                bounds.y2 = y + mRect.y + mRect.height;
            } else {
                bounds.x1 = Math.min(bounds.x1, x + mRect.x);
                bounds.y1 = Math.min(bounds.y1, y + mRect.y);
                bounds.x2 = Math.max(bounds.x2, x + mRect.x + mRect.width);
                bounds.y2 = Math.max(bounds.y2, y + mRect.y + mRect.height);
            }
        });
    }
    // draw stroke
    lines.forEach((line, lineIndex)=>{
        const x = 0;
        const y = p.size * (p.lineHeight ?? 1) * lineIndex;
        ctx.strokeText(line, x, y);
    });
    // draw fill
    lines.forEach((line, lineIndex)=>{
        const x = 0;
        const y = p.size * (p.lineHeight ?? 1) * lineIndex;
        ctx.fillText(line, x, y);
    });
    ctx.restore();
    return {
        x: bounds.x1,
        y: bounds.y1,
        width: bounds.x2 - bounds.x1,
        height: bounds.y2 - bounds.y1
    };
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Yf6D":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawProject", ()=>drawProject);
var _bb = require("../../bb/bb");
function drawProject(project, factor) {
    const resultCanvas = (0, _bb.BB).canvas(Math.max(1, Math.round(project.width * factor)), Math.max(1, Math.round(project.height * factor)));
    const ctx = (0, _bb.BB).ctx(resultCanvas);
    ctx.save();
    if (factor > 1) ctx.imageSmoothingEnabled = false;
    for(let i = 0; i < project.layers.length; i++){
        const layer = project.layers[i];
        if (!layer.isVisible || layer.opacity === 0) continue;
        ctx.globalAlpha = layer.opacity;
        const mixModeStr = layer.mixModeStr;
        ctx.globalCompositeOperation = mixModeStr !== undefined ? mixModeStr : "source-over";
        ctx.drawImage(layer.image, 0, 0, resultCanvas.width, resultCanvas.height);
    }
    ctx.restore();
    return resultCanvas;
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jhX3B":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Input processor for gradient tool.
 * Coordinates are in canvas space.
 * angleRad is the angle of the canvas.
 */ parcelHelpers.export(exports, "GradientTool", ()=>GradientTool);
parcelHelpers.export(exports, "drawGradient", ()=>drawGradient);
var _bb = require("../../bb/bb");
class GradientTool {
    // ---- public ----
    constructor(p){
        this.downX = 0;
        this.downY = 0;
        this.downAngleRad = 0;
        this.onGradient = p.onGradient;
    }
    onDown(x, y, angleRad) {
        this.downX = x;
        this.downY = y;
        this.downAngleRad = angleRad;
    }
    onMove(x, y) {
        this.onGradient(false, this.downX, this.downY, x, y, this.downAngleRad);
    }
    onUp(x, y) {
        this.onGradient(true, this.downX, this.downY, x, y, this.downAngleRad);
    }
}
function drawGradient(ctx, gradientObj) {
    ctx.save();
    const x1 = gradientObj.x1;
    const y1 = gradientObj.y1;
    let x2 = gradientObj.x2;
    let y2 = gradientObj.y2;
    if (gradientObj.doSnap) {
        const angleDeg = gradientObj.angleRad * 180 / Math.PI;
        const r1 = (0, _bb.BB).rotate(x1, y1, gradientObj.angleRad / Math.PI * 180);
        const r2 = (0, _bb.BB).rotate(x2, y2, gradientObj.angleRad / Math.PI * 180);
        const pAngleDeg = (0, _bb.BB).pointsToAngleDeg(r1, r2) + 90;
        const pAngleDegSnapped = Math.round(pAngleDeg / 45) * 45;
        const rotated = (0, _bb.BB).rotateAround({
            x: x1,
            y: y1
        }, {
            x: x2,
            y: y2
        }, pAngleDegSnapped - pAngleDeg);
        x2 = rotated.x;
        y2 = rotated.y;
        // needs to be perfect if p1->p2 aligns with canvas x- or y-axis
        if ((angleDeg + pAngleDegSnapped) % 90 === 0) {
            if (Math.round((angleDeg - pAngleDegSnapped) / 90) % 2 === 0) x2 = x1;
            else y2 = y1;
        }
    }
    let baseColor = gradientObj.color1;
    if (gradientObj.isEraser && gradientObj.doLockAlpha) baseColor = {
        r: 255,
        g: 255,
        b: 255
    };
    let color1 = {
        ...baseColor,
        a: gradientObj.opacity
    };
    let color2 = {
        ...baseColor,
        a: 0
    };
    if (gradientObj.isReversed) {
        const temp = color1;
        color1 = color2;
        color2 = temp;
    }
    let gradient;
    if (gradientObj.type === "linear") {
        gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr(color1));
        gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
    } else if (gradientObj.type === "linear-mirror") {
        const d = {
            x: x2 - x1,
            y: y2 - y1
        };
        gradient = ctx.createLinearGradient(x1 - d.x, y1 - d.y, x2, y2);
        gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
        gradient.addColorStop(0.5, (0, _bb.BB).ColorConverter.toRgbaStr(color1));
        gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
    } else if (gradientObj.type === "radial") {
        const r = (0, _bb.BB).Vec2.dist({
            x: x1,
            y: y1
        }, {
            x: x2,
            y: y2
        });
        gradient = ctx.createRadialGradient(x1, y1, 0, x1, y1, r);
        gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr(color1));
        gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr(color2));
    }
    ctx.fillStyle = gradient;
    if (gradientObj.isEraser) ctx.globalCompositeOperation = "destination-out";
    if (gradientObj.doLockAlpha) ctx.globalCompositeOperation = "source-atop";
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.restore();
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6hHQR":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "translateBlending", ()=>translateBlending);
var _language = require("../../language/language");
function translateBlending(blendMode) {
    if (!blendMode) return (0, _language.LANG)("layers-blend-normal");
    const codes = {
        "source-over": "layers-blend-normal",
        "darken": "layers-blend-darken",
        "multiply": "layers-blend-multiply",
        "color-burn": "layers-blend-color-burn",
        "lighten": "layers-blend-lighten",
        "screen": "layers-blend-screen",
        "color-dodge": "layers-blend-color-dodge",
        "overlay": "layers-blend-overlay",
        "soft-light": "layers-blend-soft-light",
        "hard-light": "layers-blend-hard-light",
        "difference": "layers-blend-difference",
        "exclusion": "layers-blend-exclusion",
        "hue": "layers-blend-hue",
        "saturation": "layers-blend-saturation",
        "color": "layers-blend-color",
        "luminosity": "layers-blend-luminosity"
    };
    if (!(blendMode in codes)) throw new Error("unknown blend mode");
    return (0, _language.LANG)(codes[blendMode]);
}

},{"../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3gjCf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "renameLayerDialog", ()=>renameLayerDialog);
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
var _showModal = require("../../modals/base/showModal");
var _removeLayerSvg = require("/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
function renameLayerDialog(parentEl, currentName, callback) {
    const div = (0, _bb.BB).el();
    const label = (0, _bb.BB).el({
        content: (0, _language.LANG)("layers-rename-name") + ":",
        css: {
            marginRight: "5px"
        }
    });
    const row = (0, _bb.BB).el({
        css: {
            display: "flex"
        }
    });
    const input = (0, _bb.BB).el({
        tagName: "input"
    });
    input.value = currentName;
    input.setAttribute("data-ignore-focus", "true");
    const clearBtn = (0, _bb.BB).el({
        tagName: "button",
        content: '<img src="' + (0, _removeLayerSvgDefault.default) + '" height="20"/>',
        title: (0, _language.LANG)("layers-rename-clear"),
        css: {
            marginLeft: "10px"
        },
        onClick: ()=>{
            input.value = "";
            input.focus();
        }
    });
    const suggestions = [
        (0, _language.LANG)("layers-rename-sketch"),
        (0, _language.LANG)("layers-rename-colors"),
        (0, _language.LANG)("layers-rename-shading"),
        (0, _language.LANG)("layers-rename-lines"),
        (0, _language.LANG)("layers-rename-effects"),
        (0, _language.LANG)("background"),
        (0, _language.LANG)("layers-rename-foreground")
    ];
    const suggestionBtns = [];
    const row2 = (0, _bb.BB).el({
        css: {
            display: "flex",
            flexWrap: "wrap",
            marginTop: "5px",
            marginLeft: "-5px"
        }
    });
    suggestions.forEach((item)=>{
        const btn = (0, _bb.BB).el({
            parent: row2,
            tagName: "button",
            content: item,
            onClick: ()=>{
                input.value = "" + btn.textContent;
            },
            css: {
                margin: "5px 0 0 5px"
            }
        });
        suggestionBtns.push(btn);
    });
    div.append(label);
    label.append(row, row2);
    row.append(input, clearBtn);
    setTimeout(()=>{
        input.focus();
        input.select();
    }, 10);
    (0, _showModal.showModal)({
        target: parentEl,
        message: `<b>${(0, _language.LANG)("layers-rename-title")}</b>`,
        div: div,
        buttons: [
            (0, _language.LANG)("layers-rename"),
            "Cancel"
        ],
        primaries: [
            (0, _language.LANG)("layers-rename")
        ],
        callback: (val)=>{
            (0, _bb.BB).destroyEl(clearBtn);
            suggestionBtns.forEach((item)=>{
                (0, _bb.BB).destroyEl(item);
            });
            suggestionBtns.splice(0, suggestionBtns.length);
            if (val === (0, _language.LANG)("layers-rename")) callback(input.value);
            else callback(undefined);
        },
        clickOnEnter: (0, _language.LANG)("layers-rename")
    });
}

},{"../../../../bb/bb":"dcQKo","../../../../language/language":"iiYGN","../../modals/base/showModal":"hr9Po","/src/app/img/ui/remove-layer.svg":"bxKFW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bxKFW":[function(require,module,exports) {
module.exports = require("b9287f92a72a6e18").getBundleURL("d3gnI") + "remove-layer.4913f03e.svg" + "?" + Date.now();

},{"b9287f92a72a6e18":"lgJ39"}],"9Py2f":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "mergeLayerDialog", ()=>mergeLayerDialog);
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
var _options = require("../../components/options");
var _translateBlending = require("../../../canvas/translate-blending");
var _showModal = require("../../modals/base/showModal");
var _theme = require("../../../../theme/theme");
function mergeLayerDialog(parentEl, p) {
    const div = (0, _bb.BB).el();
    div.innerHTML = (0, _language.LANG)("layers-merge-description");
    const options = new (0, _options.Options)({
        optionArr: [
            {
                id: p.mixModeStr,
                label: (0, _translateBlending.translateBlending)(p.mixModeStr)
            },
            {
                id: "source-in",
                label: "source-in"
            },
            {
                id: "source-out",
                label: "source-out"
            },
            {
                id: "source-atop",
                label: "source-atop"
            },
            {
                id: "destination-in",
                label: "destination-in"
            },
            {
                id: "destination-out",
                label: "destination-out"
            },
            {
                id: "destination-atop",
                label: "destination-atop"
            },
            {
                id: "xor",
                label: "xor"
            }
        ],
        initId: p.mixModeStr,
        onChange: ()=>{
            update();
        },
        isSmall: true
    });
    options.getElement().style.marginTop = "5px";
    div.append(options.getElement());
    const thumbDimensions = (0, _bb.BB).fitInto(p.topCanvas.width, p.topCanvas.height, 200, 200, 1);
    const preview = (0, _bb.BB).canvas(thumbDimensions.width, thumbDimensions.height);
    preview.title = (0, _language.LANG)("preview");
    preview.className = "kl-merge-preview";
    const spacer = (0, _bb.BB).el({
        content: "<br/>",
        css: {
            clear: "both"
        }
    });
    div.append(spacer, preview);
    function updateCheckerboard() {
        (0, _bb.BB).createCheckerDataUrl(4, (url)=>{
            preview.style.backgroundImage = "url(" + url + ")";
        }, (0, _theme.theme).isDark());
    }
    updateCheckerboard();
    (0, _theme.theme).addIsDarkListener(updateCheckerboard);
    const alphaCanvas = (0, _bb.BB).copyCanvas(preview);
    (0, _bb.BB).ctx(alphaCanvas).drawImage(p.topCanvas, 0, 0, alphaCanvas.width, alphaCanvas.height);
    (0, _bb.BB).convertToAlphaChannelCanvas(alphaCanvas);
    const update = ()=>{
        const ctx = (0, _bb.BB).ctx(preview);
        ctx.save();
        ctx.clearRect(0, 0, preview.width, preview.height);
        if (preview.width > p.topCanvas.width) ctx.imageSmoothingEnabled = false;
        ctx.drawImage(p.bottomCanvas, 0, 0, preview.width, preview.height);
        if (options.getValue() === "as-alpha") {
            ctx.globalCompositeOperation = "destination-in";
            ctx.globalAlpha = p.topOpacity;
            ctx.drawImage(alphaCanvas, 0, 0, preview.width, preview.height);
        } else {
            ctx.globalCompositeOperation = options.getValue();
            ctx.globalAlpha = p.topOpacity;
            ctx.drawImage(p.topCanvas, 0, 0, preview.width, preview.height);
        }
        ctx.restore();
    };
    update();
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: (keyStr)=>{
            if (keyStr === "right") options.next();
            if (keyStr === "left") options.previous();
        }
    });
    (0, _showModal.showModal)({
        target: parentEl,
        message: `<b>${(0, _language.LANG)("layers-merge-modal-title")}</b>`,
        div: div,
        buttons: [
            "Ok",
            "Cancel"
        ],
        clickOnEnter: "Ok",
        callback: (val)=>{
            keyListener.destroy();
            options.destroy();
            (0, _theme.theme).removeIsDarkListener(updateCheckerboard);
            if (val === "Ok") p.callback(options.getValue());
        }
    });
}

},{"../../../../bb/bb":"dcQKo","../../../../language/language":"iiYGN","../../components/options":"hNLP6","../../../canvas/translate-blending":"6hHQR","../../modals/base/showModal":"hr9Po","../../../../theme/theme":"4G3JB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"27IEf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DropdownMenu", ()=>DropdownMenu);
var _c = require("../../../bb/base/c");
var _ui = require("../../../bb/base/ui");
class DropdownMenu {
    // ---- public ----
    constructor(p){
        this.isExpanded = false;
        this.onSetEnabled = ()=>0;
        const button = (0, _c.c)("button,w-full,h-full", [
            p.button
        ]);
        button.onclick = ()=>{
            toggle(!this.isExpanded);
        };
        if (p.buttonTitle) button.title = p.buttonTitle;
        (0, _ui.makeUnfocusable)(button);
        const items = [];
        const itemMap = {};
        p.items.forEach((item)=>{
            const itemButton = (0, _c.c)("button", item[1]);
            (0, _ui.makeUnfocusable)(itemButton);
            itemButton.onclick = ()=>{
                toggle(false);
                p.onItemClick(item[0]);
            };
            items.push(itemButton);
            itemMap[item[0]] = itemButton;
        });
        this.onSetEnabled = (id, enabled)=>{
            itemMap[id].disabled = !enabled;
        };
        const menu = (0, _c.c)(".kl-dropdown-menu,right-0,top-full,nowrap,hidden", items);
        this.rootElement = (0, _c.c)(",pos-relative", [
            button,
            menu
        ]);
        const toggle = (force)=>{
            this.isExpanded = force;
            menu.style.display = this.isExpanded ? "block" : "none";
            if (this.isExpanded) {
                document.addEventListener("pointerdown", onPointerDown);
                window.addEventListener("blur", onBlur);
            } else {
                document.removeEventListener("pointerdown", onPointerDown);
                window.removeEventListener("blur", onBlur);
            }
        };
        const onPointerDown = (e)=>{
            const target = e.target;
            if (button.contains(target) || menu.contains(target)) return;
            toggle(false);
        };
        const onBlur = ()=>toggle(false);
    }
    getElement() {
        return this.rootElement;
    }
    setEnabled(id, enabled) {
        this.onSetEnabled(id, enabled);
    }
}

},{"../../../bb/base/c":"eg9k9","../../../bb/base/ui":"2nyzl","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dRtih":[function(require,module,exports) {
module.exports = require("e636dadc99e05414").getBundleURL("d3gnI") + "add-layer.21472908.svg" + "?" + Date.now();

},{"e636dadc99e05414":"lgJ39"}],"1jmou":[function(require,module,exports) {
module.exports = require("e1a3d4883b1ceae3").getBundleURL("d3gnI") + "duplicate-layer.ee0c87e4.svg" + "?" + Date.now();

},{"e1a3d4883b1ceae3":"lgJ39"}],"6z8Dr":[function(require,module,exports) {
module.exports = require("c65cd6fbed95e6e0").getBundleURL("d3gnI") + "merge-layers.1a96fa59.svg" + "?" + Date.now();

},{"c65cd6fbed95e6e0":"lgJ39"}],"3N21W":[function(require,module,exports) {
module.exports = require("ce9587e6e14f776").getBundleURL("d3gnI") + "rename-layer.a7ea9cd5.svg" + "?" + Date.now();

},{"ce9587e6e14f776":"lgJ39"}],"E9FPv":[function(require,module,exports) {
module.exports = require("4e0f4f0b6aba83d9").getBundleURL("d3gnI") + "caret-down.0f7da0ad.svg" + "?" + Date.now();

},{"4e0f4f0b6aba83d9":"lgJ39"}],"kspFU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Overlay for KlCanvasWorkspace.
 * - brush circle
 * - eyedropper circle
 * - compass needle (rotation hud)
 */ parcelHelpers.export(exports, "WorkspaceSvgOverlay", ()=>WorkspaceSvgOverlay);
var _bb = require("../../bb/bb");
class WorkspaceSvgOverlay {
    // ---- public ----
    constructor(p){
        this.rootElement = (0, _bb.BB).createSvg({
            elementType: "svg",
            width: "" + p.width,
            height: "" + p.height
        });
        (0, _bb.BB).css(this.rootElement, {
            position: "absolute",
            left: "0",
            top: "0",
            pointerEvents: "none",
            userSelect: "none"
        });
        //brush circles
        this.brushCircleOuter = (0, _bb.BB).createSvg({
            elementType: "circle",
            r: "10",
            stroke: "rgba(0,0,0,0.7)",
            "stroke-width": "1",
            fill: "none"
        });
        this.brushCircleInner = (0, _bb.BB).createSvg({
            elementType: "circle",
            r: "9",
            stroke: "rgba(255,255,255,0.7)",
            "stroke-width": "1",
            fill: "none"
        });
        this.rootElement.append(this.brushCircleOuter, this.brushCircleInner);
        //color picker preview circle
        this.pickerPreviewBorder = (0, _bb.BB).createSvg({
            elementType: "circle",
            r: "47",
            stroke: "black",
            "stroke-width": "22",
            fill: "none"
        });
        this.pickerPreviewBorder.style.opacity = "0";
        this.pickerPreviewCol = (0, _bb.BB).createSvg({
            elementType: "circle",
            r: "47",
            stroke: "black",
            "stroke-width": "20",
            fill: "none"
        });
        this.pickerPreviewCol.style.opacity = "0";
        this.rootElement.append(this.pickerPreviewBorder, this.pickerPreviewCol);
        //rotation compass
        this.compassSize = 30;
        this.compass = (0, _bb.BB).createSvg({
            elementType: "g",
            transform: "translate(" + p.width / 2 + ", " + p.height / 2 + ")"
        });
        (0, _bb.BB).css(this.compass, {
            transition: "opacity 0.25s ease-in-out",
            opacity: "0"
        });
        this.compassInner = (0, _bb.BB).createSvg({
            elementType: "g",
            transform: "rotate(45)"
        });
        this.compassBaseCircle = (0, _bb.BB).createSvg({
            elementType: "circle",
            fill: "rgba(0,0,0,0.9)",
            stroke: "none",
            cx: "0",
            cy: "0",
            r: "" + this.compassSize
        });
        this.compassLineCircle = (0, _bb.BB).createSvg({
            elementType: "circle",
            fill: "none",
            stroke: "rgba(255,255,255,0.75)",
            "stroke-width": "1",
            cx: "0",
            cy: "0",
            r: "" + this.compassSize * 0.9
        });
        this.compassUpperTriangle = (0, _bb.BB).createSvg({
            elementType: "path",
            fill: "#f00",
            stroke: "none",
            d: "M -" + this.compassSize * 0.25 + ",0 " + this.compassSize * 0.25 + ",0 0,-" + this.compassSize * 0.9 + " z"
        });
        this.compassLowerTriangle = (0, _bb.BB).createSvg({
            elementType: "path",
            fill: "#fff",
            stroke: "none",
            d: "M -" + this.compassSize * 0.25 + ",0 " + this.compassSize * 0.25 + ",0 0," + this.compassSize * 0.9 + " z"
        });
        this.compassInner.append(this.compassBaseCircle, this.compassLineCircle, this.compassUpperTriangle, this.compassLowerTriangle);
        this.compass.append(this.compassInner);
        this.rootElement.append(this.compass);
    }
    getElement() {
        return this.rootElement;
    }
    setSize(width, height) {
        this.rootElement.setAttribute("width", "" + width);
        this.rootElement.setAttribute("height", "" + height);
        this.compass.setAttribute("transform", "translate(" + width / 2 + ", " + height / 2 + ")");
    }
    updateCursor(p) {
        if (p.x !== undefined) {
            this.brushCircleOuter.setAttribute("cx", "" + p.x);
            this.brushCircleInner.setAttribute("cx", "" + p.x);
        }
        if (p.y !== undefined) {
            this.brushCircleOuter.setAttribute("cy", "" + p.y);
            this.brushCircleInner.setAttribute("cy", "" + p.y);
        }
        if (p.radius !== undefined) {
            this.brushCircleOuter.setAttribute("r", "" + Math.max(0, p.radius));
            this.brushCircleInner.setAttribute("r", "" + Math.max(0, p.radius - 1));
        }
        if (p.isVisible !== undefined) {
            this.brushCircleOuter.style.opacity = p.isVisible ? "1" : "0";
            this.brushCircleInner.style.opacity = p.isVisible ? "1" : "0";
        }
    }
    updateColorPreview(p) {
        if (p.x !== undefined) {
            this.pickerPreviewCol.setAttribute("cx", "" + p.x);
            this.pickerPreviewBorder.setAttribute("cx", "" + p.x);
        }
        if (p.y !== undefined) {
            this.pickerPreviewCol.setAttribute("cy", "" + p.y);
            this.pickerPreviewBorder.setAttribute("cy", "" + p.y);
        }
        if (p.color) {
            this.pickerPreviewCol.setAttribute("stroke", (0, _bb.BB).ColorConverter.toRgbStr(p.color));
            const borderColor = (0, _bb.BB).testIsWhiteBestContrast(p.color) ? "rgba(255,255,255,0.5)" : "rgba(0,0,0,0.5)";
            this.pickerPreviewBorder.setAttribute("stroke", borderColor);
        }
        if (p.isVisible !== undefined) {
            this.pickerPreviewCol.style.opacity = p.isVisible ? "1" : "0";
            this.pickerPreviewBorder.style.opacity = p.isVisible ? "1" : "0";
        }
    }
    updateCompass(p) {
        if (p.angleDeg !== undefined) {
            this.compassInner.setAttribute("transform", "rotate(" + p.angleDeg + ")");
            this.compassLineCircle.style.opacity = p.angleDeg % 90 === 0 ? "1" : "0";
        }
        if (p.isVisible !== undefined) this.compass.style.opacity = p.isVisible ? "1" : "0";
    }
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ep4xw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Work area that displays the KlCanvas.
 * - pan, zoom, rotate (also via multi-touch)
 * - input modes: drawing, hand, pick, fill, text // transform, select
 * - drawing input events
 * - view change events
 * - eyedropper input events (pick)
 * - draws cursor, eyedropper overlay
 *
 * subscribes to klCanvas changes
 * listens to kl history for changes
 * and you can manually trigger redraw
 */ parcelHelpers.export(exports, "KlCanvasWorkspace", ()=>KlCanvasWorkspace);
var _bb = require("../../bb/bb");
var _workspaceSvgOverlay = require("./workspace-svg-overlay");
var _klHistory = require("../history/kl-history");
var _cursorPickerPng = require("/src/app/img/ui/cursor-picker.png");
var _cursorPickerPngDefault = parcelHelpers.interopDefault(_cursorPickerPng);
var _cursorZoomEwPng = require("/src/app/img/ui/cursor-zoom-ew.png");
var _cursorZoomEwPngDefault = parcelHelpers.interopDefault(_cursorZoomEwPng);
var _cursorFillPng = require("/src/app/img/ui/cursor-fill.png");
var _cursorFillPngDefault = parcelHelpers.interopDefault(_cursorFillPng);
var _cursorTextPng = require("/src/app/img/ui/cursor-text.png");
var _cursorTextPngDefault = parcelHelpers.interopDefault(_cursorTextPng);
var _kl = require("../kl");
var _linetoolProcessor = require("../events/linetool-processor");
var _theme = require("../../theme/theme");
var _klConfig = require("../kl-config");
const MIN_SCALE = 1 / 16;
const MAX_SCALE = Math.pow(2, 7);
var TMode;
(function(TMode) {
    TMode[TMode["Draw"] = 0] = "Draw";
    TMode[TMode["Hand"] = 1] = "Hand";
    TMode[TMode["HandGrabbing"] = 2] = "HandGrabbing";
    TMode[TMode["Pick"] = 3] = "Pick";
    TMode[TMode["Zoom"] = 4] = "Zoom";
    TMode[TMode["Rotate"] = 5] = "Rotate";
    TMode[TMode["Rotating"] = 6] = "Rotating";
    TMode[TMode["Fill"] = 7] = "Fill";
    TMode[TMode["Gradient"] = 8] = "Gradient";
    TMode[TMode["Text"] = 9] = "Text";
    TMode[TMode["Shape"] = 10] = "Shape";
})(TMode || (TMode = {}));
const ANIMATION_SPEED = 0.3; // rate of transition towards targetTransform
class KlCanvasWorkspace {
    getRenderedTransform() {
        // rounded x & y so canvas is less blurry.
        const result = this.renderedTransformObj;
        result.x = this.highResTransformObj.x;
        result.y = this.highResTransformObj.y;
        result.scale = this.highResTransformObj.scale;
        result.angle = this.highResTransformObj.angle;
        if (result.angle % (Math.PI / 2) === 0 && result.scale % 1 === 0) {
            result.x = Math.round(result.x);
            result.y = Math.round(result.y);
        }
        return result;
    }
    updateChangeListener() {
        this.klCanvas.addChangeListener(()=>{
            this.lastRenderedState = -1;
            this.reqFrame();
        });
    }
    updateCursor(modeInt, doForce) {
        if (modeInt === this.currentMode && !doForce) return;
        const oldMode = this.currentMode;
        this.currentMode = modeInt;
        this.lastRenderedState = -1;
        if (this.currentMode === TMode.Draw) this.rootEl.style.cursor = "crosshair";
        else if (this.currentMode === TMode.Hand) this.rootEl.style.cursor = "grab";
        else if (this.currentMode === TMode.HandGrabbing) this.rootEl.style.cursor = "grabbing";
        else if (this.currentMode === TMode.Pick) this.rootEl.style.cursor = "url('" + (0, _cursorPickerPngDefault.default) + "') 0 15, crosshair";
        else if (this.currentMode === TMode.Zoom) this.rootEl.style.cursor = "url('" + (0, _cursorZoomEwPngDefault.default) + "') 7 7, zoom-in";
        else if (this.currentMode === TMode.Rotate) this.rootEl.style.cursor = "grab";
        else if (this.currentMode === TMode.Rotating) this.rootEl.style.cursor = "grabbing";
        else if (this.currentMode === TMode.Fill) this.rootEl.style.cursor = "url('" + (0, _cursorFillPngDefault.default) + "') 1 12, crosshair";
        else if (this.currentMode === TMode.Gradient) this.rootEl.style.cursor = "crosshair";
        else if (this.currentMode === TMode.Text) this.rootEl.style.cursor = "url('" + (0, _cursorTextPngDefault.default) + "') 1 12, crosshair";
        else if (this.currentMode === TMode.Shape) this.rootEl.style.cursor = "crosshair";
        if ([
            TMode.Draw,
            TMode.Pick,
            TMode.Fill,
            TMode.Text,
            TMode.Shape
        ].includes(this.globalMode)) {
            const oldIsHand = [
                TMode.Hand,
                TMode.HandGrabbing
            ].includes(oldMode);
            const currentIsHand = [
                TMode.Hand,
                TMode.HandGrabbing
            ].includes(this.currentMode);
            if (!oldIsHand && currentIsHand) this.mainDoubleTapper.setAllowedPointerTypeArr([
                "mouse",
                "pen",
                "touch"
            ]);
            if (oldIsHand && !currentIsHand) this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (this.currentMode !== TMode.Pick) this.svgOverlay.updateColorPreview({
            isVisible: false
        });
    }
    /**
     * returns false if no change of zoom
     * @param stepNum
     * @param centerX
     * @param centerY
     * @private
     */ internalZoomByStep(stepNum, centerX, centerY) {
        const step = Math.log2(this.targetTransformObj.scale);
        let newStep = step / Math.abs(stepNum);
        newStep += stepNum > 0 ? 1 : -1;
        newStep = Math.round(newStep);
        newStep *= Math.abs(stepNum);
        const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, Math.pow(2, newStep)));
        //has zoomed?
        if (newScale === this.targetTransformObj.scale) return false;
        const effectiveFactor = newScale / this.targetTransformObj.scale;
        this.targetTransformObj.scale = newScale;
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(centerX, centerY));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(effectiveFactor));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-centerX, -centerY));
        let origin = [
            this.targetTransformObj.x,
            this.targetTransformObj.y,
            0,
            1
        ];
        origin = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, origin);
        this.targetTransformObj.x = origin[0];
        this.targetTransformObj.y = origin[1];
        this.transformIsDirty = true;
        return true;
    }
    /**
     * mixes two transform objects. modifies A
     * @param transformA
     * @param transformB
     * @param blendFactor 0 -> A, 1 -> B
     * @private
     */ mixTransformObj(transformA, transformB, blendFactor) {
        if (transformA.angle === transformB.angle) {
            transformA.scale = (0, _bb.BB).mix(transformA.scale, transformB.scale, blendFactor);
            transformA.x = (0, _bb.BB).mix(transformA.x, transformB.x, blendFactor);
            transformA.y = (0, _bb.BB).mix(transformA.y, transformB.y, blendFactor);
            transformA.angle = (0, _bb.BB).mix(transformA.angle, transformB.angle, blendFactor);
            return;
        }
        const w = this.klCanvas.getWidth();
        const h = this.klCanvas.getHeight();
        // --- determine centerPosA, centerPosB ---
        const centerPosA = this.canvasToWorkspaceCoord({
            x: w / 2,
            y: h / 2
        }, transformA);
        const centerPosB = this.canvasToWorkspaceCoord({
            x: w / 2,
            y: h / 2
        }, transformB);
        // --- centerPosMixed ---
        transformA.x = (0, _bb.BB).mix(centerPosA.x, centerPosB.x, blendFactor);
        transformA.y = (0, _bb.BB).mix(centerPosA.y, centerPosB.y, blendFactor);
        // --- scale and angle ---
        transformA.scale = (0, _bb.BB).mix(transformA.scale, transformB.scale, blendFactor);
        transformA.angle = (0, _bb.BB).mix(transformA.angle, transformB.angle, blendFactor);
        // --- x and y ---
        const mixedPos = this.canvasToWorkspaceCoord({
            x: -w / 2,
            y: -h / 2
        }, transformA);
        transformA.x = mixedPos.x;
        transformA.y = mixedPos.y;
    }
    render() {
        if (this.doResizeCanvas) {
            this.doResizeCanvas = false;
            this.renderTargetCanvas.width = this.renderWidth;
            this.renderTargetCanvas.height = this.renderHeight;
        }
        this.renderContext(this.renderTargetCtx);
    }
    /**
     * is the gray background that surrounds canvas visible?
     * @private
     */ testBgVisible() {
        //bring workspace points (corners of workspace) into canvas coordinate system
        //then check if any corner point is outside of the canvas -> that means the bg is visible
        const workspacePointArr = [
            [
                0,
                0
            ],
            [
                this.renderWidth,
                0
            ],
            [
                this.renderWidth,
                this.renderHeight
            ],
            [
                0,
                this.renderHeight
            ]
        ];
        const art = this.getRenderedTransform();
        //setup transformation matrix
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(1 / art.scale));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(-art.angle));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-art.x, -art.y));
        //transform points, then test if outside of canvas
        for(let i = 0; i < workspacePointArr.length; i++){
            let coords = [
                workspacePointArr[i][0],
                workspacePointArr[i][1],
                0,
                1
            ];
            coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
            if (!(0 <= coords[0] && coords[0] <= this.klCanvas.getWidth() && 0 <= coords[1] && coords[1] <= this.klCanvas.getHeight())) //if not inside -> bg visible
            return true;
        }
        return false;
    }
    renderContext(ctx) {
        const w = this.klCanvas.getWidth();
        const h = this.klCanvas.getHeight();
        const art = this.getRenderedTransform();
        const isDark = (0, _theme.theme).isDark();
        if (art.scale >= 4 || art.scale === 1 && art.angle === 0) ctx.imageSmoothingEnabled = false;
        else {
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "low"; // art.scale >= 1 ? 'low' : 'medium';
        }
        //ctx.imageSmoothingEnabled = false;
        //renderTargetCtx.globalCompositeOperation  = 'multiply';
        ctx.save();
        {
            if (this.bgVisible) {
                ctx.fillStyle = isDark ? "rgb(33, 33, 33)" : "rgb(158,158,158)"; // 'rgb(185,185,185)';
                ctx.fillRect(0, 0, this.renderWidth, this.renderHeight);
            } else ctx.clearRect(0, 0, this.renderWidth, this.renderHeight);
            if (this.bgVisible) {
                ctx.save();
                ctx.translate(art.x, art.y);
                ctx.scale(art.scale, art.scale);
                ctx.rotate(art.angle);
                ctx.imageSmoothingEnabled = false;
                //outline
                const borderSize = 1;
                ctx.globalAlpha = isDark ? 0.25 : 0.2;
                ctx.drawImage(isDark ? this.emptyLightCanvas : this.emptyCanvas, -borderSize / art.scale, -borderSize / art.scale, w + borderSize * 2 / art.scale, h + borderSize * 2 / art.scale);
                ctx.globalAlpha = 1;
                //erase
                ctx.globalCompositeOperation = "destination-out";
                ctx.drawImage(this.emptyCanvas, 0, 0, w, h);
                ctx.restore();
            }
            /*const region = new Path2D();
            region.rect(80, 10, 20, 130);
            ctx.clip(region);*/ ctx.translate(art.x, art.y);
            ctx.scale(art.scale, art.scale);
            ctx.rotate(art.angle);
            const layerArr = this.klCanvas.getLayersFast();
            for(let i = 0; i < layerArr.length; i++){
                if (!layerArr[i].isVisible || layerArr[i].opacity === 0) continue;
                ctx.globalAlpha = layerArr[i].opacity;
                ctx.globalCompositeOperation = layerArr[i].mixModeStr;
                const compositeObj = layerArr[i].canvas.compositeObj;
                if (compositeObj) {
                    if (this.compositeCanvas.width !== layerArr[i].canvas.width || this.compositeCanvas.height !== layerArr[i].canvas.height) {
                        this.compositeCanvas.width = layerArr[i].canvas.width;
                        this.compositeCanvas.height = layerArr[i].canvas.height;
                    } else this.compositeCtx.clearRect(0, 0, this.compositeCanvas.width, this.compositeCanvas.height);
                    this.compositeCtx.drawImage(layerArr[i].canvas, 0, 0);
                    compositeObj.draw(this.compositeCtx);
                    ctx.drawImage(this.compositeCanvas, 0, 0, w, h);
                } else ctx.drawImage(layerArr[i].canvas, 0, 0, w, h);
            }
            ctx.globalAlpha = 1;
        }
        ctx.restore();
        // rotation hud
        if (TMode.Rotate === this.currentMode || TMode.Rotating === this.currentMode) this.svgOverlay.updateCompass({
            isVisible: true,
            angleDeg: art.angle / Math.PI * 180
        });
        else this.svgOverlay.updateCompass({
            isVisible: false
        });
    }
    workspaceToCanvasCoord(p) {
        const art = this.getRenderedTransform();
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(1 / art.scale));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(-art.angle));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-art.x, -art.y));
        let coords = [
            p.x,
            p.y,
            0,
            1
        ];
        coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
        return {
            x: coords[0],
            y: coords[1]
        };
    }
    canvasToWorkspaceCoord(p, transformObj) {
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(transformObj.x, transformObj.y));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(transformObj.angle));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(transformObj.scale));
        let coords = [
            p.x,
            p.y,
            0,
            1
        ];
        coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
        return {
            x: coords[0],
            y: coords[1]
        };
    }
    snapAngleRad(angleRad, snapDegIncrement, maxDistDeg) {
        let angleDeg = angleRad * 180 / Math.PI;
        const modDeg = Math.abs(angleDeg % snapDegIncrement);
        const dist = Math.min(modDeg, snapDegIncrement - modDeg);
        if (dist <= maxDistDeg) angleDeg = Math.round(angleDeg / snapDegIncrement) * snapDegIncrement;
        return angleDeg / 180 * Math.PI;
    }
    /**
     * angle always in range [-PI, PI]
     * @param angleRad
     * @private
     */ minimizeAngleRad(angleRad) {
        angleRad = angleRad % (2 * Math.PI);
        if (angleRad > Math.PI) angleRad -= 2 * Math.PI;
        else if (angleRad < -Math.PI) angleRad += 2 * Math.PI;
        return angleRad;
    }
    resetInputProcessor() {
        this.currentInputProcessor = null;
        this.updateCursor(this.globalMode);
        this.reqFrame(true);
    }
    reqFrame(doRedrawCanvas) {
        this.animationFrameRequested = true;
        if (doRedrawCanvas) this.lastRenderedState = -1;
    }
    updateLoop() {
        window.requestAnimationFrame(()=>this.updateLoop());
        const newState = (0, _klHistory.klHistory).getState();
        const doRender = this.lastRenderedState < newState;
        //handle variable framerate
        const nowTime = performance.now();
        const elapsedFrames = (nowTime - this.lastRenderTime) * 60 / 1000; //how many frames elapsed since last render if fps were 60fps
        this.lastRenderTime = nowTime;
        if (this.animationFrameRequested || doRender) {
            this.animationFrameRequested = false;
            this.checkChange(elapsedFrames);
        }
    }
    checkChange(elapsedFrames) {
        const newState = (0, _klHistory.klHistory).getState();
        const doRender = this.lastRenderedState < newState || this.highResTransformObj.scale !== this.targetTransformObj.scale || this.highResTransformObj.x !== this.targetTransformObj.x || this.highResTransformObj.y !== this.targetTransformObj.y;
        //update transform
        if (!this.doAnimateTranslate && (this.highResTransformObj.scale === this.targetTransformObj.scale || Math.abs(this.highResTransformObj.scale - this.targetTransformObj.scale) < 0.008 * this.targetTransformObj.scale)) {
            this.highResTransformObj.scale = this.targetTransformObj.scale;
            this.highResTransformObj.x = this.targetTransformObj.x;
            this.highResTransformObj.y = this.targetTransformObj.y;
            this.highResTransformObj.angle = this.targetTransformObj.angle;
            if (this.transformIsDirty) {
                this.transformIsDirty = false;
                this.bgVisible = this.testBgVisible();
            }
            this.svgOverlay.updateCursor({
                radius: this.brushRadius * this.highResTransformObj.scale
            });
        } else if ((this.highResTransformObj.x === this.targetTransformObj.x || Math.abs(this.highResTransformObj.x - this.targetTransformObj.x) < 0.5) && (this.highResTransformObj.y === this.targetTransformObj.y || Math.abs(this.highResTransformObj.y - this.targetTransformObj.y) < 0.5) && (this.highResTransformObj.scale === this.targetTransformObj.scale || Math.abs(this.highResTransformObj.scale - this.targetTransformObj.scale) < 0.008 * this.targetTransformObj.scale)) {
            this.highResTransformObj.scale = this.targetTransformObj.scale;
            this.highResTransformObj.x = this.targetTransformObj.x;
            this.highResTransformObj.y = this.targetTransformObj.y;
            this.highResTransformObj.angle = this.targetTransformObj.angle;
            this.doAnimateTranslate = false;
            if (this.transformIsDirty) {
                this.transformIsDirty = false;
                this.bgVisible = this.testBgVisible();
            }
            this.svgOverlay.updateCursor({
                radius: this.brushRadius * this.highResTransformObj.scale
            });
        } else {
            this.reqFrame(); //probably needs another frame
            const blendFactor = Math.min(1, ANIMATION_SPEED * elapsedFrames);
            this.mixTransformObj(this.highResTransformObj, this.targetTransformObj, blendFactor);
            this.bgVisible = true; // spare yourself the calculation
            this.svgOverlay.updateCursor({
                radius: this.brushRadius * this.highResTransformObj.scale
            });
        }
        if (this.pointer && this.currentMode == TMode.Draw && !this.usesCssCursor) this.svgOverlay.updateCursor({
            x: this.pointer.x,
            y: this.pointer.y,
            isVisible: true
        });
        else this.svgOverlay.updateCursor({
            isVisible: false
        });
        if (doRender) {
            //console.log('scale', this.renderedTransform.scale, 'x', this.renderedTransform.x, 'y', this.renderedTransform.y);
            this.lastRenderedState = newState;
            const start = performance.now();
            this.render();
            this.renderTime = (0, _bb.BB).mix(this.renderTime, performance.now() - start, 0.05);
        }
        doRender;
    }
    // ---- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: {
                position: "absolute",
                left: "0",
                right: "0",
                top: "0",
                bottom: "0",
                cursor: "crosshair",
                userSelect: "none"
            }
        });
        this.klCanvas = p.klCanvas;
        this.onViewChange = p.onViewChange;
        this.renderTargetCanvas = (0, _bb.BB).canvas(p.width, p.height);
        this.renderTargetCtx = (0, _bb.BB).ctx(this.renderTargetCanvas);
        this.renderWidth = p.width;
        this.renderHeight = p.height;
        this.compositeCanvas = (0, _bb.BB).canvas(1, 1); // for drawing klcanvas layer composite
        this.compositeCtx = (0, _bb.BB).ctx(this.compositeCanvas);
        this.doResizeCanvas = false;
        this.oldTransformObj = null;
        this.targetTransformObj = {
            x: 0,
            y: 0,
            scale: 1,
            angle: 0
        };
        this.highResTransformObj = {
            x: 0,
            y: 0,
            scale: 1,
            angle: 0
        };
        this.renderedTransformObj = {};
        this.cursorPos = {
            x: 0,
            y: 0
        };
        this.usesCssCursor = false;
        this.bgVisible = true;
        this.transformIsDirty = true;
        this.doAnimateTranslate = true;
        this.svgOverlay = new (0, _workspaceSvgOverlay.WorkspaceSvgOverlay)({
            width: p.width,
            height: p.height
        });
        (0, _bb.BB).css(this.renderTargetCanvas, {
            userSelect: "none",
            pointerEvents: "none"
        });
        (0, _bb.BB).createCheckerDataUrl(8, (url)=>{
            this.renderTargetCanvas.style.background = "url(" + url + ")";
        }, (0, _theme.theme).isDark());
        (0, _theme.theme).addIsDarkListener(()=>{
            this.renderTargetCanvas.style.background = "url(" + (0, _bb.BB).createCheckerDataUrl(8, undefined, (0, _theme.theme).isDark()) + ")";
            this.lastRenderedState = -1;
            this.reqFrame();
        });
        this.rootEl.append(this.renderTargetCanvas, this.svgOverlay.getElement());
        this.rootEl.addEventListener("touchend", (e)=>{
            e.preventDefault();
            return false;
        });
        this.rootEl.addEventListener("contextmenu", (e)=>{
            e.preventDefault();
            return false;
        });
        this.rootEl.addEventListener("dragstart", (e)=>{
            e.preventDefault();
            return false;
        });
        this.emptyCanvas = (0, _bb.BB).canvas(1, 1);
        this.emptyLightCanvas = (0, _bb.BB).canvas(1, 1);
        {
            let ctx = (0, _bb.BB).ctx(this.emptyCanvas);
            ctx.fillRect(0, 0, 1, 1);
            ctx = (0, _bb.BB).ctx(this.emptyLightCanvas);
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, 0, 1, 1);
        }
        this.keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr, event, comboStr, isRepeat)=>{
                if ((0, _kl.KL).dialogCounter.get() > 0 || (0, _bb.BB).isInputFocused(true)) return;
                if (keyStr === "alt") event.preventDefault();
                if (isRepeat) return;
                if (this.currentInputProcessor) this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                else {
                    if ([
                        TMode.Draw,
                        TMode.Pick,
                        TMode.Fill,
                        TMode.Gradient,
                        TMode.Text,
                        TMode.Shape
                    ].includes(this.globalMode) && comboStr === "space") {
                        this.currentInputProcessor = this.inputProcessorObj.spaceHand;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                    if ([
                        TMode.Draw,
                        TMode.Hand,
                        TMode.Fill,
                        TMode.Gradient,
                        TMode.Text,
                        TMode.Shape
                    ].includes(this.globalMode) && comboStr === "alt") {
                        this.currentInputProcessor = this.inputProcessorObj.altPicker;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                    if ([
                        "r",
                        "shift+r"
                    ].includes(comboStr)) {
                        this.currentInputProcessor = this.inputProcessorObj.rotate;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                    if ("z" === comboStr) {
                        this.currentInputProcessor = this.inputProcessorObj.zoom;
                        this.currentInputProcessor.onKeyDown(keyStr, event, comboStr, isRepeat);
                        return;
                    }
                }
            },
            onUp: (keyStr, event, oldComboStr)=>{
                // prevent menu bar in Firefox
                if (keyStr === "alt") event.preventDefault();
                if (this.currentInputProcessor) this.currentInputProcessor.onKeyUp(keyStr, event, oldComboStr);
            }
        });
        this.updateChangeListener();
        this.currentMode = TMode.Draw;
        this.globalMode = TMode.Draw;
        this.renderTime = 0;
        this.lastDrawEvent = null;
        this.linetoolProcessor = new (0, _linetoolProcessor.LinetoolProcessor)({
            onDraw: (event)=>{
                const getMatrix = ()=>{
                    const art = this.getRenderedTransform();
                    let matrix = (0, _bb.BB).Matrix.getIdentity();
                    matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(1 / art.scale));
                    matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(-art.angle));
                    matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-art.x, -art.y));
                    return matrix;
                };
                if (event.type === "line" && !this.lastDrawEvent) {
                    const matrix = getMatrix();
                    let coords = [
                        event.x1,
                        event.y1,
                        0,
                        1
                    ];
                    coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
                    this.lastDrawEvent = {
                        x: coords[0],
                        y: coords[1],
                        pressure: event.pressure1
                    };
                    return;
                }
                if ("x" in event || "x0" in event) {
                    const matrix = getMatrix();
                    if ("x" in event) {
                        let coords = [
                            event.x,
                            event.y,
                            0,
                            1
                        ];
                        coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
                        event.x = coords[0];
                        event.y = coords[1];
                    }
                    if ("x0" in event) {
                        event.x0 = this.lastDrawEvent.x;
                        event.y0 = this.lastDrawEvent.y;
                        event.pressure0 = this.lastDrawEvent.pressure;
                        let coords = [
                            event.x1,
                            event.y1,
                            0,
                            1
                        ];
                        coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
                        event.x1 = coords[0];
                        event.y1 = coords[1];
                        this.lastDrawEvent = {
                            x: event.x1,
                            y: event.y1,
                            pressure: event.pressure1
                        };
                    }
                }
                if (event.type === "down" || event.type === "move") this.lastDrawEvent = {
                    x: event.x,
                    y: event.y,
                    pressure: event.pressure
                };
                p.onDraw(event);
            }
        });
        this.pointer = null;
        this.isDrawing = false;
        this.inputProcessorObj = {
            draw: {
                onPointer: (val)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Draw);
                    const comboStr = this.keyListener.getComboStr();
                    const event = {
                        scale: this.highResTransformObj.scale
                    };
                    event.shiftIsPressed = comboStr === "shift";
                    event.pressure = val.pressure;
                    event.isCoalesced = !!val.isCoalesced;
                    if (val.type === "pointerdown") {
                        this.isDrawing = true;
                        event.type = "down";
                    } else if (val.button) event.type = "move";
                    else if (val.type === "pointerup") {
                        this.isDrawing = false;
                        event.type = "up";
                        this.linetoolProcessor.process(event);
                        this.resetInputProcessor();
                        return;
                    } else return;
                    event.x = val.relX;
                    event.y = val.relY;
                    this.linetoolProcessor.process(event);
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            fill: {
                onPointer: (event)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Fill);
                    if (event.type === "pointerdown") {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        p.onFill(Math.floor(coord.x), Math.floor(coord.y));
                    } else if (event.type === "pointerup") {
                        this.resetInputProcessor();
                        return;
                    }
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            gradient: {
                onPointer: (event)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Gradient);
                    const coord = this.workspaceToCanvasCoord({
                        x: event.relX,
                        y: event.relY
                    });
                    if (event.type === "pointerdown") {
                        this.isDrawing = true;
                        p.onGradient("down", coord.x, coord.y, this.renderedTransformObj.angle);
                    } else if (event.type === "pointermove") p.onGradient("move", coord.x, coord.y, this.renderedTransformObj.angle);
                    else if (event.type === "pointerup") {
                        this.isDrawing = false;
                        p.onGradient("up", coord.x, coord.y, this.renderedTransformObj.angle);
                        this.resetInputProcessor();
                    }
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            text: {
                onPointer: (event)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Text);
                    if (event.type === "pointerdown") {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        p.onText(Math.floor(coord.x), Math.floor(coord.y), this.renderedTransformObj.angle);
                    } else if (event.type === "pointerup") {
                        this.resetInputProcessor();
                        return;
                    }
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            shape: {
                onPointer: (event)=>{
                    this.reqFrame();
                    this.updateCursor(TMode.Shape);
                    const coord = this.workspaceToCanvasCoord({
                        x: event.relX,
                        y: event.relY
                    });
                    if (event.type === "pointerdown") {
                        this.isDrawing = true;
                        p.onShape("down", coord.x, coord.y, this.renderedTransformObj.angle);
                    } else if (event.type === "pointermove") p.onShape("move", coord.x, coord.y, this.renderedTransformObj.angle);
                    else if (event.type === "pointerup") {
                        this.isDrawing = false;
                        p.onShape("up", coord.x, coord.y, this.renderedTransformObj.angle);
                        this.resetInputProcessor();
                    }
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            hand: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Hand);
                    if ([
                        "left",
                        "middle"
                    ].includes(event.button || "")) {
                        this.updateCursor(TMode.HandGrabbing);
                        this.targetTransformObj.x += event.dX;
                        this.targetTransformObj.y += event.dY;
                        this.highResTransformObj = (0, _bb.BB).copyObj(this.targetTransformObj);
                        this.doAnimateTranslate = false;
                        this.transformIsDirty = true;
                        this.reqFrame(true);
                    } else if (event.type === "pointerup") this.resetInputProcessor();
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            spaceHand: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Hand);
                    if ([
                        "left",
                        "middle"
                    ].includes(event.button || "")) {
                        this.updateCursor(TMode.HandGrabbing);
                        this.targetTransformObj.x += event.dX;
                        this.targetTransformObj.y += event.dY;
                        this.highResTransformObj = (0, _bb.BB).copyObj(this.targetTransformObj);
                        this.doAnimateTranslate = false;
                        this.transformIsDirty = true;
                        this.reqFrame(true);
                    }
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if (comboStr !== "space") this.resetInputProcessor();
                    else this.updateCursor(TMode.Hand);
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    this.resetInputProcessor();
                }
            },
            zoom: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Zoom);
                    if (event.button === "left" && !event.isCoalesced && event.dX != 0) {
                        const offsetX = event.pageX - event.relX;
                        const offsetY = event.pageY - event.relY;
                        this.internalZoomByStep(event.dX / 175, event.downPageX - offsetX, event.downPageY - offsetY);
                        this.highResTransformObj = (0, _bb.BB).copyObj(this.targetTransformObj);
                        this.lastRenderedState = -1;
                        this.reqFrame();
                        this.onViewChange({
                            changed: [
                                "scale"
                            ],
                            angle: this.targetTransformObj.angle,
                            scale: this.targetTransformObj.scale
                        });
                    }
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if (comboStr !== "z") this.resetInputProcessor();
                    else this.updateCursor(TMode.Zoom);
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    this.resetInputProcessor();
                }
            },
            picker: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Pick);
                    if ([
                        "left",
                        "right"
                    ].includes(event.button || "") && !event.isCoalesced || event.type === "pointerup") {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        const pickedColor = this.klCanvas.getColorAt(coord.x, coord.y);
                        p.onPick(pickedColor, event.type === "pointerup");
                        this.svgOverlay.updateColorPreview({
                            x: event.relX,
                            y: event.relY,
                            color: pickedColor,
                            isVisible: event.type !== "pointerup"
                        });
                        if (event.type === "pointerup") this.resetInputProcessor();
                    }
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{},
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyUp: (keyStr, event, oldComboStr)=>{}
            },
            altPicker: {
                onPointer: (event)=>{
                    this.updateCursor(TMode.Pick);
                    if ([
                        "left",
                        "right"
                    ].includes(event.button || "") && !event.isCoalesced || event.type === "pointerup") {
                        const coord = this.workspaceToCanvasCoord({
                            x: event.relX,
                            y: event.relY
                        });
                        const pickedColor = this.klCanvas.getColorAt(coord.x, coord.y);
                        p.onPick(pickedColor, event.type === "pointerup");
                        this.svgOverlay.updateColorPreview({
                            x: event.relX,
                            y: event.relY,
                            color: pickedColor,
                            isVisible: event.type !== "pointerup"
                        });
                    }
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if (comboStr !== "alt") this.resetInputProcessor();
                    else this.updateCursor(TMode.Pick);
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    this.resetInputProcessor();
                }
            },
            rotate: {
                onPointer: (event)=>{
                    this.updateCursor(event.button === "left" ? TMode.Rotating : TMode.Rotate);
                    if (event.type === "pointerdown" && event.button === "left") this.oldTransformObj = (0, _bb.BB).copyObj(this.targetTransformObj);
                    else if (event.button === "left" && !event.isCoalesced && this.oldTransformObj) {
                        const offsetX = event.pageX - event.relX;
                        const offsetY = event.pageY - event.relY;
                        //rotation done around center
                        const centerObj = {
                            x: this.renderWidth / 2,
                            y: this.renderHeight / 2
                        };
                        const startAngleRad = (0, _bb.BB).Vec2.angle(centerObj, {
                            x: event.downPageX - offsetX,
                            y: event.downPageY - offsetY
                        });
                        const angleRad = (0, _bb.BB).Vec2.angle(centerObj, {
                            x: event.pageX - offsetX,
                            y: event.pageY - offsetY
                        });
                        let dAngleRad = angleRad - startAngleRad;
                        //apply angle
                        this.targetTransformObj = (0, _bb.BB).copyObj(this.oldTransformObj);
                        this.targetTransformObj.angle += dAngleRad;
                        if (this.keyListener.isPressed("shift")) {
                            this.targetTransformObj.angle = Math.round(this.targetTransformObj.angle / Math.PI * 8) * Math.PI / 8; //snap the angle to 45/2 degs
                            dAngleRad = this.targetTransformObj.angle - this.oldTransformObj.angle;
                        }
                        this.targetTransformObj.angle = this.minimizeAngleRad(this.targetTransformObj.angle);
                        //rotate transform.xy
                        let matrix = (0, _bb.BB).Matrix.getIdentity();
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(centerObj.x, centerObj.y));
                        //matrix = BB.Matrix.multiplyMatrices(matrix, BB.Matrix.createScaleMatrix(effectiveFactor));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(dAngleRad));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-centerObj.x, -centerObj.y));
                        //matrix = multiplyMatrices(matrix, createTranslationMatrix(val.x - val.startX, val.y - val.startY));
                        let origin = [
                            this.targetTransformObj.x,
                            this.targetTransformObj.y,
                            0,
                            1
                        ];
                        origin = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, origin);
                        this.targetTransformObj.x = origin[0];
                        this.targetTransformObj.y = origin[1];
                        this.highResTransformObj = (0, _bb.BB).copyObj(this.targetTransformObj);
                        this.transformIsDirty = true;
                        this.lastRenderedState = -1;
                        this.reqFrame();
                        this.onViewChange({
                            changed: [
                                "angle"
                            ],
                            scale: this.targetTransformObj.scale,
                            angle: this.targetTransformObj.angle
                        });
                    }
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyDown: (keyStr, event, comboStr, isRepeat)=>{
                    if ([
                        "r",
                        "r+shift",
                        "shift+r",
                        "r+left",
                        "r+right",
                        "r+left+right",
                        "r+right+left",
                        "r+up"
                    ].includes(comboStr)) this.updateCursor(TMode.Rotate);
                    else this.resetInputProcessor();
                },
                // eslint-disable-next-line @typescript-eslint/no-unused-vars
                onKeyUp: (keyStr, event, oldComboStr)=>{
                    const comboStr = this.keyListener.getComboStr();
                    if ([
                        "r",
                        "r+shift",
                        "shift+r",
                        "r+left",
                        "r+right",
                        "r+left+right",
                        "r+right+left",
                        "r+up"
                    ].includes(comboStr)) this.updateCursor(TMode.Rotate);
                    else this.resetInputProcessor();
                }
            }
        };
        this.currentInputProcessor = null;
        this.angleIsExtraSticky = false;
        this.pinchZoomer = new (0, _bb.BB).PinchZoomer({
            onPinch: (event)=>{
                if (event.type === "move") {
                    if (!this.oldTransformObj) {
                        this.oldTransformObj = (0, _bb.BB).copyObj(this.targetTransformObj);
                        this.angleIsExtraSticky = this.targetTransformObj.angle % (Math.PI / 2) === 0;
                    }
                    this.targetTransformObj = (0, _bb.BB).copyObj(this.oldTransformObj);
                    event.scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, this.targetTransformObj.scale * event.scale)) / this.targetTransformObj.scale;
                    this.targetTransformObj.scale *= event.scale;
                    this.targetTransformObj.angle += event.angleRad;
                    this.targetTransformObj.angle = this.minimizeAngleRad(this.snapAngleRad(this.targetTransformObj.angle, 90, this.angleIsExtraSticky ? 12 : 4));
                    if (this.targetTransformObj.angle % (Math.PI / 2) !== 0) this.angleIsExtraSticky = false;
                    //targetTransformObj.angle = minimizeAngleRad(snapAngleRad(targetTransformObj.angle, 90, 7));
                    event.angleRad = this.targetTransformObj.angle - this.oldTransformObj.angle;
                    //calc translation
                    {
                        let matrix = (0, _bb.BB).Matrix.getIdentity();
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(event.relX, event.relY));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createScaleMatrix(event.scale));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(event.angleRad));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-event.relX, -event.relY));
                        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(event.relX - event.downRelX, event.relY - event.downRelY));
                        let origin = [
                            this.targetTransformObj.x,
                            this.targetTransformObj.y,
                            0,
                            1
                        ];
                        origin = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, origin);
                        this.targetTransformObj.x = origin[0];
                        this.targetTransformObj.y = origin[1];
                    }
                    this.highResTransformObj = (0, _bb.BB).copyObj(this.targetTransformObj);
                    //if (event.scale !== 1) {
                    this.onViewChange({
                        changed: [
                            "scale",
                            "angle"
                        ],
                        scale: this.targetTransformObj.scale,
                        angle: this.targetTransformObj.angle
                    });
                    //}
                    this.reqFrame();
                    this.transformIsDirty = true;
                    this.lastRenderedState = -1;
                } else if (event.type === "end") this.oldTransformObj = null;
            }
        });
        const onDoubleTap = (event)=>{
            if (this.fitView(true)) {
                this.lastRenderedState = -1;
                this.reqFrame();
            } else {
                // zoom 2 steps further
                const didZoom = this.internalZoomByStep(2, event.relX, event.relY);
                if (didZoom) this.onViewChange({
                    changed: [
                        "scale"
                    ],
                    angle: this.targetTransformObj.angle,
                    scale: this.targetTransformObj.scale
                });
                //updateCursor(TMode.Draw, true);
                this.lastRenderedState = -1;
            }
        };
        this.mainDoubleTapper = new (0, _bb.BB).DoubleTapper({
            onDoubleTap
        });
        this.middleDoubleTapper = new (0, _bb.BB).DoubleTapper({
            onDoubleTap
        });
        this.middleDoubleTapper.setAllowedButtonArr([
            "middle"
        ]);
        this.twoFingerTap = new (0, _bb.BB).NFingerTapper({
            fingers: 2,
            onTap: ()=>{
                p.onUndo();
            }
        });
        this.threeFingerTap = new (0, _bb.BB).NFingerTapper({
            fingers: 3,
            onTap: ()=>{
                p.onRedo();
            }
        });
        this.pointerEventChain = new (0, _bb.BB).EventChain({
            chainArr: [
                this.twoFingerTap,
                this.threeFingerTap,
                this.mainDoubleTapper,
                this.middleDoubleTapper,
                this.pinchZoomer,
                new (0, _bb.BB).OnePointerLimiter(),
                new (0, _bb.BB).CoalescedExploder()
            ]
        });
        this.pointerEventChain.setChainOut((event)=>{
            this.cursorPos.x = event.relX;
            this.cursorPos.y = event.relY;
            if (event.type === "pointerup" && event.pointerType === "touch") {
                this.pointer = null;
                this.lastRenderedState = -1;
                this.reqFrame();
            } else {
                if (!this.pointer) this.pointer = {
                    x: 0,
                    y: 0
                };
                this.pointer.x = event.relX;
                this.pointer.y = event.relY;
            }
            if (this.currentInputProcessor) this.currentInputProcessor.onPointer(event);
            else {
                const comboStr = this.keyListener.getComboStr();
                if (this.globalMode === TMode.Draw) {
                    if ([
                        "",
                        "shift",
                        "ctrl"
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "left") {
                        this.currentInputProcessor = this.inputProcessorObj.draw;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Draw);
                        this.reqFrame();
                    }
                } else if (this.globalMode === TMode.Hand) {
                    if (event.type === "pointerdown" && [
                        "left",
                        "middle"
                    ].includes(event.button || "")) {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else this.updateCursor(TMode.Hand);
                } else if (this.globalMode === TMode.Pick) {
                    if (event.type === "pointerdown" && [
                        "left",
                        "right"
                    ].includes(event.button || "")) {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else this.updateCursor(TMode.Pick);
                } else if (this.globalMode === TMode.Fill) {
                    if (event.type === "pointerdown" && event.button === "left") {
                        this.currentInputProcessor = this.inputProcessorObj.fill;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Fill);
                        this.reqFrame();
                    }
                } else if (this.globalMode === TMode.Gradient) {
                    if ([
                        "",
                        "shift",
                        "ctrl"
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "left") {
                        this.currentInputProcessor = this.inputProcessorObj.gradient;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Gradient);
                        this.reqFrame();
                    }
                } else if (this.globalMode === TMode.Text) {
                    if (event.type === "pointerdown" && event.button === "left") {
                        this.currentInputProcessor = this.inputProcessorObj.text;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Text);
                        this.reqFrame();
                    }
                } else if (this.globalMode === TMode.Shape) {
                    if ([
                        "",
                        "shift",
                        "ctrl"
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "left") {
                        this.currentInputProcessor = this.inputProcessorObj.shape;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "right") {
                        this.currentInputProcessor = this.inputProcessorObj.picker;
                        this.currentInputProcessor.onPointer(event);
                    } else if ([
                        ""
                    ].includes(comboStr) && event.type === "pointerdown" && event.button === "middle") {
                        this.currentInputProcessor = this.inputProcessorObj.hand;
                        this.currentInputProcessor.onPointer(event);
                    } else {
                        this.updateCursor(TMode.Shape);
                        this.reqFrame();
                    }
                }
            }
        });
        //prevent ctrl scroll -> zooming page
        this.rootEl.addEventListener("wheel", (event)=>{
            event.preventDefault();
        });
        setTimeout(()=>{
            this.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.rootEl,
                fixScribble: true,
                onPointer: (e)=>{
                    if (e.type === "pointerdown" && e.button === "middle") try {
                        e.eventPreventDefault();
                    } catch (e) {
                    /* empty */ }
                    // prevent manual slider input keeping focus on iPad
                    if (e.type === "pointerdown") (0, _bb.BB).unfocusAnyInput();
                    /*if (e.type === 'pointermove') {
                        BB.throwOut(JSON.stringify(e));
                    }*/ this.pointerEventChain.chainIn(e);
                },
                onWheel: (wheelEvent)=>{
                    if (this.isDrawing) return;
                    this.reqFrame();
                    const didZoom = this.internalZoomByStep(-wheelEvent.deltaY / (this.keyListener.isPressed("shift") ? 8 : 2), wheelEvent.relX, wheelEvent.relY);
                    if (didZoom) this.onViewChange({
                        changed: [
                            "scale"
                        ],
                        angle: this.targetTransformObj.angle,
                        scale: this.targetTransformObj.scale
                    });
                    //updateCursor(TMode.Draw, true);
                    this.lastRenderedState = -1;
                },
                onEnterLeave: (isOver)=>{
                    if (!isOver) {
                        if (!this.isDrawing) {
                            this.pointer = null;
                            this.lastRenderedState = -1;
                        }
                    }
                },
                maxPointers: 4
            });
        }, 1);
        this.brushRadius = 1;
        this.animationFrameRequested = false;
        //setup rendering
        this.lastRenderedState = -2;
        this.lastRenderTime = performance.now();
        window.requestAnimationFrame(()=>this.updateLoop());
        this.resetOrFitView();
    }
    getElement() {
        return this.rootEl;
    }
    setCanvas(klC) {
        this.klCanvas = klC;
        this.lastDrawEvent = null;
        this.resetView();
        this.updateChangeListener();
        this.lastRenderedState = -1;
        this.reqFrame();
    }
    /**
     * set size of workspace area in pixels
     * @param width
     * @param height
     */ setSize(width, height) {
        const oldWidth = this.renderWidth;
        const oldHeight = this.renderHeight;
        if (width === oldWidth && height === oldHeight) return;
        this.doResizeCanvas = true;
        this.renderWidth = width;
        this.renderHeight = height;
        this.svgOverlay.setSize(width, height);
        this.targetTransformObj.x += (width - oldWidth) / 2;
        this.targetTransformObj.y += (height - oldHeight) / 2;
        this.highResTransformObj.x = this.targetTransformObj.x;
        this.highResTransformObj.y = this.targetTransformObj.y;
        this.bgVisible = this.testBgVisible();
        this.lastRenderedState = -1;
        this.reqFrame();
    }
    setMode(modeStr) {
        //only sets the base mode
        if (modeStr === "draw") {
            this.globalMode = TMode.Draw;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (modeStr === "fill") {
            this.globalMode = TMode.Fill;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (modeStr === "gradient") {
            this.globalMode = TMode.Gradient;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (modeStr === "text") {
            this.globalMode = TMode.Text;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (modeStr === "shape") {
            this.globalMode = TMode.Shape;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
        if (modeStr === "hand") {
            this.globalMode = TMode.Hand;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "mouse",
                "pen",
                "touch"
            ]);
        }
        if (modeStr === "pick") {
            this.globalMode = TMode.Pick;
            this.mainDoubleTapper.setAllowedPointerTypeArr([
                "touch"
            ]);
        }
    }
    getMode() {
        if (this.globalMode === TMode.Draw) return "draw";
        if (this.globalMode === TMode.Fill) return "fill";
        if (this.globalMode === TMode.Gradient) return "gradient";
        if (this.globalMode === TMode.Text) return "text";
        if (this.globalMode === TMode.Shape) return "shape";
        if (this.globalMode === TMode.Hand) return "hand";
        if (this.globalMode === TMode.Pick) return "pick";
        throw new Error("unknown globalMode");
    }
    setCursorSize(diameter) {
        this.brushRadius = diameter / 2;
        this.svgOverlay.updateCursor({
            radius: this.brushRadius * this.highResTransformObj.scale
        });
        if (this.pointer === null) {
            this.hideBrushCursorTimeout && clearTimeout(this.hideBrushCursorTimeout);
            this.svgOverlay.updateCursor({
                x: this.renderWidth / 2,
                y: this.renderHeight / 2,
                isVisible: true
            });
            this.hideBrushCursorTimeout = setTimeout(()=>{
                if (this.pointer !== null) return;
                this.svgOverlay.updateCursor({
                    isVisible: false
                });
            }, 500);
        }
    }
    zoomByStep(stepNum) {
        if (!this.internalZoomByStep(stepNum, this.renderWidth / 2, this.renderHeight / 2)) return;
        this.lastRenderedState = -1;
        this.reqFrame();
        this.onViewChange({
            changed: [
                "scale"
            ],
            angle: this.targetTransformObj.angle,
            scale: this.targetTransformObj.scale
        });
    }
    resetView(doAnimate) {
        this.targetTransformObj.scale = 1;
        this.targetTransformObj.angle = 0;
        this.targetTransformObj.x = (this.renderWidth - this.klCanvas.getWidth()) / 2;
        this.targetTransformObj.y = (this.renderHeight - this.klCanvas.getHeight()) / 2;
        if (doAnimate) {
            this.doAnimateTranslate = true;
            this.transformIsDirty = true;
        } else this.highResTransformObj = (0, _bb.BB).copyObj(this.targetTransformObj);
        this.bgVisible = this.testBgVisible();
        this.reqFrame();
        if (doAnimate) this.onViewChange({
            changed: [
                "scale",
                "angle"
            ],
            scale: this.targetTransformObj.scale,
            angle: this.targetTransformObj.angle
        });
    }
    /**
     * fit into view. center. snap angle. padding
     * returns true if transform changes
     */ fitView(doAnimate) {
        // determine new transform
        const newAngle = this.snapAngleRad(this.targetTransformObj.angle, 90, 90);
        //calc width and height of bounds
        const canvasPointsArr = [
            [
                0,
                0
            ],
            [
                this.klCanvas.getWidth(),
                0
            ],
            [
                this.klCanvas.getWidth(),
                this.klCanvas.getHeight()
            ],
            [
                0,
                this.klCanvas.getHeight()
            ],
            [
                this.klCanvas.getWidth() / 2,
                this.klCanvas.getHeight() / 2
            ]
        ];
        //setup transformation matrix
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(newAngle));
        //rotate points
        for(let i = 0; i < canvasPointsArr.length; i++){
            let coords = [
                canvasPointsArr[i][0],
                canvasPointsArr[i][1],
                0,
                1
            ];
            coords = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, coords);
            canvasPointsArr[i][0] = coords[0];
            canvasPointsArr[i][1] = coords[1];
        }
        const boundsObj = {};
        for(let i = 0; i < canvasPointsArr.length; i++){
            if (boundsObj.x1 === undefined || canvasPointsArr[i][0] < boundsObj.x1) boundsObj.x1 = canvasPointsArr[i][0];
            if (boundsObj.y1 === undefined || canvasPointsArr[i][1] < boundsObj.y1) boundsObj.y1 = canvasPointsArr[i][1];
            if (boundsObj.x2 === undefined || canvasPointsArr[i][0] > boundsObj.x2) boundsObj.x2 = canvasPointsArr[i][0];
            if (boundsObj.y2 === undefined || canvasPointsArr[i][1] > boundsObj.y2) boundsObj.y2 = canvasPointsArr[i][1];
        }
        const boundsWidth = boundsObj.x2 - boundsObj.x1;
        const boundsHeight = boundsObj.y2 - boundsObj.y1;
        //fit bounds
        const padding = 0;
        const { width: fitWidth } = (0, _bb.BB).fitInto(boundsWidth, boundsHeight, this.renderWidth - padding, this.renderHeight - padding, 1);
        //determine scale
        const factor = Math.min(MAX_SCALE, fitWidth / boundsWidth);
        const newTargetTransformObj = {
            angle: newAngle,
            x: this.renderWidth / 2 - (canvasPointsArr[4][0] - canvasPointsArr[0][0]) * factor,
            y: this.renderHeight / 2 - (canvasPointsArr[4][1] - canvasPointsArr[0][1]) * factor,
            scale: factor
        };
        if (newTargetTransformObj.angle === this.targetTransformObj.angle && Math.abs(newTargetTransformObj.x - this.targetTransformObj.x) < 0.0000000001 && Math.abs(newTargetTransformObj.y - this.targetTransformObj.y) < 0.0000000001 && newTargetTransformObj.scale === this.targetTransformObj.scale) return false;
        this.targetTransformObj = newTargetTransformObj;
        if (doAnimate) this.doAnimateTranslate = true;
        else this.highResTransformObj = (0, _bb.BB).copyObj(this.targetTransformObj);
        this.transformIsDirty = true;
        this.reqFrame();
        if (doAnimate) this.onViewChange({
            changed: [
                "scale",
                "angle"
            ],
            scale: this.targetTransformObj.scale,
            angle: this.targetTransformObj.angle
        });
        return true;
    }
    /**
     * let the workspace decide what is best. E.g. if it's pixel art, Fit might be better.
     */ resetOrFitView() {
        const threshold = 4; // >= 400% zoom. pixelated, not blurry
        if (!(0, _klConfig.klConfig).disableAutoFit && this.klCanvas.getWidth() <= this.renderWidth / threshold && this.klCanvas.getHeight() <= this.renderHeight / threshold) this.fitView();
        else this.resetView();
    }
    setAngle(angleDeg, isRelative) {
        //rotation done around center
        const centerObj = {
            x: this.renderWidth / 2,
            y: this.renderHeight / 2
        };
        const oldAngleRad = this.targetTransformObj.angle;
        const angleRad = angleDeg / 180 * Math.PI;
        if (isRelative) this.targetTransformObj.angle += angleRad;
        else this.targetTransformObj.angle = angleRad;
        this.targetTransformObj.angle = this.minimizeAngleRad(this.snapAngleRad(this.targetTransformObj.angle, 90, 4));
        //rotate transform.xy
        let matrix = (0, _bb.BB).Matrix.getIdentity();
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(centerObj.x, centerObj.y));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createRotationMatrix(this.targetTransformObj.angle - oldAngleRad));
        matrix = (0, _bb.BB).Matrix.multiplyMatrices(matrix, (0, _bb.BB).Matrix.createTranslationMatrix(-centerObj.x, -centerObj.y));
        let origin = [
            this.targetTransformObj.x,
            this.targetTransformObj.y,
            0,
            1
        ];
        origin = (0, _bb.BB).Matrix.multiplyMatrixAndPoint(matrix, origin);
        this.targetTransformObj.x = origin[0];
        this.targetTransformObj.y = origin[1];
        this.highResTransformObj = (0, _bb.BB).copyObj(this.targetTransformObj);
        this.transformIsDirty = true;
        this.reqFrame(true);
    }
    /**
     * translate canvas by viewport pixels
     * @param tx
     * @param ty
     */ translateView(tx, ty) {
        const scale = 40;
        this.targetTransformObj.x += tx * scale;
        this.targetTransformObj.y += ty * scale;
        this.transformIsDirty = true;
        this.doAnimateTranslate = true;
        this.reqFrame(true);
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    getScale() {
        return this.targetTransformObj.scale;
    }
    getAngleDeg() {
        return this.targetTransformObj.angle * 180 / Math.PI;
    }
    getMaxScale() {
        return MAX_SCALE;
    }
    getMinScale() {
        return MIN_SCALE;
    }
    requestFrame() {
        this.lastRenderedState = -1;
        this.reqFrame();
    }
    setLastDrawEvent(x, y, pressure) {
        if (x === undefined) {
            this.lastDrawEvent = null;
            return;
        }
        if (!this.lastDrawEvent) this.lastDrawEvent = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastDrawEvent.x = x;
        this.lastDrawEvent.y = y;
        this.lastDrawEvent.pressure = pressure;
    }
}

},{"../../bb/bb":"dcQKo","./workspace-svg-overlay":"kspFU","../history/kl-history":"klzEn","/src/app/img/ui/cursor-picker.png":"ccCXg","/src/app/img/ui/cursor-zoom-ew.png":"aY2N1","/src/app/img/ui/cursor-fill.png":"hniqd","/src/app/img/ui/cursor-text.png":"bHJ4v","../kl":"8nmWp","../events/linetool-processor":"f6xn7","../../theme/theme":"4G3JB","../kl-config":"argRu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ccCXg":[function(require,module,exports) {
module.exports = require("a79944fead32bf90").getBundleURL("d3gnI") + "cursor-picker.2dc5b283.png" + "?" + Date.now();

},{"a79944fead32bf90":"lgJ39"}],"aY2N1":[function(require,module,exports) {
module.exports = require("b370081f76893b60").getBundleURL("d3gnI") + "cursor-zoom-ew.3e31c6b3.png" + "?" + Date.now();

},{"b370081f76893b60":"lgJ39"}],"hniqd":[function(require,module,exports) {
module.exports = require("6ea8847786d1d12e").getBundleURL("d3gnI") + "cursor-fill.d01bd02c.png" + "?" + Date.now();

},{"6ea8847786d1d12e":"lgJ39"}],"bHJ4v":[function(require,module,exports) {
module.exports = require("2bebe1867e1ec38f").getBundleURL("d3gnI") + "cursor-text.543fd55c.png" + "?" + Date.now();

},{"2bebe1867e1ec38f":"lgJ39"}],"f6xn7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Not really and event chain element. but pretty similar.
 *
 * Processes draw input events. When shift held -> linetool
 * line events - what KlCanvasWorkspace passes onDraw(e)
 *
 * pass input in with process(drawEvent)
 *
 * modifies draw event to include such events:
 * {
 *     type: 'line',
 *     x0: null, // you have to fill that in
 *     y0: null, // you have to fill that in
 *     pressure0: null, // you have to fill that in
 *     x1: number,
 *     y1: number,
 *     pressure1: number
 * }
 */ parcelHelpers.export(exports, "LinetoolProcessor", ()=>LinetoolProcessor);
var _bb = require("../../bb/bb");
const DIR_X = 0;
const DIR_Y = 1;
class LinetoolProcessor {
    // --- public ---
    constructor(p){
        this.downEvent = null;
        this.eventQueue = [];
        this.direction = null;
        this.onDraw = p.onDraw;
    }
    process(event) {
        if (event.type === "down") {
            this.downEvent = event;
            this.direction = null;
            if (event.shiftIsPressed) {
                this.onDraw({
                    type: "line",
                    x0: null,
                    y0: null,
                    pressure0: null,
                    x1: event.x,
                    y1: event.y,
                    pressure1: event.pressure
                });
                this.eventQueue.push(event);
                return;
            }
        }
        if (event.type === "move" && this.downEvent) {
            if (event.shiftIsPressed) {
                if (this.direction === null) {
                    const dX = Math.abs(event.x - this.downEvent.x);
                    const dY = Math.abs(event.y - this.downEvent.y);
                    if (dX > 5 || dY > 5) {
                        this.direction = dX > dY ? DIR_X : DIR_Y;
                        for(let i = 0; i < this.eventQueue.length; i++){
                            const e = this.eventQueue[i];
                            if (e.type !== "up") {
                                if (this.direction === DIR_X) e.y = this.downEvent.y;
                                else e.x = this.downEvent.x;
                            }
                            this.onDraw((0, _bb.BB).copyObj(e));
                        }
                        this.eventQueue = [];
                    }
                }
                if (this.direction === null) {
                    this.eventQueue.push(event);
                    return;
                }
                if (this.direction === DIR_X) event.y = this.downEvent.y;
                else event.x = this.downEvent.x;
            } else if (this.eventQueue.length > 0) {
                for(let i = 0; i < this.eventQueue.length; i++)this.onDraw((0, _bb.BB).copyObj(this.eventQueue[i]));
                this.eventQueue = [];
            }
        }
        if (event.type === "up") {
            this.eventQueue = [];
            this.downEvent = null;
        }
        this.onDraw((0, _bb.BB).copyObj(event));
    }
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"argRu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "klConfig", ()=>klConfig);
const klConfig = {
    filenameBase: "Klecks"
};

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gRZnS":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * preview of image with layers. can do mix modes and opacity.
 * creates a canvas.
 */ parcelHelpers.export(exports, "KlCanvasPreview", ()=>KlCanvasPreview);
var _bb = require("../../bb/bb");
var _theme = require("../../theme/theme");
class KlCanvasPreview {
    // --- public ---
    constructor(p){
        this.layers = p.layers;
        const scale = p.width / p.layers[0].image.width;
        const width = scale > 1 ? p.layers[0].image.width : p.width;
        const height = scale > 1 ? p.layers[0].image.height : p.height;
        this.canvas = (0, _bb.BB).canvas(width, height);
        this.updateCheckerboard = ()=>{
            this.canvas.style.backgroundImage = "url(" + (0, _bb.BB).createCheckerDataUrl(8, undefined, (0, _theme.theme).isDark()) + ")";
        };
        this.updateCheckerboard();
        this.ctx = (0, _bb.BB).ctx(this.canvas);
        (0, _bb.BB).css(this.canvas, {
            width: "100%",
            height: "100%",
            imageRendering: scale > 1 ? "pixelated" : undefined
        });
        setTimeout(()=>this.render(), 0);
        (0, _theme.theme).addIsDarkListener(this.updateCheckerboard);
    }
    getElement() {
        return this.canvas;
    }
    render() {
        if (!this.ctx) return;
        this.ctx.save();
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for(let i = 0; i < this.layers.length; i++){
            const layer = this.layers[i];
            if (!layer.isVisible || layer.opacity === 0) continue;
            this.ctx.globalAlpha = this.layers[i].opacity;
            this.ctx.globalCompositeOperation = this.layers[i].mixModeStr;
            if (this.canvas.width > this.layers[i].image.width) this.ctx.imageSmoothingEnabled = false;
            this.ctx.drawImage(this.layers[i].image, 0, 0, this.canvas.width, this.canvas.height);
        }
        this.ctx.restore();
    }
    destroy() {
        (0, _theme.theme).removeIsDarkListener(this.updateCheckerboard);
    }
}

},{"../../bb/bb":"dcQKo","../../theme/theme":"4G3JB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"izcGJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Free Transform UI
 * rotate, scale, translate
 *
 * - if rotation is multiple of 90° it will snap to pixels, to be more useful for pixel art
 * - when rotation goes from non-multiple of 90° to a multiple, it will snap position and width height to pixels
 * - transform.x, transform.y can sit between pixels (by 0.5) if width or height is odd number.
 *      - this is what complicates things
 * - if transform region small, corner grips move out of the way
 *
 * iX iY, iP.x, iP.y - i indicates image space
 * tX tY, tP.x, tP.y - t indicates transform space
 *
 * Not sure if it can be used for navigable canvas. (especially if canvas rotates view)
 * Probably can't be extended for distort. Needs a different approach.
 *
 * --- DOM structure ---
 * rootEl {
 * 	transEl [
 * 		boundsEl
 * 		edges[]
 * 		corners[] - round grips in the corner of transform region
 * 		angleGrip
 * 	]
 * }
 *
 */ parcelHelpers.export(exports, "FreeTransform", ()=>FreeTransform);
var _bb = require("../../../bb/bb");
var _cursorRotatePng = require("/src/app/img/ui/cursor-rotate.png");
var _cursorRotatePngDefault = parcelHelpers.interopDefault(_cursorRotatePng);
var _freeTransformUtils = require("./free-transform-utils");
class FreeTransform {
    updateScaled() {
        this.scaled.x = this.value.x * this.viewportTransform.scale;
        this.scaled.y = this.value.y * this.viewportTransform.scale;
        this.scaled.width = this.value.width * this.viewportTransform.scale;
        this.scaled.height = this.value.height * this.viewportTransform.scale;
        this.scaled.corners = this.corners.map((item)=>{
            return {
                x: item.x * this.viewportTransform.scale,
                y: item.y * this.viewportTransform.scale
            };
        });
    }
    /**
     * Returns snapped point, if ix, iy snaps. If no snapping, returns point unchanged.
     * both in image space
     *
     * @param iX - image space
     * @param iY - image space
     * @private
     */ snapCorner(iX, iY) {
        if (!this.snappingEnabled) return {
            x: iX,
            y: iY
        };
        let dist;
        const snap = {
            x: undefined,
            y: undefined,
            dist: {
                x: undefined,
                y: undefined
            }
        };
        for(let e = 0; e < this.snapX.length; e++){
            dist = Math.abs(iX - this.snapX[e]);
            if (dist < this.minSnapDist / this.viewportTransform.scale) {
                if (snap.x === undefined || dist < snap.dist.x) {
                    snap.x = this.snapX[e];
                    snap.dist.x = dist;
                }
            }
        }
        for(let e = 0; e < this.snapY.length; e++){
            dist = Math.abs(iY - this.snapY[e]);
            if (dist < this.minSnapDist / this.viewportTransform.scale) {
                if (snap.y === undefined || dist < snap.dist.y) {
                    snap.y = this.snapY[e];
                    snap.dist.y = dist;
                }
            }
        }
        if (snap.x === undefined && snap.y === undefined) return {
            x: iX,
            y: iY
        };
        return {
            x: snap.x ?? iX,
            y: snap.y ?? iY
        };
    }
    /**
     * If constrained return nearest corner pos that fits aspect ratio
     *
     * @param cornerIndex
     * @param iX
     * @param iY
     * @private
     */ constrainCorner(cornerIndex, iX, iY) {
        if (!this.isConstrained) return {
            x: iX,
            y: iY
        };
        const flip = this.value.width * this.value.height < 0 ? -1 : 1;
        return (0, _bb.BB).projectPointOnLine({
            x: this.value.x,
            y: this.value.y
        }, (0, _freeTransformUtils.toImageSpace)(this.ratio, flip * ([
            0,
            2
        ].includes(cornerIndex) ? 1 : -1), this.value), {
            x: iX,
            y: iY
        });
    }
    /**
     * Update corners according to width height.
     * Not their DOM.
     */ updateCornerPositions() {
        this.corners[0].x = -this.value.width / 2; // top left
        this.corners[0].y = -this.value.height / 2;
        this.corners[1].x = this.value.width / 2; // top right
        this.corners[1].y = -this.value.height / 2;
        this.corners[2].x = this.value.width / 2; // bottom right
        this.corners[2].y = this.value.height / 2;
        this.corners[3].x = -this.value.width / 2; // bottom left
        this.corners[3].y = this.value.height / 2;
    }
    /**
     * If constrained and dragging an edge, restore aspect ratio
     * Updates corner positions.
     *
     * @param widthChanged
     * @param heightChanged
     * @private
     */ restoreRatio(widthChanged, heightChanged) {
        if (!this.isConstrained) return;
        const angle90 = Math.abs(this.value.angleDeg) % 90 === 0;
        const whSwapped = Math.abs(this.value.angleDeg - 90) % 180 === 0;
        if (heightChanged && !widthChanged) {
            const newHeight = Math.abs(this.corners[3].y - this.corners[0].y);
            let newWidth = this.ratio * newHeight;
            if (angle90) newWidth = (whSwapped ? this.value.y % 1 : this.value.x % 1) === 0 ? (0, _bb.BB).roundEven(newWidth) : (0, _bb.BB).roundUneven(newWidth);
            if (this.corners[1].x - this.corners[0].x < 0) newWidth *= -1;
            this.corners[0].x = -newWidth / 2;
            this.corners[3].x = -newWidth / 2;
            this.corners[1].x = newWidth / 2;
            this.corners[2].x = newWidth / 2;
        }
        if (!heightChanged && widthChanged) {
            const newWidth = Math.abs(this.corners[0].x - this.corners[1].x);
            let newHeight = newWidth / this.ratio;
            if (angle90) newHeight = (whSwapped ? this.value.x % 1 : this.value.y % 1) === 0 ? (0, _bb.BB).roundEven(newHeight) : (0, _bb.BB).roundUneven(newHeight);
            if (this.corners[3].y - this.corners[0].y < 0) newHeight *= -1;
            this.corners[0].y = -newHeight / 2;
            this.corners[1].y = -newHeight / 2;
            this.corners[2].y = newHeight / 2;
            this.corners[3].y = newHeight / 2;
        }
    }
    /**
     * update transform based on corners
     * @private
     */ updateTransformViaCorners() {
        // calc transform center in image space
        const rot = (0, _bb.BB).rotateAround({
            x: 0,
            y: 0
        }, {
            x: (this.corners[0].x + this.corners[1].x) / 2,
            y: (this.corners[0].y + this.corners[3].y) / 2
        }, this.value.angleDeg);
        this.value.x = rot.x + this.value.x;
        this.value.y = rot.y + this.value.y;
        // update size
        this.value.width = this.corners[1].x - this.corners[0].x;
        this.value.height = this.corners[3].y - this.corners[0].y;
        // new center means corners changed their position
        this.updateCornerPositions();
        this.updateDOM();
    }
    /**
     * updates DOM according to transform
     * @param skipCallback
     */ updateDOM(skipCallback) {
        this.updateScaled();
        (0, _bb.BB).css(this.transEl, {
            left: this.viewportTransform.x + this.scaled.x + "px",
            top: this.viewportTransform.y + this.scaled.y + "px",
            transformOrigin: "0 0",
            transform: "rotate(" + this.value.angleDeg + "deg)"
        });
        (0, _bb.BB).css(this.boundsEl, {
            width: Math.abs(this.scaled.width) + "px",
            height: Math.abs(this.scaled.height) + "px",
            left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) + "px",
            top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) + "px"
        });
        this.corners[0].updateDOM();
        this.corners[1].updateDOM();
        this.corners[2].updateDOM();
        this.corners[3].updateDOM();
        this.edges[0].updateDOM();
        this.edges[1].updateDOM();
        this.edges[2].updateDOM();
        this.edges[3].updateDOM();
        this.angleGrip.x = 0;
        this.angleGrip.y = -Math.abs(this.value.height * this.viewportTransform.scale) / 2 - 20;
        this.angleGrip.updateDOM();
        if (!skipCallback) {
            if (this.callback) this.callback((0, _freeTransformUtils.copyTransform)(this.value));
        }
    }
    // --- public ---
    constructor(params){
        this.scaled = {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            corners: [
                {
                    x: 0,
                    y: 0
                }
            ]
        };
        this.minSnapDist = 7 // minimal snapping distance in px screen space
        ;
        this.cornerCursors = [
            "nw",
            "n",
            "ne",
            "e",
            "se",
            "s",
            "sw",
            "w"
        ];
        this.gripSize = 16;
        this.edgeSize = 10;
        this.corners = [];
        this.edges = [];
        this.viewportTransform = {
            ...params.viewportTransform
        };
        this.value = {
            x: params.x,
            y: params.y,
            width: params.width,
            height: params.height,
            angleDeg: params.angleDeg
        };
        this.isConstrained = params.isConstrained;
        this.snapX = params.snapX;
        this.snapY = params.snapY;
        this.callback = params.callback;
        this.snappingEnabled = true;
        this.ratio = this.value.width / this.value.height;
        this.rootEl = (0, _bb.BB).el({
            className: "kl-free-transform",
            css: {
                userSelect: "none"
            }
        });
        this.transEl = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                position: "absolute"
            }
        });
        this.boundsEl = (0, _bb.BB).el({
            css: {
                position: "absolute",
                cursor: "move",
                boxShadow: "rgba(255, 255, 255, 0.5) 0 0 0 1px inset, rgba(0, 0, 0, 0.5) 0 0 0 1px"
            }
        });
        const pointerRemainder = {
            x: 0,
            y: 0
        };
        function resetRemainder() {
            pointerRemainder.x = 0;
            pointerRemainder.y = 0;
        }
        this.keyListener = new (0, _bb.BB).KeyListener({});
        let boundsStartP = {
            x: 0,
            y: 0
        };
        this.boundsPointerListener = new (0, _bb.BB).PointerListener({
            target: this.boundsEl,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointerdown") boundsStartP = {
                    x: this.value.x,
                    y: this.value.y
                };
                if (event.type === "pointermove" && event.button === "left") {
                    this.value.x = boundsStartP.x + (event.pageX - event.downPageX) / this.viewportTransform.scale;
                    this.value.y = boundsStartP.y + (event.pageY - event.downPageY) / this.viewportTransform.scale;
                    let dist;
                    let snap = {
                        distX: -1,
                        distY: -1
                    };
                    if (this.snappingEnabled) {
                        let i;
                        for(i = 0; i < this.snapX.length; i++){
                            dist = Math.abs(this.value.x - this.snapX[i]);
                            if (dist < this.minSnapDist / this.viewportTransform.scale) {
                                if (snap.x === undefined || dist < snap.distX) {
                                    snap.x = this.snapX[i];
                                    snap.distX = dist;
                                }
                            }
                        }
                        for(i = 0; i < this.snapY.length; i++){
                            dist = Math.abs(this.value.y - this.snapY[i]);
                            if (dist < this.minSnapDist / this.viewportTransform.scale) {
                                if (snap.y === undefined || dist < snap.distY) {
                                    snap.y = this.snapY[i];
                                    snap.distY = dist;
                                }
                            }
                        }
                        let iP;
                        for(i = 0; i < 4; i++){
                            iP = (0, _freeTransformUtils.toImageSpace)(this.corners[i].x, this.corners[i].y, this.value);
                            let j;
                            for(j = 0; j < this.snapX.length; j++){
                                dist = Math.abs(iP.x - this.snapX[j]);
                                if (dist < this.minSnapDist / this.viewportTransform.scale) {
                                    if (snap.x === undefined || dist < snap.distX) {
                                        snap.x = this.snapX[j] - (iP.x - this.value.x);
                                        snap.distX = dist;
                                    }
                                }
                            }
                            for(j = 0; j < this.snapY.length; j++){
                                dist = Math.abs(iP.y - this.snapY[j]);
                                if (dist < this.minSnapDist / this.viewportTransform.scale) {
                                    if (snap.y === undefined || dist < snap.distY) {
                                        snap.y = this.snapY[j] - (iP.y - this.value.y);
                                        snap.distY = dist;
                                    }
                                }
                            }
                        }
                    }
                    if (this.keyListener.getComboStr() === "shift") {
                        let projected = (0, _bb.BB).projectPointOnLine({
                            x: 0,
                            y: boundsStartP.y
                        }, {
                            x: 10,
                            y: boundsStartP.y
                        }, {
                            x: this.value.x,
                            y: this.value.y
                        });
                        let dist = (0, _bb.BB).dist(projected.x, projected.y, this.value.x, this.value.y);
                        snap = {
                            x: projected.x,
                            y: projected.y,
                            distX: dist,
                            distY: dist
                        };
                        projected = (0, _bb.BB).projectPointOnLine({
                            x: boundsStartP.x,
                            y: 0
                        }, {
                            x: boundsStartP.x,
                            y: 10
                        }, {
                            x: this.value.x,
                            y: this.value.y
                        });
                        dist = (0, _bb.BB).dist(projected.x, projected.y, this.value.x, this.value.y);
                        if (dist < snap.distX) snap = {
                            x: projected.x,
                            y: projected.y,
                            distX: dist,
                            distY: dist
                        };
                        projected = (0, _bb.BB).projectPointOnLine({
                            x: boundsStartP.x,
                            y: boundsStartP.y
                        }, {
                            x: boundsStartP.x + 1,
                            y: boundsStartP.y + 1
                        }, {
                            x: this.value.x,
                            y: this.value.y
                        });
                        dist = (0, _bb.BB).dist(projected.x, projected.y, this.value.x, this.value.y);
                        if (dist < snap.distX) snap = {
                            x: projected.x,
                            y: projected.y,
                            distX: dist,
                            distY: dist
                        };
                        projected = (0, _bb.BB).projectPointOnLine({
                            x: boundsStartP.x,
                            y: boundsStartP.y
                        }, {
                            x: boundsStartP.x + 1,
                            y: boundsStartP.y - 1
                        }, {
                            x: this.value.x,
                            y: this.value.y
                        });
                        dist = (0, _bb.BB).dist(projected.x, projected.y, this.value.x, this.value.y);
                        if (dist < snap.distX) snap = {
                            x: projected.x,
                            y: projected.y,
                            distX: dist,
                            distY: dist
                        };
                    }
                    if (snap.x != undefined) this.value.x = snap.x;
                    if (snap.y != undefined) this.value.y = snap.y;
                    // snap to pixels
                    if (Math.abs(this.value.angleDeg) % 90 === 0) {
                        (0, _freeTransformUtils.snapToPixel)(this.value);
                        this.updateCornerPositions();
                    }
                    this.updateDOM();
                }
            }
        });
        for(let i = 0; i < 4; i++)((i)=>{
            const g = this.corners[i] = {
                i: i,
                el: (0, _bb.BB).el({
                    css: {
                        width: this.gripSize + "px",
                        height: this.gripSize + "px",
                        background: "#fff",
                        /*background: [
                                '#ff0000',
                                '#00ff00',
                                '#0000ff',
                                '#ff00ff',
                            ][i],*/ borderRadius: this.gripSize + "px",
                        position: "absolute",
                        border: "2px solid #000"
                    }
                }),
                x: 0,
                y: 0,
                virtualPos: {
                    x: 0,
                    y: 0
                }
            };
            g.updateDOM = ()=>{
                // grip position
                // if it gets small: slightly offset grips, so easier to handle
                const offsetArr = [
                    [
                        -1,
                        -1
                    ],
                    [
                        1,
                        -1
                    ],
                    [
                        1,
                        1
                    ],
                    [
                        -1,
                        1
                    ]
                ].map((item)=>{
                    item[0] *= this.value.width > 0 ? 1 : -1;
                    item[1] *= this.value.height > 0 ? 1 : -1;
                    return item;
                });
                const tinyOffset = Math.abs(this.scaled.width) < 20 || Math.abs(this.scaled.height) < 20 ? 10 : 0;
                (0, _bb.BB).css(g.el, {
                    left: this.scaled.corners[g.i].x - this.gripSize / 2 + offsetArr[i][0] * tinyOffset + "px",
                    top: this.scaled.corners[g.i].y - this.gripSize / 2 + offsetArr[i][1] * tinyOffset + "px"
                });
                // cursor
                let angle = (0, _bb.BB).pointsToAngleDeg({
                    x: this.value.x,
                    y: this.value.y
                }, (0, _freeTransformUtils.toImageSpace)(g.x, g.y, this.value)) + 135; // offset so nw is 0
                while(angle < 0)angle += 360;
                const index = Math.round(angle / 45) % this.cornerCursors.length;
                (0, _bb.BB).css(g.el, {
                    cursor: this.cornerCursors[index] + "-resize"
                });
            };
            g.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.corners[i].el,
                fixScribble: true,
                onPointer: (event)=>{
                    event.eventPreventDefault();
                    if (event.type === "pointerdown" && event.button === "left") this.corners[i].virtualPos = (0, _freeTransformUtils.toImageSpace)(this.corners[i].x, this.corners[i].y, this.value);
                    else if (event.type === "pointermove" && event.button === "left") {
                        this.corners[i].virtualPos.x += event.dX / this.viewportTransform.scale;
                        this.corners[i].virtualPos.y += event.dY / this.viewportTransform.scale;
                        let iP = {
                            x: this.corners[i].virtualPos.x,
                            y: this.corners[i].virtualPos.y
                        };
                        iP = this.constrainCorner(i, iP.x, iP.y);
                        if (!this.isConstrained) iP = this.snapCorner(iP.x, iP.y);
                        if (Math.abs(this.value.angleDeg) % 90 === 0) {
                            iP.x = Math.round(iP.x);
                            iP.y = Math.round(iP.y);
                        }
                        const tP = (0, _freeTransformUtils.toTransformSpace)(iP.x, iP.y, this.value);
                        const dX = tP.x - this.corners[i].x;
                        const dY = tP.y - this.corners[i].y;
                        this.corners[i].x = tP.x;
                        this.corners[i].y = tP.y;
                        let indexes = [];
                        if (i === 0) indexes = [
                            3,
                            1,
                            2
                        ];
                        else if (i === 1) indexes = [
                            2,
                            0,
                            3
                        ];
                        else if (i === 2) indexes = [
                            1,
                            3,
                            0
                        ];
                        else if (i === 3) indexes = [
                            0,
                            2,
                            1
                        ];
                        this.corners[indexes[0]].x = this.corners[i].x;
                        this.corners[indexes[1]].y = this.corners[i].y;
                        if (this.keyListener.isPressed("shift")) {
                            this.corners[indexes[2]].x -= dX;
                            this.corners[indexes[2]].y -= dY;
                            this.corners[indexes[1]].x = this.corners[indexes[2]].x;
                            this.corners[indexes[0]].y = this.corners[indexes[2]].y;
                        }
                        this.updateTransformViaCorners();
                    }
                }
            });
        })(i);
        this.updateCornerPositions();
        this.updateScaled();
        let isInverted;
        for(let i = 0; i < 4; i++)((i)=>{
            this.edges[i] = {
                el: (0, _bb.BB).el({
                    css: {
                        width: this.edgeSize + "px",
                        height: this.edgeSize + "px",
                        /*background: [
                                '#ff000044',
                                '#00ff0044',
                                '#0000ff44',
                                '#ff00ff44',
                            ][i],*/ position: "absolute"
                    }
                })
            };
            const g = this.edges[i];
            g.updateDOM = ()=>{
                if (i === 0) (0, _bb.BB).css(g.el, {
                    left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) + "px",
                    top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) - this.edgeSize + "px",
                    width: Math.abs(this.scaled.width) + "px",
                    height: this.edgeSize + "px"
                });
                else if (i === 1) (0, _bb.BB).css(g.el, {
                    left: Math.max(this.scaled.corners[0].x, this.scaled.corners[1].x) + "px",
                    top: Math.min(this.scaled.corners[1].y, this.scaled.corners[2].y) + "px",
                    width: this.edgeSize + "px",
                    height: Math.abs(this.scaled.height) + "px"
                });
                else if (i === 2) (0, _bb.BB).css(g.el, {
                    left: Math.min(this.scaled.corners[3].x, this.scaled.corners[2].x) + "px",
                    top: Math.max(this.scaled.corners[0].y, this.scaled.corners[3].y) + "px",
                    width: Math.abs(this.scaled.width) + "px",
                    height: this.edgeSize + "px"
                });
                else if (i === 3) (0, _bb.BB).css(g.el, {
                    left: Math.min(this.scaled.corners[0].x, this.scaled.corners[1].x) - this.edgeSize + "px",
                    top: Math.min(this.scaled.corners[0].y, this.scaled.corners[3].y) + "px",
                    width: this.edgeSize + "px",
                    height: Math.abs(this.scaled.height) + "px"
                });
                let angleOffset = Math.round(this.value.angleDeg / 45);
                while(angleOffset < 0)angleOffset += 8;
                angleOffset = (i * 2 + 1 + angleOffset) % this.cornerCursors.length;
                g.el.style.cursor = this.cornerCursors[angleOffset] + "-resize";
            };
            const isVertical = [
                0,
                2
            ].includes(i);
            g.pointerListener = new (0, _bb.BB).PointerListener({
                target: this.edges[i].el,
                fixScribble: true,
                onPointer: (event)=>{
                    event.eventPreventDefault();
                    if (event.type === "pointerdown" && event.button === "left") {
                        if (isVertical) isInverted = this.corners[0].y >= this.corners[3].y;
                        else isInverted = this.corners[0].x >= this.corners[1].x;
                        resetRemainder();
                    }
                    if (event.type === "pointermove" && event.button === "left") {
                        const tfD = (0, _bb.BB).rotateAround({
                            x: 0,
                            y: 0
                        }, {
                            x: event.dX / this.viewportTransform.scale,
                            y: event.dY / this.viewportTransform.scale
                        }, -this.value.angleDeg);
                        let ti = {
                            dX: tfD.x,
                            dY: tfD.y
                        };
                        if (Math.abs(this.value.angleDeg) % 90 === 0) ti = (0, _bb.BB).intDxy(pointerRemainder, tfD.x, tfD.y);
                        let indexes = [];
                        if (i === 0) indexes = [
                            2,
                            3,
                            0,
                            1
                        ];
                        else if (i === 1) indexes = [
                            0,
                            3,
                            1,
                            2
                        ];
                        else if (i === 2) indexes = [
                            0,
                            1,
                            2,
                            3
                        ];
                        else if (i === 3) indexes = [
                            1,
                            2,
                            0,
                            3
                        ];
                        const dimension = isVertical ? "y" : "x";
                        const d = isVertical ? ti.dY : ti.dX;
                        if (isInverted) {
                            this.corners[indexes[0]][dimension] += d;
                            this.corners[indexes[1]][dimension] += d;
                        } else {
                            this.corners[indexes[2]][dimension] += d;
                            this.corners[indexes[3]][dimension] += d;
                        }
                        if (this.keyListener.isPressed("shift")) {
                            if (isInverted) {
                                this.corners[indexes[2]][dimension] -= d;
                                this.corners[indexes[3]][dimension] -= d;
                            } else {
                                this.corners[indexes[0]][dimension] -= d;
                                this.corners[indexes[1]][dimension] -= d;
                            }
                        }
                        if (isVertical) this.restoreRatio(false, true);
                        else this.restoreRatio(true, false);
                        this.updateTransformViaCorners();
                    }
                }
            });
        })(i);
        this.angleGrip = {
            el: (0, _bb.BB).el({
                css: {
                    cursor: "url(" + (0, _cursorRotatePngDefault.default) + ") 10 10, move",
                    width: this.gripSize + "px",
                    height: this.gripSize + "px",
                    background: "#0ff",
                    borderRadius: this.gripSize + "px",
                    position: "absolute",
                    boxShadow: "inset 0 0 0 2px #000"
                }
            }),
            x: 0,
            y: 0,
            snap: false,
            updateDOM: ()=>{
                (0, _bb.BB).css(this.angleGrip.el, {
                    left: this.angleGrip.x - this.gripSize / 2 + "px",
                    top: this.angleGrip.y - this.gripSize / 2 + "px"
                });
            }
        };
        (0, _bb.BB).el({
            parent: this.angleGrip.el,
            css: {
                width: "2px",
                height: "13px",
                left: this.gripSize / 2 - 1 + "px",
                top: this.gripSize + "px",
                background: "#0ff",
                position: "absolute"
            }
        });
        this.anglePointerListener = new (0, _bb.BB).PointerListener({
            target: this.angleGrip.el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointermove" && event.button === "left") {
                    const bounds = this.rootEl.getBoundingClientRect();
                    const offset = {
                        x: bounds.left - this.rootEl.scrollLeft + this.viewportTransform.x,
                        y: bounds.top - this.rootEl.scrollTop + this.viewportTransform.y
                    };
                    const iP = {
                        x: (event.clientX - offset.x) / this.viewportTransform.scale,
                        y: (event.clientY - offset.y) / this.viewportTransform.scale
                    };
                    const a = (0, _bb.BB).pointsToAngleDeg({
                        x: this.value.x,
                        y: this.value.y
                    }, iP) + 90;
                    this.value.angleDeg = a;
                    const snapDeg = Math.round(a / 360 * 8) * 45;
                    if (this.keyListener.getComboStr() === "shift") this.value.angleDeg = snapDeg;
                    else if (this.snappingEnabled && Math.abs(snapDeg - a) < 8) this.value.angleDeg = snapDeg;
                    this.updateDOM();
                }
                if (event.type === "pointerup") {
                    if (Math.abs(this.value.angleDeg) % 90 === 0) {
                        (0, _freeTransformUtils.snapToPixel)(this.value);
                        this.updateCornerPositions();
                        this.updateDOM();
                    }
                }
            }
        });
        (0, _freeTransformUtils.snapToPixel)(this.value);
        this.updateDOM(true);
        (0, _bb.BB).append(this.transEl, [
            this.boundsEl,
            this.edges[0].el,
            this.edges[1].el,
            this.edges[2].el,
            this.edges[3].el,
            this.corners[0].el,
            this.corners[1].el,
            this.corners[2].el,
            this.corners[3].el,
            this.angleGrip.el
        ]);
    }
    getValue() {
        return (0, _freeTransformUtils.copyTransform)(this.value);
    }
    setIsConstrained(b) {
        this.isConstrained = b;
        if (b && this.value.width !== 0 && this.value.height !== 0) this.ratio = Math.abs(this.value.width / this.value.height);
    }
    setSnapping(b) {
        this.snappingEnabled = b;
    }
    setPos(p) {
        this.value.x = p.x;
        this.value.y = p.y;
        this.updateDOM(true);
    }
    move(dX, dY) {
        this.value.x += dX;
        this.value.y += dY;
        this.updateDOM(false);
    }
    setSize(w, h) {
        this.value.width = w;
        this.value.height = h;
        if (Math.abs(this.value.angleDeg) % 90 === 0) (0, _freeTransformUtils.snapToPixel)(this.value);
        this.updateCornerPositions();
        this.updateDOM(false);
    }
    setAngleDeg(a) {
        this.value.angleDeg = a;
        if (Math.abs(this.value.angleDeg) % 90 === 0) {
            (0, _freeTransformUtils.snapToPixel)(this.value);
            this.updateCornerPositions();
        }
        this.updateDOM(true);
    }
    setViewportTransform(transform) {
        this.viewportTransform = transform;
        this.updateScaled();
        this.updateDOM();
    }
    getElement() {
        return this.rootEl;
    }
    getRatio() {
        return this.ratio;
    }
    destroy() {
        this.keyListener.destroy();
        this.boundsPointerListener.destroy();
        this.corners.forEach((item)=>item.pointerListener.destroy());
        this.edges.forEach((item)=>item.pointerListener.destroy());
        this.anglePointerListener.destroy();
    }
}

},{"../../../bb/bb":"dcQKo","/src/app/img/ui/cursor-rotate.png":"8m6CW","./free-transform-utils":"6XErJ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8m6CW":[function(require,module,exports) {
module.exports = require("1e90bee649d7a11d").getBundleURL("d3gnI") + "cursor-rotate.509e78a5.png" + "?" + Date.now();

},{"1e90bee649d7a11d":"lgJ39"}],"6XErJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * snap entire transform to pixel grid. changes transform
 *
 * for x y:
 * If a dimension has an even size, it be an integer.
 * If it's uneven, it's sits exactly half way between two pixels.
 *
 * @param transform
 */ parcelHelpers.export(exports, "snapToPixel", ()=>snapToPixel);
parcelHelpers.export(exports, "copyTransform", ()=>copyTransform);
/**
 * image space to transform space
 * - origin of transform space is at center of transform bounds.
 * - same scale as image space. -> one unit is x: 1/width, y: 1/height
 * - up is where transform points up
 * - x goes right
 * - y goes down
 * @param x
 * @param y
 * @param transform
 */ parcelHelpers.export(exports, "toTransformSpace", ()=>toTransformSpace);
/**
 * transform space to image space
 * @param x
 * @param y
 * @param transform
 */ parcelHelpers.export(exports, "toImageSpace", ()=>toImageSpace);
var _bb = require("../../../bb/bb");
function snapToPixel(transform) {
    if (Math.abs(transform.angleDeg) % 90 !== 0) return;
    transform.width = Math.round(transform.width);
    transform.height = Math.round(transform.height);
    // 0° is original orientation.
    // At 90° and 270° width and height become swapped due to different orientation.
    const whSwapped = Math.abs(transform.angleDeg - 90) % 180 === 0;
    transform.x = (whSwapped ? transform.height : transform.width) % 2 === 0 ? Math.round(transform.x) : Math.round(transform.x - 0.5) + 0.5;
    transform.y = (whSwapped ? transform.width : transform.height) % 2 === 0 ? Math.round(transform.y) : Math.round(transform.y - 0.5) + 0.5;
}
function copyTransform(transform) {
    return {
        x: transform.x,
        y: transform.y,
        width: transform.width,
        height: transform.height,
        angleDeg: transform.angleDeg
    };
}
function toTransformSpace(x, y, transform) {
    let px, py;
    px = x - transform.x;
    py = y - transform.y;
    const rot = (0, _bb.BB).rotateAround({
        x: 0,
        y: 0
    }, {
        x: px,
        y: py
    }, -transform.angleDeg);
    px = rot.x;
    py = rot.y;
    return {
        x: px,
        y: py
    };
}
function toImageSpace(x, y, transform) {
    const rot = (0, _bb.BB).rotateAround({
        x: 0,
        y: 0
    }, {
        x: x,
        y: y
    }, transform.angleDeg);
    return {
        x: rot.x + transform.x,
        y: rot.y + transform.y
    };
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3quPq":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * a basic canvas where you can transform one layer(move around, rotate, scale)
 */ parcelHelpers.export(exports, "FreeTransformCanvas", ()=>FreeTransformCanvas);
var _bb = require("../../../bb/bb");
var _freeTransform = require("./free-transform");
var _preview = require("../project-viewport/preview");
var _emotionCssCjs = require("@emotion/css/dist/emotion-css.cjs");
class FreeTransformCanvas {
    updatePreview() {
        const transform = this.freeTransform.getValue();
        const ctx = (0, _bb.BB).ctx(this.previewCanvas);
        ctx.save();
        ctx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
        (0, _bb.BB).drawTransformedImageWithBounds(ctx, this.layers[this.transformIndex].image, transform, undefined, (0, _bb.BB).testShouldPixelate(transform, transform.width / this.initTransform.width, transform.height / this.initTransform.height));
        ctx.restore();
        this.preview.render();
    }
    // ---- public ----
    constructor(p){
        this.imageWidth = p.imageWidth;
        this.imageHeight = p.imageHeight;
        this.rootEl = (0, _bb.BB).el({
            className: "kl-preview-wrapper",
            css: {
                width: p.elementWidth + "px",
                height: p.elementHeight + "px"
            }
        });
        this.rootEl.oncontextmenu = ()=>{
            return false;
        };
        this.layers = p.layers;
        this.transformIndex = p.transformIndex;
        this.previewLayerArr = this.layers.map((item)=>{
            return {
                image: item.image,
                isVisible: item.isVisible,
                mixModeStr: item.mixModeStr ?? "source-over",
                opacity: item.opacity,
                hasClipping: false
            };
        });
        this.previewCanvas = (0, _bb.BB).canvas(this.imageWidth, this.imageHeight);
        this.previewLayerArr[this.previewLayerArr.length - 1].image = this.previewCanvas;
        this.preview = new (0, _preview.Preview)({
            width: p.elementWidth,
            height: p.elementHeight,
            project: {
                width: p.imageWidth,
                height: p.imageHeight,
                layers: this.previewLayerArr
            },
            hasEditMode: true,
            onModeChange: (m)=>{
                this.freeTransform.getElement().style.pointerEvents = m === "edit" ? "" : "none";
                this.freeTransform.getElement().style.opacity = m === "edit" ? "" : "0.5";
            },
            onTransformChange: (transform)=>{
                this.freeTransform.setViewportTransform(transform);
            },
            padding: 30
        });
        this.preview.getElement().classList.add((0, _emotionCssCjs.css)({
            overflow: "hidden",
            marginLeft: "-20px",
            marginRight: "-20px"
        }));
        this.rootEl.append(this.preview.getElement());
        this.initTransform = {
            x: this.imageWidth / 2,
            y: this.imageHeight / 2,
            width: this.layers[this.transformIndex].image.width,
            height: this.layers[this.transformIndex].image.height
        };
        this.freeTransform = new (0, _freeTransform.FreeTransform)({
            x: this.initTransform.x,
            y: this.initTransform.y,
            width: this.initTransform.width,
            height: this.initTransform.height,
            angleDeg: 0,
            isConstrained: true,
            snapX: [
                0,
                this.imageWidth
            ],
            snapY: [
                0,
                this.imageHeight
            ],
            viewportTransform: this.preview.getTransform(),
            callback: ()=>{
                this.updatePreview();
            }
        });
        this.preview.getElement().append(this.freeTransform.getElement());
        (0, _bb.BB).css(this.freeTransform.getElement(), {
            position: "absolute",
            left: "0",
            top: "0"
        });
        setTimeout(()=>this.updatePreview(), 0);
    }
    // ---- interface ----
    move(dX, dY) {
        this.freeTransform.move(dX, dY);
    }
    reset() {
        const w = this.layers[this.transformIndex].image.width;
        const h = this.layers[this.transformIndex].image.height;
        this.freeTransform.setSize(w, h);
        this.freeTransform.setPos({
            x: w / 2,
            y: h / 2
        });
        this.freeTransform.setAngleDeg(0);
        this.updatePreview();
    }
    setTransformFit() {
        const fit = (0, _bb.BB).fitInto(this.layers[this.transformIndex].image.width, this.layers[this.transformIndex].image.height, this.imageWidth, this.imageHeight, 1);
        this.freeTransform.setSize(fit.width, fit.height);
        this.freeTransform.setPos({
            x: fit.width / 2,
            y: fit.height / 2
        });
        this.freeTransform.setAngleDeg(0);
        this.updatePreview();
    }
    setTransformCenter() {
        this.freeTransform.setPos({
            x: this.imageWidth / 2,
            y: this.imageHeight / 2
        });
        this.freeTransform.setAngleDeg(0);
        this.updatePreview();
    }
    /**
     * gives you the transformation in the original scale
     */ getTransformation() {
        return this.freeTransform.getValue();
    }
    getIsPixelated() {
        const transform = this.freeTransform.getValue();
        return (0, _bb.BB).testShouldPixelate(transform, transform.width / this.initTransform.width, transform.height / this.initTransform.height);
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.freeTransform.destroy();
        this.preview.destroy();
        (0, _bb.BB).freeCanvas(this.previewCanvas);
    }
}

},{"../../../bb/bb":"dcQKo","./free-transform":"izcGJ","../project-viewport/preview":"iWTRk","@emotion/css/dist/emotion-css.cjs":"djBls","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"djBls":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "cache", ()=>(0, _emotionCssCjsJs.cache));
parcelHelpers.export(exports, "css", ()=>(0, _emotionCssCjsJs.css));
parcelHelpers.export(exports, "cx", ()=>(0, _emotionCssCjsJs.cx));
parcelHelpers.export(exports, "flush", ()=>(0, _emotionCssCjsJs.flush));
parcelHelpers.export(exports, "getRegisteredStyles", ()=>(0, _emotionCssCjsJs.getRegisteredStyles));
parcelHelpers.export(exports, "hydrate", ()=>(0, _emotionCssCjsJs.hydrate));
parcelHelpers.export(exports, "injectGlobal", ()=>(0, _emotionCssCjsJs.injectGlobal));
parcelHelpers.export(exports, "keyframes", ()=>(0, _emotionCssCjsJs.keyframes));
parcelHelpers.export(exports, "merge", ()=>(0, _emotionCssCjsJs.merge));
parcelHelpers.export(exports, "sheet", ()=>(0, _emotionCssCjsJs.sheet));
var _emotionCssCjsJs = require("./emotion-css.cjs.js");

},{"./emotion-css.cjs.js":"lHuBY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lHuBY":[function(require,module,exports) {
"use strict";
module.exports = require("f137cb683236d829");

},{"f137cb683236d829":"dOmLI"}],"dOmLI":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var createInstance_dist_emotionCssCreateInstance = require("54af33f838955507");
require("7d50a5e5c903a54f");
require("13ee65b027be31e3");
require("9416049ebd5e32b6");
var _createEmotion = createInstance_dist_emotionCssCreateInstance["default"]({
    key: "css"
}), flush = _createEmotion.flush, hydrate = _createEmotion.hydrate, cx = _createEmotion.cx, merge = _createEmotion.merge, getRegisteredStyles = _createEmotion.getRegisteredStyles, injectGlobal = _createEmotion.injectGlobal, keyframes = _createEmotion.keyframes, css = _createEmotion.css, sheet = _createEmotion.sheet, cache = _createEmotion.cache;
exports.cache = cache;
exports.css = css;
exports.cx = cx;
exports.flush = flush;
exports.getRegisteredStyles = getRegisteredStyles;
exports.hydrate = hydrate;
exports.injectGlobal = injectGlobal;
exports.keyframes = keyframes;
exports.merge = merge;
exports.sheet = sheet;

},{"54af33f838955507":"6W8XF","7d50a5e5c903a54f":"3Umtj","13ee65b027be31e3":"kS2E2","9416049ebd5e32b6":"6UI8e"}],"6W8XF":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
var createCache = require("c5be38aa9184983a");
var serialize = require("af8b25fea777dff7");
var utils = require("9bc9c7495c25c7b0");
function _interopDefault(e) {
    return e && e.__esModule ? e : {
        "default": e
    };
}
var createCache__default = /*#__PURE__*/ _interopDefault(createCache);
function insertWithoutScoping(cache, serialized) {
    if (cache.inserted[serialized.name] === undefined) return cache.insert("", serialized, cache.sheet, true);
}
function merge(registered, css, className) {
    var registeredStyles = [];
    var rawClassName = utils.getRegisteredStyles(registered, registeredStyles, className);
    if (registeredStyles.length < 2) return className;
    return rawClassName + css(registeredStyles);
}
var createEmotion = function createEmotion(options) {
    var cache = createCache__default["default"](options); // $FlowFixMe
    cache.sheet.speedy = function(value) {
        if (this.ctr !== 0) throw new Error("speedy must be changed before any rules are inserted");
        this.isSpeedy = value;
    };
    cache.compat = true;
    var css = function css() {
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
        var serialized = serialize.serializeStyles(args, cache.registered, undefined);
        utils.insertStyles(cache, serialized, false);
        return cache.key + "-" + serialized.name;
    };
    var keyframes = function keyframes() {
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
        var serialized = serialize.serializeStyles(args, cache.registered);
        var animation = "animation-" + serialized.name;
        insertWithoutScoping(cache, {
            name: serialized.name,
            styles: "@keyframes " + animation + "{" + serialized.styles + "}"
        });
        return animation;
    };
    var injectGlobal = function injectGlobal() {
        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)args[_key3] = arguments[_key3];
        var serialized = serialize.serializeStyles(args, cache.registered);
        insertWithoutScoping(cache, serialized);
    };
    var cx = function cx() {
        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)args[_key4] = arguments[_key4];
        return merge(cache.registered, css, classnames(args));
    };
    return {
        css: css,
        cx: cx,
        injectGlobal: injectGlobal,
        keyframes: keyframes,
        hydrate: function hydrate(ids) {
            ids.forEach(function(key) {
                cache.inserted[key] = true;
            });
        },
        flush: function flush() {
            cache.registered = {};
            cache.inserted = {};
            cache.sheet.flush();
        },
        // $FlowFixMe
        sheet: cache.sheet,
        cache: cache,
        getRegisteredStyles: utils.getRegisteredStyles.bind(null, cache.registered),
        merge: merge.bind(null, cache.registered, css)
    };
};
var classnames = function classnames(args) {
    var cls = "";
    for(var i = 0; i < args.length; i++){
        var arg = args[i];
        if (arg == null) continue;
        var toAdd = void 0;
        switch(typeof arg){
            case "boolean":
                break;
            case "object":
                if (Array.isArray(arg)) toAdd = classnames(arg);
                else {
                    toAdd = "";
                    for(var k in arg)if (arg[k] && k) {
                        toAdd && (toAdd += " ");
                        toAdd += k;
                    }
                }
                break;
            default:
                toAdd = arg;
        }
        if (toAdd) {
            cls && (cls += " ");
            cls += toAdd;
        }
    }
    return cls;
};
exports["default"] = createEmotion;

},{"c5be38aa9184983a":"3Umtj","af8b25fea777dff7":"kS2E2","9bc9c7495c25c7b0":"6UI8e"}],"bajkn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Interactive preview for crop filter. Corners and edges can be dragged.
 * the div that you append this to must be relative
 */ parcelHelpers.export(exports, "Cropper", ()=>Cropper);
var _bb = require("../../../bb/bb");
class Cropper {
    update() {
        this.edges[0].update();
        this.edges[1].update();
        this.edges[2].update();
        this.edges[3].update();
        this.cornerElArr[0].update();
        this.cornerElArr[1].update();
        this.cornerElArr[2].update();
        this.cornerElArr[3].update();
        this.darken[0].update();
        this.darken[1].update();
        this.darken[2].update();
        this.darken[3].update();
        this.outline.update();
        this.thirdsHorizontal.update();
        this.thirdsVertical.update();
    }
    commit() {
        this.pointerRemainder.x = 0;
        this.pointerRemainder.y = 0;
        this.callback(this.getTransform());
    }
    // ---- public ----
    constructor(params){
        this.x = params.x;
        this.y = params.y;
        this.width = params.width;
        this.height = params.height;
        this.scale = params.scale;
        this.callback = params.callback;
        const maxW = params.maxW;
        const maxH = params.maxW;
        this.rootEl = (0, _bb.BB).el();
        const gripCursors = [
            "nw",
            "n",
            "ne",
            "e",
            "se",
            "s",
            "sw",
            "w"
        ];
        this.keyListener = new (0, _bb.BB).KeyListener({});
        (0, _bb.BB).css(this.rootEl, {
            position: "absolute",
            left: this.x * this.scale + "px",
            top: this.y * this.scale + "px"
        });
        this.outline = {
            el: (0, _bb.BB).el({
                css: {
                    position: "absolute",
                    border: "1px dashed #fff",
                    cursor: "move"
                }
            }),
            update: ()=>{
                (0, _bb.BB).css(this.outline.el, {
                    left: this.grips[0].x * this.scale - 1 + "px",
                    top: this.grips[0].y * this.scale - 1 + "px",
                    width: (this.grips[2].x - this.grips[0].x) * this.scale + "px",
                    height: (this.grips[2].y - this.grips[0].y) * this.scale + "px"
                });
            }
        };
        this.pointerRemainder = {
            x: 0,
            y: 0
        };
        this.outlinePointerListener = new (0, _bb.BB).PointerListener({
            target: this.outline.el,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointermove" && event.button === "left") {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    this.grips[0].x += dX;
                    this.grips[0].y += dY;
                    this.grips[1].x += dX;
                    this.grips[1].y += dY;
                    this.grips[2].x += dX;
                    this.grips[2].y += dY;
                    this.grips[3].x += dX;
                    this.grips[3].y += dY;
                    this.update();
                }
                if (event.type === "pointerup") this.commit();
            }
        });
        this.thirdsHorizontal = {
            el: (0, _bb.BB).el({
                css: {
                    position: "absolute",
                    borderTop: "1px solid #0ff",
                    borderBottom: "1px solid #0ff"
                }
            }),
            update: ()=>{
                (0, _bb.BB).css(this.thirdsHorizontal.el, {
                    left: this.grips[0].x * this.scale + "px",
                    top: (this.grips[0].y + (this.grips[2].y - this.grips[0].y) / 3) * this.scale + "px",
                    width: (this.grips[2].x - this.grips[0].x) * this.scale + "px",
                    height: (this.grips[2].y - this.grips[0].y) / 3 * this.scale + "px"
                });
            }
        };
        this.thirdsVertical = {
            el: (0, _bb.BB).el({
                css: {
                    position: "absolute",
                    borderLeft: "1px solid #0ff",
                    borderRight: "1px solid #0ff"
                }
            }),
            update: ()=>{
                (0, _bb.BB).css(this.thirdsVertical.el, {
                    left: (this.grips[0].x + (this.grips[2].x - this.grips[0].x) / 3) * this.scale + "px",
                    top: this.grips[0].y * this.scale + "px",
                    width: (this.grips[2].x - this.grips[0].x) / 3 * this.scale + "px",
                    height: (this.grips[2].y - this.grips[0].y) * this.scale + "px"
                });
            }
        };
        const gripSize = 40;
        const gripOverlay = 10;
        this.grips = [
            {
                x: 0,
                y: 0
            },
            {
                x: this.width,
                y: 0
            },
            {
                x: this.width,
                y: this.height
            },
            {
                x: 0,
                y: this.height
            }
        ];
        const transformTop = (dY)=>{
            this.grips[0].y += dY;
            this.grips[0].y = (0, _bb.BB).clamp(this.grips[0].y, this.grips[3].y - maxH, this.grips[3].y - 1);
            this.grips[1].y = this.grips[0].y;
        };
        const transformRight = (dX)=>{
            this.grips[1].x += dX;
            this.grips[1].x = (0, _bb.BB).clamp(this.grips[1].x, this.grips[0].x + 1, this.grips[0].x + maxW);
            this.grips[2].x = this.grips[1].x;
        };
        const transformBottom = (dY)=>{
            this.grips[2].y += dY;
            this.grips[2].y = (0, _bb.BB).clamp(this.grips[2].y, this.grips[1].y + 1, this.grips[1].y + maxH);
            this.grips[3].y = this.grips[2].y;
        };
        const transformLeft = (dX)=>{
            this.grips[0].x += dX;
            this.grips[0].x = (0, _bb.BB).clamp(this.grips[0].x, this.grips[1].x - maxW, this.grips[1].x - 1);
            this.grips[3].x = this.grips[0].x;
        };
        this.edges = [];
        for(let i = 0; i < 4; i++)((i)=>{
            const el = (0, _bb.BB).el({
                css: {
                    width: gripSize + "px",
                    height: gripSize + "px",
                    //background: '#0f0',
                    position: "absolute"
                }
            });
            const update = ()=>{
                if (i === 0) (0, _bb.BB).css(el, {
                    left: this.grips[0].x * this.scale + gripOverlay + "px",
                    top: this.grips[0].y * this.scale - gripSize * 2 + gripOverlay + "px",
                    width: (this.grips[1].x - this.grips[0].x) * this.scale - gripOverlay * 2 + "px",
                    height: gripSize * 2 + "px"
                });
                else if (i === 1) (0, _bb.BB).css(el, {
                    left: this.grips[1].x * this.scale - gripOverlay + "px",
                    top: this.grips[1].y * this.scale + gripOverlay + "px",
                    width: gripSize * 2 + "px",
                    height: (this.grips[2].y - this.grips[1].y) * this.scale - gripOverlay * 2 + "px"
                });
                else if (i === 2) (0, _bb.BB).css(el, {
                    left: this.grips[3].x * this.scale + gripOverlay + "px",
                    top: this.grips[3].y * this.scale - gripOverlay + "px",
                    width: (this.grips[2].x - this.grips[3].x) * this.scale - gripOverlay * 2 + "px",
                    height: gripSize * 2 + "px"
                });
                else if (i === 3) (0, _bb.BB).css(el, {
                    left: this.grips[0].x * this.scale - gripSize * 2 + gripOverlay + "px",
                    top: this.grips[0].y * this.scale + gripOverlay + "px",
                    width: gripSize * 2 + "px",
                    height: (this.grips[3].y - this.grips[0].y) * this.scale - gripOverlay * 2 + "px"
                });
                const angleOffset = i * 2 + 1;
                el.style.cursor = gripCursors[angleOffset] + "-resize";
            };
            this.edges[i] = {
                el,
                update
            };
        })(i);
        this.darken = [];
        for(let i = 0; i < 4; i++)((i)=>{
            const g = (0, _bb.BB).el({
                css: {
                    position: "absolute",
                    background: "#000",
                    opacity: "0.5"
                }
            });
            const update = ()=>{
                if (i === 0) (0, _bb.BB).css(g, {
                    left: this.grips[0].x * this.scale + "px",
                    top: this.grips[0].y * this.scale - 8000 + "px",
                    width: (this.grips[1].x - this.grips[0].x) * this.scale + "px",
                    height: "8000px"
                });
                else if (i === 1) (0, _bb.BB).css(g, {
                    left: this.grips[1].x * this.scale + "px",
                    top: this.grips[1].y * this.scale - 8000 + "px",
                    width: "8000px",
                    height: "16000px"
                });
                else if (i === 2) (0, _bb.BB).css(g, {
                    left: this.grips[3].x * this.scale + "px",
                    top: this.grips[3].y * this.scale + "px",
                    width: (this.grips[2].x - this.grips[3].x) * this.scale + "px",
                    height: "8000px"
                });
                else if (i === 3) (0, _bb.BB).css(g, {
                    left: this.grips[0].x * this.scale - 8000 + "px",
                    top: this.grips[0].y * this.scale - 8000 + "px",
                    width: "8000px",
                    height: "16000px"
                });
            };
            this.darken[i] = {
                el: g,
                update
            };
        })(i);
        this.edge0PointerListener = new (0, _bb.BB).PointerListener({
            target: this.edges[0].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointermove" && event.button === "left") {
                    const { dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformTop(dY);
                    if (this.keyListener.isPressed("shift")) transformBottom(-dY);
                    this.update();
                }
                if (event.type === "pointerup") this.commit();
            }
        });
        this.edge1PointerListener = new (0, _bb.BB).PointerListener({
            target: this.edges[1].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointermove" && event.button === "left") {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformRight(dX);
                    if (this.keyListener.isPressed("shift")) transformLeft(-dX);
                    this.update();
                }
                if (event.type === "pointerup") this.commit();
            }
        });
        this.edge2PointerListener = new (0, _bb.BB).PointerListener({
            target: this.edges[2].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointermove" && event.button === "left") {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformBottom(dY);
                    if (this.keyListener.isPressed("shift")) transformTop(-dY);
                    this.update();
                }
                if (event.type === "pointerup") this.commit();
            }
        });
        this.edge3PointerListener = new (0, _bb.BB).PointerListener({
            target: this.edges[3].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointermove" && event.button === "left") {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformLeft(dX);
                    if (this.keyListener.isPressed("shift")) transformRight(-dX);
                    this.update();
                }
                if (event.type === "pointerup") this.commit();
            }
        });
        this.cornerElArr = [];
        (()=>{
            for(let i = 0; i < 4; i++)((i)=>{
                const g = (0, _bb.BB).el({
                    css: {
                        //background: '#f00',
                        width: gripSize * 2 + "px",
                        height: gripSize * 2 + "px",
                        position: "absolute",
                        cursor: [
                            "nwse-resize",
                            "nesw-resize"
                        ][i % 2]
                    }
                });
                const update = ()=>{
                    if (i === 0) (0, _bb.BB).css(g, {
                        left: this.grips[0].x * this.scale - gripSize * 2 + gripOverlay + "px",
                        top: this.grips[0].y * this.scale - gripSize * 2 + gripOverlay + "px"
                    });
                    else if (i === 1) (0, _bb.BB).css(g, {
                        left: this.grips[1].x * this.scale - gripOverlay + "px",
                        top: this.grips[1].y * this.scale - gripSize * 2 + gripOverlay + "px"
                    });
                    else if (i === 2) (0, _bb.BB).css(g, {
                        left: this.grips[1].x * this.scale - gripOverlay + "px",
                        top: this.grips[2].y * this.scale - gripOverlay + "px"
                    });
                    else if (i === 3) (0, _bb.BB).css(g, {
                        left: this.grips[0].x * this.scale - gripSize * 2 + gripOverlay + "px",
                        top: this.grips[2].y * this.scale - gripOverlay + "px"
                    });
                };
                this.cornerElArr[i] = {
                    el: g,
                    update
                };
            })(i);
        })();
        //top left
        this.corner0PointerListener = new (0, _bb.BB).PointerListener({
            target: this.cornerElArr[0].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointermove" && event.button === "left") {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformLeft(dX);
                    transformTop(dY);
                    if (this.keyListener.isPressed("shift")) {
                        transformRight(-dX);
                        transformBottom(-dY);
                    }
                    this.update();
                }
                if (event.type === "pointerup") this.commit();
            }
        });
        //top right
        this.corner1PointerListener = new (0, _bb.BB).PointerListener({
            target: this.cornerElArr[1].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointermove" && event.button === "left") {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformRight(dX);
                    transformTop(dY);
                    if (this.keyListener.isPressed("shift")) {
                        transformLeft(-dX);
                        transformBottom(-dY);
                    }
                    this.update();
                }
                if (event.type === "pointerup") this.commit();
            }
        });
        //bottom right
        this.corner2PointerListener = new (0, _bb.BB).PointerListener({
            target: this.cornerElArr[2].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointermove" && event.button === "left") {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformRight(dX);
                    transformBottom(dY);
                    if (this.keyListener.isPressed("shift")) {
                        transformLeft(-dX);
                        transformTop(-dY);
                    }
                    this.update();
                }
                if (event.type === "pointerup") this.commit();
            }
        });
        //bottom left
        this.corner3PointerListener = new (0, _bb.BB).PointerListener({
            target: this.cornerElArr[3].el,
            fixScribble: true,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.type === "pointermove" && event.button === "left") {
                    const { dX, dY } = (0, _bb.BB).intDxy(this.pointerRemainder, event.dX / this.scale, event.dY / this.scale);
                    transformLeft(dX);
                    transformBottom(dY);
                    if (this.keyListener.isPressed("shift")) {
                        transformRight(-dX);
                        transformTop(-dY);
                    }
                    this.update();
                }
                if (event.type === "pointerup") this.commit();
            }
        });
        this.rootEl.append(this.darken[1].el, this.darken[0].el, this.darken[2].el, this.darken[3].el, this.thirdsHorizontal.el, this.thirdsVertical.el, this.outline.el, this.edges[1].el, this.edges[0].el, this.edges[2].el, this.edges[3].el, this.cornerElArr[0].el, this.cornerElArr[1].el, this.cornerElArr[2].el, this.cornerElArr[3].el);
        this.update();
    }
    // ---- interface ----
    getTransform() {
        this.grips[1].x -= this.grips[0].x;
        this.grips[1].y -= this.grips[0].y;
        this.grips[2].x -= this.grips[0].x;
        this.grips[2].y -= this.grips[0].y;
        this.grips[3].x -= this.grips[0].x;
        this.grips[3].y -= this.grips[0].y;
        this.x += this.grips[0].x;
        this.y += this.grips[0].y;
        this.grips[0].x = 0;
        this.grips[0].y = 0;
        return {
            x: this.x,
            y: this.y,
            width: this.grips[1].x,
            height: this.grips[2].y
        };
    }
    setTransform(p) {
        this.x = p.x;
        this.y = p.y;
        this.width = p.width;
        this.height = p.height;
        (0, _bb.BB).css(this.rootEl, {
            left: this.x * this.scale + "px",
            top: this.y * this.scale + "px"
        });
        this.grips[0].x = 0;
        this.grips[0].y = 0;
        this.grips[1].x = this.width;
        this.grips[1].y = 0;
        this.grips[2].x = this.width;
        this.grips[2].y = this.height;
        this.grips[3].x = 0;
        this.grips[3].y = this.height;
        this.update();
        this.commit();
    }
    setScale(s) {
        this.scale = s;
        (0, _bb.BB).css(this.rootEl, {
            left: this.x * this.scale + "px",
            top: this.y * this.scale + "px"
        });
        this.update();
    }
    showThirds(b) {
        this.thirdsHorizontal.el.style.display = b ? "block" : "none";
        this.thirdsVertical.el.style.display = b ? "block" : "none";
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.keyListener.destroy();
        this.outlinePointerListener.destroy();
        this.corner0PointerListener.destroy();
        this.corner1PointerListener.destroy();
        this.corner2PointerListener.destroy();
        this.corner3PointerListener.destroy();
        this.edge0PointerListener.destroy();
        this.edge1PointerListener.destroy();
        this.edge2PointerListener.destroy();
        this.edge3PointerListener.destroy();
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1YtXQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Previews currently active layer
 * thumbnail (hover shows bigger preview), layername, opacity
 *
 * internally listens to kl history. updates when there's a change.
 * but you need to update it when the active layer changed. (different canvas object)
 *
 * update visibility for performance
 */ parcelHelpers.export(exports, "LayerPreview", ()=>LayerPreview);
var _bb = require("../../../bb/bb");
var _klHistory = require("../../history/kl-history");
var _language = require("../../../language/language");
var _theme = require("../../../theme/theme");
var _base = require("../../../bb/base/base");
class LayerPreview {
    updateCheckerPatterns() {
        const checker = (0, _bb.BB).createCheckerCanvas(4, (0, _theme.theme).isDark());
        this.animationCanvasCheckerPattern = (0, _base.throwIfNull)(this.animationCanvasCtx.createPattern(checker, "repeat"));
        this.largeCanvasCheckerPattern = (0, _base.throwIfNull)(this.canvasCtx.createPattern(checker, "repeat"));
    }
    animate() {
        if (this.animationCount === 0) return;
        this.animationCount--;
        this.canvasCtx.save();
        this.canvasCtx.globalAlpha = Math.pow((this.animationLength - this.animationCount) / this.animationLength, 2);
        this.canvasCtx.drawImage(this.animationCanvas, 0, 0);
        this.canvasCtx.restore();
        if (this.animationCount > 0) requestAnimationFrame(()=>this.animate());
    }
    /**
     * is always instant
     */ drawLargeCanvas() {
        if (!this.largeCanvasIsVisible || !this.layerObj) return;
        const layerCanvas = this.layerObj.context.canvas;
        const canvasDimensions = (0, _bb.BB).fitInto(layerCanvas.width, layerCanvas.height, this.largeCanvasSize, this.largeCanvasSize, 1);
        this.largeCanvas.width = Math.round(canvasDimensions.width);
        this.largeCanvas.height = Math.round(canvasDimensions.height);
        this.largeCanvasCtx.save();
        if (this.largeCanvas.width > layerCanvas.width) this.largeCanvasCtx.imageSmoothingEnabled = false;
        else {
            this.largeCanvasCtx.imageSmoothingEnabled = true;
            this.largeCanvasCtx.imageSmoothingQuality = "high";
        }
        this.largeCanvasCtx.fillStyle = this.largeCanvasCheckerPattern;
        this.largeCanvasCtx.fillRect(0, 0, this.largeCanvas.width, this.largeCanvas.height);
        this.largeCanvasCtx.drawImage(layerCanvas, 0, 0, this.largeCanvas.width, this.largeCanvas.height);
        this.largeCanvasCtx.restore();
        const bounds = this.rootEl.getBoundingClientRect();
        (0, _bb.BB).css(this.largeCanvasWrapper, {
            top: Math.max(10, bounds.top + this.height / 2 - this.largeCanvas.height / 2) + "px"
        });
    }
    draw(isInstant) {
        if (!this.isVisible || !this.layerObj) return;
        const layerIsVisible = this.layerObj.isVisible;
        this.checkEl.parentElement.title = layerIsVisible ? (0, _language.LANG)("layers-active-layer-visible") : (0, _language.LANG)("layers-active-layer-hidden");
        this.checkEl.checked = layerIsVisible;
        this.checkEl.style.boxShadow = layerIsVisible ? "" : "0 0 0 1px red";
        this.nameLabelEl.textContent = this.layerObj.name;
        if (this.layerObj.isVisible) this.opacityEl.innerHTML = (0, _language.LANG)("opacity") + "<br>" + Math.round(this.layerObj.opacity * 100) + "%";
        else this.opacityEl.innerHTML = (0, _language.LANG)("opacity") + "<br><s>" + Math.round(this.layerObj.opacity * 100) + "%</s>";
        const layerCanvas = this.layerObj.context.canvas;
        if (layerCanvas.width !== this.lastDrawnSize.width || layerCanvas.height !== this.lastDrawnSize.height) {
            const canvasDimensions = (0, _bb.BB).fitInto(layerCanvas.width, layerCanvas.height, this.canvasSize, this.canvasSize, 1);
            this.canvas.width = Math.round(canvasDimensions.width);
            this.canvas.height = Math.round(canvasDimensions.height);
            isInstant = true;
        }
        this.animationCanvas.width = this.canvas.width;
        this.animationCanvas.height = this.canvas.height;
        this.animationCanvasCtx.save();
        this.animationCanvasCtx.imageSmoothingEnabled = false;
        this.animationCanvasCtx.fillStyle = this.animationCanvasCheckerPattern;
        this.animationCanvasCtx.fillRect(0, 0, this.animationCanvas.width, this.animationCanvas.height);
        this.animationCanvasCtx.drawImage(layerCanvas, 0, 0, this.animationCanvas.width, this.animationCanvas.height);
        this.animationCanvasCtx.restore();
        if (isInstant) {
            this.animationCount = 0;
            this.canvasCtx.save();
            this.canvasCtx.drawImage(this.animationCanvas, 0, 0);
            this.canvasCtx.restore();
        } else {
            this.animationCount = this.animationLength;
            this.animate();
        }
        this.drawLargeCanvas();
        this.lastDrawnState = (0, _klHistory.klHistory).getState();
        this.lastDrawnSize.width = layerCanvas.width;
        this.lastDrawnSize.height = layerCanvas.height;
    }
    // ---- public ----
    constructor(p){
        this.animationCanvasCheckerPattern = {};
        this.largeCanvasCheckerPattern = {};
        // internally redraws with in an interval. checks history is something changed
        // this update will be animated
        // it will not be animated if the resolution changed
        // also redraws when you call updateLayer - not animated
        // syncs via updateLayer, and internally updates layer opacity via a hack
        this.rootEl = (0, _bb.BB).el({
            className: "kl-layer-preview"
        });
        this.isVisible = true;
        this.height = 40;
        this.canvasSize = this.height - 10;
        this.largeCanvasSize = 300;
        this.lastDrawnState = -2;
        this.lastDrawnSize = {
            width: 0,
            height: 0
        };
        this.animationCanvas = (0, _bb.BB).canvas(); // to help animate the transition
        this.animationCanvasCtx = (0, _bb.BB).ctx(this.animationCanvas);
        this.animationLength = 30;
        this.animationCount = 0;
        this.largeCanvasIsVisible = false;
        let largeCanvasAnimationTimeout;
        const largeCanvasAnimationDurationMs = 300;
        this.uiState = p.uiState;
        // --- setup dom ---
        this.contentWrapperEl = (0, _bb.BB).el({
            css: {
                display: "flex",
                alignItems: "center",
                height: this.height + "px"
            }
        });
        const checkWrapper = (0, _bb.BB).el({
            css: {
                display: "flex",
                justifyContent: "flex-end",
                alignItems: "center",
                width: "23px",
                flexShrink: "0"
            }
        });
        this.checkEl = (0, _bb.BB).el({
            parent: checkWrapper,
            tagName: "input",
            css: {
                pointerEvents: "none"
            },
            custom: {
                type: "checkbox",
                disabled: "true"
            }
        });
        const canvasWrapperEl = (0, _bb.BB).el({
            css: {
                //background: '#f00',
                minWidth: this.height + "px",
                height: this.height + "px",
                display: "flex",
                justifyContent: "center",
                alignItems: "center"
            }
        });
        this.canvas = (0, _bb.BB).canvas(this.canvasSize, this.canvasSize);
        this.canvasCtx = (0, _bb.BB).ctx(this.canvas);
        this.canvas.title = (0, _language.LANG)("layers-active-layer");
        const nameWrapper = (0, _bb.BB).el({
            css: {
                //background: '#ff0',
                flexGrow: "1",
                paddingLeft: "10px",
                fontSize: "13px",
                overflow: "hidden",
                position: "relative"
            }
        });
        this.nameLabelEl = (0, _bb.BB).el({
            content: "",
            css: {
                cssFloat: "left",
                whiteSpace: "nowrap"
            }
        });
        const clickableEl = (0, _bb.BB).el({
            css: {
                // background: 'rgba(0,255,0,0.6)',
                position: "absolute",
                left: "10px",
                top: "0",
                width: "90px",
                height: "100%"
            }
        });
        if (p.onClick) {
            clickableEl.addEventListener("click", ()=>p.onClick());
            this.canvas.addEventListener("click", ()=>p.onClick());
            checkWrapper.addEventListener("click", ()=>p.onClick());
        }
        this.opacityEl = (0, _bb.BB).el({
            content: (0, _language.LANG)("opacity") + "<br>100%",
            css: {
                minWidth: "60px",
                fontSize: "12px",
                textAlign: "center"
            }
        });
        this.largeCanvasWrapper = (0, _bb.BB).el({
            onClick: (0, _bb.BB).handleClick,
            css: {
                pointerEvents: "none",
                background: "#fff",
                position: "absolute",
                right: "280px",
                top: "10px",
                border: "1px solid #aaa",
                boxShadow: "1px 1px 3px rgba(0,0,0,0.3)",
                transition: "opacity " + largeCanvasAnimationDurationMs + "ms ease-in-out",
                userSelect: "none",
                display: "block",
                webkitTouchCallout: "none"
            }
        });
        this.largeCanvas = (0, _bb.BB).canvas(this.largeCanvasSize, this.largeCanvasSize);
        this.largeCanvasWrapper.append(this.largeCanvas);
        this.largeCanvasCtx = (0, _bb.BB).ctx(this.largeCanvas);
        (0, _bb.BB).css(this.largeCanvas, {
            display: "block"
        });
        canvasWrapperEl.append(this.canvas);
        nameWrapper.append(this.nameLabelEl, clickableEl);
        this.contentWrapperEl.append(checkWrapper, canvasWrapperEl, nameWrapper, this.opacityEl);
        this.rootEl.append(this.contentWrapperEl);
        this.updateCheckerPatterns();
        (0, _theme.theme).addIsDarkListener(()=>{
            this.updateCheckerPatterns();
            this.draw(true);
        });
        // --- update logic ---
        // cross-fade done via 2 canvases (old and new state)
        // both have checkerboard background drawn on them, both fully opaque
        // -> no "lighter" is needed for accurate cross-fading
        setInterval(()=>{
            if (!this.layerObj) return;
            const currentState = (0, _klHistory.klHistory).getState();
            if (currentState === this.lastDrawnState) return;
            //update opacity w hack
            this.layerObj.opacity = this.layerObj.context.canvas.opacity;
            this.draw(false);
        }, 2000);
        const removeLargeCanvas = ()=>{
            this.largeCanvasWrapper.remove();
        };
        const showLargeCanvas = (b)=>{
            if (this.largeCanvasIsVisible === b) return;
            clearTimeout(largeCanvasAnimationTimeout);
            this.largeCanvasIsVisible = b;
            if (b) largeCanvasAnimationTimeout = setTimeout(()=>{
                this.drawLargeCanvas();
                this.largeCanvasWrapper.style.opacity = "0";
                p.klRootEl.append(this.largeCanvasWrapper);
                setTimeout(()=>{
                    this.largeCanvasWrapper.style.opacity = "1";
                }, 20);
            }, 250);
            else {
                this.largeCanvasWrapper.style.opacity = "0";
                largeCanvasAnimationTimeout = setTimeout(removeLargeCanvas, largeCanvasAnimationDurationMs + 20);
            }
        };
        const pointerListener = new (0, _bb.BB).PointerListener({
            target: this.canvas,
            onEnterLeave: (b)=>{
                showLargeCanvas(b);
            }
        });
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    setIsVisible(b) {
        if (this.isVisible === b) return;
        this.isVisible = b;
        this.contentWrapperEl.style.display = this.isVisible ? "flex" : "none";
        this.rootEl.style.marginBottom = this.isVisible ? "" : "10px";
        const currentState = (0, _klHistory.klHistory).getState();
        if (b && this.lastDrawnState !== currentState) this.draw(true);
    }
    //when the layer might have changed
    setLayer(klCanvasLayerObj) {
        this.layerObj = klCanvasLayerObj;
        this.draw(true);
    }
    setUiState(stateStr) {
        this.uiState = stateStr;
        if (this.uiState === "left") (0, _bb.BB).css(this.largeCanvasWrapper, {
            left: "280px",
            right: ""
        });
        else (0, _bb.BB).css(this.largeCanvasWrapper, {
            left: "",
            right: "280px"
        });
    }
}

},{"../../../bb/bb":"dcQKo","../../history/kl-history":"klzEn","../../../language/language":"iiYGN","../../../theme/theme":"4G3JB","../../../bb/base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aDt10":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showImportAsLayerDialog", ()=>showImportAsLayerDialog);
var _bb = require("../../../bb/bb");
var _freeTransformCanvas = require("../components/free-transform-canvas");
var _showModal = require("./base/showModal");
var _language = require("../../../language/language");
var _testIsSmall = require("../utils/test-is-small");
var _previewSize = require("../utils/preview-size");
function showImportAsLayerDialog(params) {
    const div = document.createElement("div");
    (0, _bb.BB).appendTextDiv(div, (0, _language.LANG)("import-as-layer-description"));
    if (params.klCanvas.isLayerLimitReached()) {
        const noteEl = (0, _bb.BB).el({
            content: (0, _language.LANG)("import-as-layer-limit-reached"),
            css: {
                background: "#ff0",
                padding: "10px",
                marginTop: "5px",
                marginBottom: "5px",
                border: "1px solid #e7d321",
                borderRadius: "5px"
            }
        });
        div.append(noteEl);
    }
    const isSmall = (0, _testIsSmall.testIsSmall)();
    const buttonRowEl = (0, _bb.BB).el({
        css: {
            display: "flex"
        }
    });
    const originalSizeBtn = (0, _bb.BB).el({
        tagName: "button",
        content: "1:1",
        css: {
            marginRight: "10px"
        },
        onClick: function() {
            freeTransformCanvas.reset();
        }
    });
    const fitSizeBtn = (0, _bb.BB).el({
        tagName: "button",
        content: (0, _language.LANG)("import-as-layer-fit"),
        css: {
            marginRight: "10px"
        },
        onClick: function() {
            freeTransformCanvas.setTransformFit();
        }
    });
    const centerBtn = (0, _bb.BB).el({
        tagName: "button",
        content: (0, _language.LANG)("center"),
        css: {
            marginRight: "10px"
        },
        onClick: function() {
            freeTransformCanvas.setTransformCenter();
        }
    });
    buttonRowEl.append(originalSizeBtn, fitSizeBtn, centerBtn);
    div.append(buttonRowEl);
    const layers = [];
    {
        const klCanvasLayerArr = params.klCanvas.getLayers();
        for(let i = 0; i < klCanvasLayerArr.length; i++)layers.push({
            image: klCanvasLayerArr[i].context.canvas,
            isVisible: klCanvasLayerArr[i].isVisible,
            opacity: klCanvasLayerArr[i].opacity,
            mixModeStr: klCanvasLayerArr[i].mixModeStr
        });
    }
    layers.push({
        image: params.importImage,
        isVisible: true,
        opacity: 1,
        mixModeStr: "source-over"
    });
    const freeTransformCanvas = new (0, _freeTransformCanvas.FreeTransformCanvas)({
        elementWidth: (0, _previewSize.getPreviewWidth)(isSmall),
        elementHeight: (0, _previewSize.getPreviewHeight)(isSmall) + 50,
        imageWidth: params.klCanvas.getLayerContext(0).canvas.width,
        imageHeight: params.klCanvas.getLayerContext(0).canvas.height,
        layers: layers,
        transformIndex: layers.length - 1
    });
    (0, _bb.BB).css(freeTransformCanvas.getElement(), {
        marginTop: "10px",
        marginLeft: "-20px"
    });
    div.append(freeTransformCanvas.getElement());
    function move(x, y) {
        freeTransformCanvas.move(x, y);
    }
    const keyListener = new (0, _bb.BB).KeyListener({
        onDown: function(keyStr) {
            if (keyStr === "left") move(-1, 0);
            if (keyStr === "right") move(1, 0);
            if (keyStr === "up") move(0, -1);
            if (keyStr === "down") move(0, 1);
        }
    });
    (0, _showModal.showModal)({
        target: params.target,
        message: `<b>${(0, _language.LANG)("import-as-layer-title")}</b>`,
        div: div,
        style: isSmall ? undefined : {
            width: "540px"
        },
        buttons: [
            "Ok",
            "Cancel"
        ],
        clickOnEnter: "Ok",
        callback: function(buttonStr) {
            keyListener.destroy();
            freeTransformCanvas.destroy();
            (0, _bb.BB).destroyEl(originalSizeBtn);
            (0, _bb.BB).destroyEl(fitSizeBtn);
            (0, _bb.BB).destroyEl(centerBtn);
            if (buttonStr === "Ok") params.callback(freeTransformCanvas.getTransformation(), freeTransformCanvas.getIsPixelated());
            else params.callback();
        }
    });
}

},{"../../../bb/bb":"dcQKo","../components/free-transform-canvas":"3quPq","./base/showModal":"hr9Po","../../../language/language":"iiYGN","../utils/test-is-small":"giqoI","../utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"giqoI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "testIsSmall", ()=>testIsSmall);
function testIsSmall() {
    return window.innerWidth < 550;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"llYOD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "smallPreview", ()=>smallPreview);
parcelHelpers.export(exports, "mediumPreview", ()=>mediumPreview);
parcelHelpers.export(exports, "getPreviewWidth", ()=>getPreviewWidth);
parcelHelpers.export(exports, "getPreviewHeight", ()=>getPreviewHeight);
const smallPreview = {
    width: 340,
    height: 220
};
const mediumPreview = {
    width: 540,
    height: 300
};
function getPreviewWidth(isSmall) {
    return isSmall ? smallPreview.width : mediumPreview.width;
}
function getPreviewHeight(isSmall) {
    return isSmall ? smallPreview.height : mediumPreview.height;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9RVJV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Not really generalized. UI when you drag/drop an image into window.
 * The moment you create it, it will listen.
 * */ parcelHelpers.export(exports, "KlImageDropper", ()=>KlImageDropper);
var _bb = require("../../../bb/bb");
class KlImageDropper {
    // ---- public ----
    constructor(p){
        //set up DOM
        this.rootEl = (0, _bb.BB).el({
            content: "Drop to import",
            css: {
                paddingTop: "100px",
                position: "fixed",
                left: "0",
                top: "0",
                width: "100%",
                height: "100%",
                background: "rgba(50, 50, 50, 0.7)",
                color: "#fff",
                textShadow: "2px 2px #000",
                textAlign: "center",
                fontSize: "25px"
            }
        });
        const wrapperEl = (0, _bb.BB).el({
            css: {
                "marginTop": "50px",
                "display": "flex",
                "justifyContent": "center"
            }
        });
        const optionStyle = {
            width: "200px",
            padding: "50px",
            margin: "10px",
            //opacity: 0.5,
            borderRadius: "20px",
            border: "1px dashed #fff",
            background: "#00aefe",
            fontWeight: "bold"
        };
        const optionLayerEl = (0, _bb.BB).el({
            content: "As Layer",
            css: optionStyle
        });
        const optionImageEl = (0, _bb.BB).el({
            content: "As New Image",
            css: optionStyle
        });
        this.rootEl.append(wrapperEl);
        wrapperEl.append(optionLayerEl, optionImageEl);
        let rootCounter = 0;
        let optionLayerCounter = 0;
        let optionImageCounter = 0;
        const destroy = ()=>{
            rootCounter = 0;
            optionLayerCounter = 0;
            optionImageCounter = 0;
            this.rootEl.remove();
        };
        /**
         * check, can drop content be imported
         */ const testAcceptType = (event)=>{
            return !!event.dataTransfer && !event.dataTransfer.types.includes("text/plain");
        };
        const updateOptions = ()=>{
            const boxShadow = "0 0 20px 4px #fff";
            if (optionLayerCounter > 0) {
                optionLayerEl.style.boxShadow = boxShadow;
                optionImageEl.style.boxShadow = "";
            } else if (optionImageCounter > 0) {
                optionLayerEl.style.boxShadow = "";
                optionImageEl.style.boxShadow = boxShadow;
            } else {
                optionLayerEl.style.boxShadow = "";
                optionImageEl.style.boxShadow = "";
            }
        };
        optionLayerEl.addEventListener("dragenter", ()=>{
            optionLayerCounter++;
            updateOptions();
        });
        optionLayerEl.addEventListener("dragleave", ()=>{
            optionLayerCounter--;
            updateOptions();
        });
        optionImageEl.addEventListener("dragenter", ()=>{
            optionImageCounter++;
            updateOptions();
        });
        optionImageEl.addEventListener("dragleave", ()=>{
            optionImageCounter--;
            updateOptions();
        });
        const rootDragOver = (event)=>{
            if (!testAcceptType(event)) return;
            event.stopPropagation();
            event.preventDefault();
        };
        const rootDragEnter = (event)=>{
            if (!p.enabledTest() || !testAcceptType(event)) return;
            if (rootCounter === 0) p.target.append(this.rootEl);
            rootCounter++;
        };
        const rootDragLeave = (event)=>{
            if (!testAcceptType(event) || rootCounter === 0) return;
            rootCounter = Math.max(0, rootCounter - 1);
            if (rootCounter === 0) this.rootEl.remove();
        };
        const rootDrop = (event)=>{
            if (!testAcceptType(event) || !event.dataTransfer || event.dataTransfer.files.length === 0) {
                destroy();
                return;
            }
            event.stopPropagation();
            event.preventDefault();
            let optionStr = "default";
            if (optionLayerCounter > 0) optionStr = "layer";
            else if (optionImageCounter > 0) optionStr = "image";
            p.onDrop(event.dataTransfer.files, optionStr);
            if (rootCounter > 0) this.rootEl.remove();
            rootCounter = 0;
            optionLayerCounter = 0;
            optionImageCounter = 0;
            updateOptions();
        };
        window.addEventListener("dragover", rootDragOver, false);
        window.addEventListener("dragenter", rootDragEnter, false);
        window.addEventListener("dragleave", rootDragLeave, false);
        window.addEventListener("drop", rootDrop, false);
        // if something goes wrong and you're stuck with overlay
        this.rootEl.addEventListener("pointerdown", ()=>{
            destroy();
        });
        const keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr)=>{
                if (rootCounter > 0 && keyStr === "esc") destroy();
            }
        });
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hWy6k":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Compressed HUD toolspace. When you hold ctrl+alt.
 * small color picker, brush settings
 */ parcelHelpers.export(exports, "OverlayToolspace", ()=>OverlayToolspace);
var _bb = require("../../../bb/bb");
var _klColorSliderSmall = require("./kl-color-slider-small");
var _klSlider = require("./kl-slider");
var _language = require("../../../language/language");
class OverlayToolspace {
    // ---- public ----
    constructor(p){
        const sizeObj = {
            width: 150,
            svHeight: 90,
            hHeight: 20,
            sliderHeight: 25
        };
        let isVisible = false;
        this.rootEl = (0, _bb.BB).el({
            className: "kl-overlay-toolspace"
        });
        const queuedObj = {
            color: null,
            size: null,
            opacity: null
        };
        // --- inputs ---
        //color selection
        const colorEl = (0, _bb.BB).el({
            parent: this.rootEl,
            className: "kl-overlay-toolspace__color"
        });
        const colorSlider = new (0, _klColorSliderSmall.KlColorSliderSmall)({
            width: sizeObj.width,
            heightSV: sizeObj.svHeight,
            heightH: sizeObj.hHeight,
            color: p.brushSettingService.getColor(),
            callback: (rgbObj)=>{
                selectedColorEl.style.backgroundColor = "rgb(" + rgbObj.r + "," + rgbObj.g + "," + rgbObj.b + ")";
                p.brushSettingService.setColor(rgbObj, subscriptionFunc);
            }
        });
        const selectedColorEl = (0, _bb.BB).el({
            css: {
                width: sizeObj.width + "px",
                height: sizeObj.hHeight + "px",
                pointerEvents: "none"
            }
        });
        {
            const initialColor = p.brushSettingService.getColor();
            selectedColorEl.style.backgroundColor = "rgb(" + initialColor.r + "," + initialColor.g + "," + initialColor.b + ")";
        }
        colorEl.append(selectedColorEl, colorSlider.getElement());
        const updateColor = (rgbObj)=>{
            colorSlider.setColor(rgbObj);
            selectedColorEl.style.backgroundColor = "rgb(" + rgbObj.r + "," + rgbObj.g + "," + rgbObj.b + ")";
        };
        //brushsize slider
        const sizeSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("brush-size"),
            width: sizeObj.width,
            height: sizeObj.sliderHeight,
            min: 0,
            max: 500,
            value: 50,
            resolution: 225,
            eventResMs: 1000 / 30,
            toDisplayValue: (val)=>val * 2,
            toValue: (displayValue)=>displayValue / 2,
            onChange: (v)=>{
                p.brushSettingService.setSize(v);
            },
            formatFunc: (displayValue)=>{
                if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                else return Math.round(displayValue);
            }
        });
        (0, _bb.BB).css(sizeSlider.getElement(), {
            marginTop: "2px"
        });
        const opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("opacity"),
            width: sizeObj.width,
            height: sizeObj.sliderHeight,
            min: 0,
            max: 1,
            value: 1,
            resolution: 225,
            eventResMs: 1000 / 30,
            toDisplayValue: (val)=>val * 100,
            toValue: (displayValue)=>displayValue / 100,
            onChange: (v)=>{
                p.brushSettingService.setOpacity(v);
            }
        });
        (0, _bb.BB).css(opacitySlider.getElement(), {
            margin: "2px 0"
        });
        this.rootEl.append(sizeSlider.getElement(), opacitySlider.getElement());
        // --- general setup ---
        const subscriptionFunc = (event)=>{
            if (event.type === "color") {
                if (!isVisible) queuedObj.color = event.value;
                else updateColor(event.value);
            }
            if (event.type === "size") {
                if (!isVisible) queuedObj.size = event.value;
                else sizeSlider.setValue(event.value);
            }
            if (event.type === "opacity") {
                if (!isVisible) queuedObj.opacity = event.value;
                else opacitySlider.setValue(event.value);
            }
            if (event.type === "sliderConfig") {
                sizeSlider.update(event.value.sizeSlider);
                opacitySlider.update(event.value.opacitySlider);
            }
        };
        p.brushSettingService.subscribe(subscriptionFunc);
        {
            const sliderConfig = p.brushSettingService.getSliderConfig();
            sizeSlider.update(sliderConfig.sizeSlider);
            opacitySlider.update(sliderConfig.opacitySlider);
            sizeSlider.setValue(p.brushSettingService.getSize());
            opacitySlider.setValue(p.brushSettingService.getOpacity());
        }
        const updateUI = ()=>{
            // unfocus manual slider input
            (0, _bb.BB).unfocusAnyInput();
            this.rootEl.style.display = isVisible ? "block" : "none";
            if (isVisible && mousePos) (0, _bb.BB).css(this.rootEl, {
                left: mousePos.x - Math.round(sizeObj.width / 2) + "px",
                top: mousePos.y - Math.round(sizeObj.svHeight + sizeObj.hHeight * 3 / 2) + "px"
            });
        };
        let mousePos = null;
        document.addEventListener("pointermove", (event)=>{
            mousePos = {
                x: event.pageX,
                y: event.pageY
            };
        });
        const keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr, event, comboStr, isRepeat)=>{
                if (isRepeat) return;
                if (isVisible) {
                    isVisible = false;
                    updateUI();
                    return;
                }
                if (!p.enabledTest() || !mousePos) return;
                if ([
                    "ctrl+alt",
                    "cmd+alt",
                    "alt+ctrl",
                    "alt+cmd"
                ].includes(comboStr)) {
                    event.preventDefault();
                    isVisible = true;
                    if (queuedObj.color !== null) {
                        updateColor(queuedObj.color);
                        queuedObj.color = null;
                    }
                    if (queuedObj.size !== null) {
                        sizeSlider.setValue(queuedObj.size);
                        queuedObj.size = null;
                    }
                    if (queuedObj.opacity !== null) {
                        opacitySlider.setValue(queuedObj.opacity);
                        queuedObj.opacity = null;
                    }
                    updateUI();
                }
            },
            onUp: (keyStr, event, oldComboStr)=>{
                if ([
                    "ctrl+alt",
                    "cmd+alt",
                    "alt+ctrl",
                    "alt+cmd"
                ].includes(oldComboStr) && isVisible) {
                    isVisible = false;
                    colorSlider.end();
                    updateUI();
                }
            },
            onBlur: ()=>{
                if (isVisible) {
                    isVisible = false;
                    colorSlider.end();
                    updateUI();
                }
            }
        });
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"dcQKo","./kl-color-slider-small":"jJnMO","./kl-slider":"4hcvv","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fltn0":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Topmost row of buttons in toolspace (with the app logo)
 */ parcelHelpers.export(exports, "ToolspaceTopRow", ()=>ToolspaceTopRow);
var _bb = require("../../../bb/bb");
var _klecksLogoPng = require("/src/app/img/klecks-logo.png");
var _klecksLogoPngDefault = parcelHelpers.interopDefault(_klecksLogoPng);
var _newImageSvg = require("/src/app/img/ui/new-image.svg");
var _newImageSvgDefault = parcelHelpers.interopDefault(_newImageSvg);
var _importSvg = require("/src/app/img/ui/import.svg");
var _importSvgDefault = parcelHelpers.interopDefault(_importSvg);
var _exportSvg = require("/src/app/img/ui/export.svg");
var _exportSvgDefault = parcelHelpers.interopDefault(_exportSvg);
var _shareSvg = require("/src/app/img/ui/share.svg");
var _shareSvgDefault = parcelHelpers.interopDefault(_shareSvg);
var _helpSvg = require("/src/app/img/ui/help.svg");
var _helpSvgDefault = parcelHelpers.interopDefault(_helpSvg);
var _language = require("../../../language/language");
class ToolspaceTopRow {
    // ---- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            className: "kl-toolspace-row",
            css: {
                height: "36px",
                display: "flex"
            }
        });
        function createButton(p) {
            const padding = 6 + (p.extraPadding ? p.extraPadding : 0);
            const el = (0, _bb.BB).el({
                className: "toolspace-row-button nohighlight",
                title: p.title,
                onClick: p.onClick,
                css: {
                    padding: p.contain ? padding + "px 0" : ""
                }
            });
            const im = (0, _bb.BB).el({
                className: p.darkInvert ? "dark-invert" : undefined,
                css: {
                    backgroundImage: "url('" + p.image + "')",
                    backgroundRepeat: "no-repeat",
                    backgroundPosition: "center",
                    backgroundSize: p.contain ? "contain" : "",
                    //filter: 'grayscale(1)',
                    height: "100%"
                }
            });
            im.style.pointerEvents = "none";
            el.append(im);
            const pointerListener = new (0, _bb.BB).PointerListener({
                target: el,
                onEnterLeave: function(isOver) {
                    el.classList.toggle("toolspace-row-button-hover", isOver);
                }
            });
            return {
                el,
                pointerListener
            };
        }
        const logoButton = createButton({
            onClick: p.onLogo,
            title: (0, _language.LANG)("home"),
            image: p.logoImg ? p.logoImg : (0, _klecksLogoPngDefault.default),
            contain: true,
            darkInvert: true
        });
        logoButton.el.classList.add("kl-tool-row-border-right");
        (0, _bb.BB).css(logoButton.el, {
            width: "46px"
        });
        const newButton = createButton({
            onClick: p.onNew,
            title: (0, _language.LANG)("file-new"),
            image: (0, _newImageSvgDefault.default),
            extraPadding: 1,
            contain: true
        });
        const importButton = createButton({
            onClick: p.onImport,
            title: (0, _language.LANG)("file-import"),
            image: (0, _importSvgDefault.default),
            extraPadding: 1,
            contain: true
        });
        const saveButton = createButton({
            onClick: p.onSave,
            title: (0, _language.LANG)("file-save"),
            image: (0, _exportSvgDefault.default),
            extraPadding: 1,
            contain: true
        });
        let shareButton = null;
        if ((0, _bb.BB).canShareFiles()) shareButton = createButton({
            onClick: p.onShare,
            title: (0, _language.LANG)("file-share"),
            image: (0, _shareSvgDefault.default),
            contain: true,
            darkInvert: true
        });
        const helpButton = createButton({
            onClick: p.onHelp,
            title: (0, _language.LANG)("help"),
            image: (0, _helpSvgDefault.default),
            contain: true,
            darkInvert: true
        });
        (0, _bb.BB).append(this.rootEl, [
            logoButton.el,
            newButton.el,
            importButton.el,
            saveButton.el,
            shareButton ? shareButton.el : undefined,
            helpButton.el
        ]);
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"dcQKo","/src/app/img/klecks-logo.png":"l2ndI","/src/app/img/ui/new-image.svg":"fjjGc","/src/app/img/ui/import.svg":"aqqZd","/src/app/img/ui/export.svg":"kaStO","/src/app/img/ui/share.svg":"eS7Vq","/src/app/img/ui/help.svg":"e1IQ4","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l2ndI":[function(require,module,exports) {
module.exports = require("f2456243f9d38501").getBundleURL("d3gnI") + "klecks-logo.a5145675.png" + "?" + Date.now();

},{"f2456243f9d38501":"lgJ39"}],"fjjGc":[function(require,module,exports) {
module.exports = require("8c6a9a27203562e6").getBundleURL("d3gnI") + "new-image.38d5fae1.svg" + "?" + Date.now();

},{"8c6a9a27203562e6":"lgJ39"}],"aqqZd":[function(require,module,exports) {
module.exports = require("33fb2f5581b8e6a0").getBundleURL("d3gnI") + "import.f22da78a.svg" + "?" + Date.now();

},{"33fb2f5581b8e6a0":"lgJ39"}],"kaStO":[function(require,module,exports) {
module.exports = require("7792ac74ef6f9ce0").getBundleURL("d3gnI") + "export.abffd7d2.svg" + "?" + Date.now();

},{"7792ac74ef6f9ce0":"lgJ39"}],"eS7Vq":[function(require,module,exports) {
module.exports = require("b99972267c8e7a12").getBundleURL("d3gnI") + "share.fb29aac6.svg" + "?" + Date.now();

},{"b99972267c8e7a12":"lgJ39"}],"e1IQ4":[function(require,module,exports) {
module.exports = require("2c1a40b3da39f09b").getBundleURL("d3gnI") + "help.d5fd5dcd.svg" + "?" + Date.now();

},{"2c1a40b3da39f09b":"lgJ39"}],"3fI3r":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Toolrow Dropdown. The button where you select: brush, fill, select, transform, etc.
 */ parcelHelpers.export(exports, "ToolDropdown", ()=>ToolDropdown);
var _bb = require("../../../bb/bb");
var _modalCount = require("../modals/modal-count");
var _toolPaintSvg = require("/src/app/img/ui/tool-paint.svg");
var _toolPaintSvgDefault = parcelHelpers.interopDefault(_toolPaintSvg);
var _toolFillSvg = require("/src/app/img/ui/tool-fill.svg");
var _toolFillSvgDefault = parcelHelpers.interopDefault(_toolFillSvg);
var _toolGradientSvg = require("/src/app/img/ui/tool-gradient.svg");
var _toolGradientSvgDefault = parcelHelpers.interopDefault(_toolGradientSvg);
var _toolTextSvg = require("/src/app/img/ui/tool-text.svg");
var _toolTextSvgDefault = parcelHelpers.interopDefault(_toolTextSvg);
var _toolShapeSvg = require("/src/app/img/ui/tool-shape.svg");
var _toolShapeSvgDefault = parcelHelpers.interopDefault(_toolShapeSvg);
var _caretDownSvg = require("/src/app/img/ui/caret-down.svg");
var _caretDownSvgDefault = parcelHelpers.interopDefault(_caretDownSvg);
var _language = require("../../../language/language");
class ToolDropdown {
    updateButton() {
        this.activeButton.title = this.titleArr[this.currentActiveIndex];
        this.activeButtonIm.style.backgroundImage = "url('" + this.imArr[this.currentActiveIndex] + "')";
    }
    // ---- public ----
    constructor(p){
        this.smallMargin = "6px 0";
        this.optionArr = [
            "draw",
            "fill",
            "gradient",
            "text",
            "shape"
        ];
        this.imArr = [
            (0, _toolPaintSvgDefault.default),
            (0, _toolFillSvgDefault.default),
            (0, _toolGradientSvgDefault.default),
            (0, _toolTextSvgDefault.default),
            (0, _toolShapeSvgDefault.default)
        ];
        this.titleArr = [
            `${(0, _language.LANG)("tool-brush")} [B]`,
            `${(0, _language.LANG)("tool-paint-bucket")} [G]`,
            `${(0, _language.LANG)("tool-gradient")} [G]`,
            `${(0, _language.LANG)("tool-text")} [T]`,
            `${(0, _language.LANG)("tool-shape")} [U]`
        ];
        this.currentActiveIndex = 0;
        this.isActive = true;
        let isOpen = false;
        //preload images
        setTimeout(()=>{
            for(let i = 1; i < this.imArr.length; i++){
                const im = new Image();
                im.src = this.imArr[i];
            }
        }, 100);
        this.rootEl = (0, _bb.BB).el({
            css: {
                position: "relative",
                flexGrow: "1"
            }
        });
        let openTimeout;
        let isDragging = false;
        let startX;
        let startY;
        let pointerListener;
        if ((0, _bb.BB).hasPointerEvents) pointerListener = new (0, _bb.BB).PointerListener({
            target: this.rootEl,
            onPointer: (event)=>{
                if (event.type === "pointerdown") {
                    if (isOpen) return;
                    openTimeout = setTimeout(()=>{
                        showDropdown();
                    }, 400);
                    isDragging = true;
                    startX = event.pageX;
                    startY = event.pageY;
                } else if (event.type === "pointermove") {
                    if (isDragging && !isOpen && (0, _bb.BB).dist(startX, startY, event.pageX, event.pageY) > 5) {
                        clearTimeout(openTimeout);
                        showDropdown();
                    }
                } else if (event.type === "pointerup") {
                    clearTimeout(openTimeout);
                    if (isOpen && isDragging) {
                        const target = document.elementFromPoint(event.pageX, event.pageY);
                        for(let i = 0; i < this.dropdownBtnArr.length; i++)if (target === this.dropdownBtnArr[i].wrapper) {
                            closeDropdown();
                            this.isActive = true;
                            this.currentActiveIndex = i;
                            this.updateButton();
                            p.onChange(this.optionArr[this.currentActiveIndex]);
                            break;
                        }
                    }
                    isDragging = false;
                }
            }
        });
        this.activeButton = (0, _bb.BB).el({
            parent: this.rootEl,
            className: "toolspace-row-button nohighlight toolspace-row-button-activated",
            title: this.titleArr[this.currentActiveIndex],
            onClick: (e)=>{
                if (this.isActive && !isOpen) {
                    e.preventDefault();
                    e.stopPropagation();
                    showDropdown();
                    return;
                }
                this.isActive = true;
                p.onChange(this.optionArr[this.currentActiveIndex]);
                if (isOpen) closeDropdown();
            },
            css: {
                padding: "10px 0",
                pointerEvents: "auto",
                height: "100%",
                boxSizing: "border-box"
            }
        });
        this.activeButtonIm = (0, _bb.BB).el({
            parent: this.activeButton,
            className: "dark-invert",
            css: {
                backgroundRepeat: "no-repeat",
                backgroundPosition: "center",
                backgroundSize: "contain",
                width: "calc(100% - 7px)",
                height: "100%",
                pointerEvents: "none",
                opacity: "0.75"
            }
        });
        this.arrowButton = (0, _bb.BB).el({
            parent: this.activeButton,
            className: "dark-invert",
            css: {
                position: "absolute",
                right: "1px",
                bottom: "1px",
                width: "18px",
                height: "18px",
                //background: '#aaa',
                //borderRadius: '2px',
                cursor: "pointer",
                backgroundImage: "url('" + (0, _caretDownSvgDefault.default) + "')",
                backgroundRepeat: "no-repeat",
                backgroundPosition: "center",
                backgroundSize: "60%"
            },
            title: "More Tools",
            onClick: (e)=>{
                e.preventDefault();
                e.stopPropagation();
                showDropdown();
            }
        });
        const overlay = (0, _bb.BB).el({
            css: {
                position: "absolute",
                //background: 'rgba(255,0,0,0.5)',
                left: "0",
                top: "0",
                right: "0",
                bottom: "0"
            }
        });
        const overlayPointerListener = new (0, _bb.BB).PointerListener({
            target: overlay,
            onPointer: (e)=>{
                if (e.type === "pointerdown") {
                    e.eventPreventDefault();
                    closeDropdown();
                }
            }
        });
        const dropdownWrapper = (0, _bb.BB).el({
            className: "tool-dropdown-wrapper",
            css: {
                position: "absolute",
                width: "100%",
                height: 100 * (this.optionArr.length - 1) + "%",
                top: "100%",
                left: "0",
                zIndex: "1",
                boxSizing: "border-box",
                cursor: "pointer",
                transition: "height 0.1s ease-in-out, opacity 0.1s ease-in-out",
                borderBottomLeftRadius: "5px",
                borderBottomRightRadius: "5px",
                overflow: "hidden"
            }
        });
        this.dropdownBtnArr = [];
        const createDropdownButton = (p)=>{
            const wrapper = (0, _bb.BB).el({
                parent: dropdownWrapper,
                className: "tool-dropdown-button",
                title: p.title,
                css: {
                    padding: "10px 0",
                    height: 100 / (this.optionArr.length - 1) + "%",
                    boxSizing: "border-box"
                },
                onClick: (e)=>{
                    e.preventDefault();
                    e.stopPropagation();
                    p.onClick(p.index);
                }
            });
            (0, _bb.BB).el({
                parent: wrapper,
                className: "dark-invert",
                css: {
                    backgroundImage: "url('" + p.image + "')",
                    backgroundRepeat: "no-repeat",
                    backgroundPosition: "center",
                    backgroundSize: "contain",
                    height: "100%",
                    pointerEvents: "none",
                    opacity: "0.75"
                }
            });
            // --- interface ---
            const show = (b)=>{
                wrapper.style.display = b ? "block" : "none";
            };
            const setIsSmall = (b)=>{
                wrapper.style.padding = b ? this.smallMargin : "10px 0";
            };
            return {
                wrapper,
                show,
                setIsSmall
            };
        };
        const onClickDropdownBtn = (index)=>{
            closeDropdown();
            this.isActive = true;
            this.currentActiveIndex = index;
            this.updateButton();
            p.onChange(this.optionArr[this.currentActiveIndex]);
        };
        for(let i = 0; i < this.optionArr.length; i++)this.dropdownBtnArr.push(createDropdownButton({
            index: i,
            id: this.optionArr[i],
            image: this.imArr[i],
            title: this.titleArr[i],
            onClick: onClickDropdownBtn
        }));
        const showDropdown = ()=>{
            (0, _modalCount.dialogCounter).increase(0.5);
            isOpen = true;
            for(let i = 0; i < this.optionArr.length; i++)this.dropdownBtnArr[i].show(this.currentActiveIndex !== i);
            this.arrowButton.style.display = "none";
            this.rootEl.style.zIndex = "1";
            document.body.append(overlay);
            this.rootEl.append(dropdownWrapper);
        };
        const closeDropdown = ()=>{
            (0, _modalCount.dialogCounter).decrease(0.5);
            isOpen = false;
            this.arrowButton.style.removeProperty("display");
            this.rootEl.style.removeProperty("z-index");
            overlay.remove();
            dropdownWrapper.remove();
        };
        this.updateButton();
    }
    // ---- interface ----
    setIsSmall(b) {
        this.activeButton.style.padding = b ? this.smallMargin : "10px 0";
        for(let i = 0; i < this.optionArr.length; i++)this.dropdownBtnArr[i].setIsSmall(b);
        if (b) {
            this.arrowButton.style.width = "14px";
            this.arrowButton.style.height = "14px";
        } else {
            this.arrowButton.style.width = "18px";
            this.arrowButton.style.height = "18px";
        }
    }
    setActive(activeStr) {
        if (this.optionArr.includes(activeStr)) {
            this.isActive = true;
            for(let i = 0; i < this.optionArr.length; i++)if (this.optionArr[i] === activeStr) {
                this.currentActiveIndex = i;
                break;
            }
            this.activeButton.classList.add("toolspace-row-button-activated");
            this.updateButton();
        } else {
            this.isActive = false;
            this.activeButton.classList.remove("toolspace-row-button-activated");
        }
    }
    getActive() {
        return this.optionArr[this.currentActiveIndex];
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"dcQKo","../modals/modal-count":"lsSVM","/src/app/img/ui/tool-paint.svg":"cAWlT","/src/app/img/ui/tool-fill.svg":"fT68h","/src/app/img/ui/tool-gradient.svg":"er4Xu","/src/app/img/ui/tool-text.svg":"jYwrt","/src/app/img/ui/tool-shape.svg":"3ZxcT","/src/app/img/ui/caret-down.svg":"E9FPv","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cAWlT":[function(require,module,exports) {
module.exports = require("2a4a463edc69933a").getBundleURL("d3gnI") + "tool-paint.3b54bb57.svg" + "?" + Date.now();

},{"2a4a463edc69933a":"lgJ39"}],"fT68h":[function(require,module,exports) {
module.exports = require("95c1a7ffa8778eb7").getBundleURL("d3gnI") + "tool-fill.33373232.svg" + "?" + Date.now();

},{"95c1a7ffa8778eb7":"lgJ39"}],"er4Xu":[function(require,module,exports) {
module.exports = require("3b08676504adc917").getBundleURL("d3gnI") + "tool-gradient.d894f221.svg" + "?" + Date.now();

},{"3b08676504adc917":"lgJ39"}],"jYwrt":[function(require,module,exports) {
module.exports = require("1821fbb853b85349").getBundleURL("d3gnI") + "tool-text.33314b25.svg" + "?" + Date.now();

},{"1821fbb853b85349":"lgJ39"}],"3ZxcT":[function(require,module,exports) {
module.exports = require("20dc0ffb6cb77ae").getBundleURL("d3gnI") + "tool-shape.0f3cd4be.svg" + "?" + Date.now();

},{"20dc0ffb6cb77ae":"lgJ39"}],"eTege":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Row of buttons in toolspace. image-operations (draw, hand), zoom, undo/redo
 * Need to do syncing. So tool is correct, and zoom/undo/redo buttons are properly enabled/disabled
 * heights: 54px tall, 36px small -> via setIsSmall
 */ parcelHelpers.export(exports, "ToolspaceToolRow", ()=>ToolspaceToolRow);
var _bb = require("../../../bb/bb");
var _toolDropdown = require("./tool-dropdown");
var _toolHandSvg = require("/src/app/img/ui/tool-hand.svg");
var _toolHandSvgDefault = parcelHelpers.interopDefault(_toolHandSvg);
var _toolZoomInSvg = require("/src/app/img/ui/tool-zoom-in.svg");
var _toolZoomInSvgDefault = parcelHelpers.interopDefault(_toolZoomInSvg);
var _toolZoomOutSvg = require("/src/app/img/ui/tool-zoom-out.svg");
var _toolZoomOutSvgDefault = parcelHelpers.interopDefault(_toolZoomOutSvg);
var _toolUndoSvg = require("/src/app/img/ui/tool-undo.svg");
var _toolUndoSvgDefault = parcelHelpers.interopDefault(_toolUndoSvg);
var _language = require("../../../language/language");
class ToolspaceToolRow {
    // ---- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            className: "kl-toolspace-row",
            css: {
                height: "54px",
                display: "flex"
            }
        });
        this.onActivate = p.onActivate;
        this.currentActiveStr = "draw"; // 'draw' | 'hand' | 'fill'
        const createButton = (p)=>{
            const smallMargin = p.doLighten ? "6px 0" : "8px 0";
            const el = (0, _bb.BB).el({
                className: "toolspace-row-button nohighlight",
                //title: p.title,
                onClick: p.onClick,
                css: {
                    padding: p.contain ? "10px 0" : ""
                }
            });
            const im = (0, _bb.BB).el({
                className: "dark-invert",
                css: {
                    backgroundImage: "url('" + p.image + "')",
                    backgroundRepeat: "no-repeat",
                    backgroundPosition: "center",
                    backgroundSize: p.contain ? "contain" : "",
                    //filter: 'grayscale(1)',
                    height: "100%",
                    transform: p.doMirror ? "scale(-1, 1)" : "",
                    pointerEvents: "none",
                    opacity: p.doLighten ? "0.75" : "1"
                }
            });
            el.append(im);
            const pointerListener = new (0, _bb.BB).PointerListener({
                target: el,
                onEnterLeave: (isOver)=>{
                    el.classList.toggle("toolspace-row-button-hover", isOver);
                }
            });
            const setIsSmall = (b)=>{
                el.style.padding = p.contain ? b ? smallMargin : "10px 0" : "";
            };
            return {
                el,
                pointerListener,
                setIsSmall
            };
        };
        const createTriangleButton = (p)=>{
            const result = (0, _bb.BB).el({
                css: {
                    flexGrow: "1",
                    position: "relative"
                }
            });
            const svg = (0, _bb.BB).createSvg({
                elementType: "svg",
                width: "67px",
                height: "54px",
                viewBox: "0 0 100 100",
                preserveAspectRatio: "none"
            });
            (0, _bb.BB).css(svg, {
                position: "absolute",
                left: "0",
                top: "0"
            });
            const blurRadius = 10;
            const blurOffsetX = 2;
            const blurOffsetY = 2;
            const defs = (0, _bb.BB).createSvg({
                elementType: "defs",
                childrenArr: [
                    {
                        elementType: "filter",
                        id: "innershadow",
                        x0: "-50%",
                        y0: "-50%",
                        width: "200%",
                        height: "200%",
                        childrenArr: [
                            {
                                elementType: "feGaussianBlur",
                                in: "SourceAlpha",
                                stdDeviation: "" + blurRadius,
                                result: "blur"
                            },
                            {
                                elementType: "feOffset",
                                dx: "" + blurOffsetX,
                                dy: "" + blurOffsetY
                            },
                            {
                                elementType: "feComposite",
                                in2: "SourceAlpha",
                                operator: "arithmetic",
                                k2: "-1",
                                k3: "1",
                                result: "shadowDiff"
                            },
                            {
                                elementType: "feFlood",
                                "flood-color": "#000",
                                "flood-opacity": "0.2"
                            },
                            {
                                elementType: "feComposite",
                                in2: "shadowDiff",
                                operator: "in"
                            },
                            {
                                elementType: "feComposite",
                                in2: "SourceGraphic",
                                operator: "over",
                                result: "firstfilter"
                            },
                            {
                                elementType: "feGaussianBlur",
                                in: "firstfilter",
                                stdDeviation: "" + blurRadius,
                                result: "blur2"
                            },
                            {
                                elementType: "feOffset",
                                dx: "" + blurOffsetX,
                                dy: "" + blurOffsetY
                            },
                            {
                                elementType: "feComposite",
                                in2: "firstfilter",
                                operator: "arithmetic",
                                k2: "-1",
                                k3: "1",
                                result: "shadowDiff"
                            },
                            {
                                elementType: "feFlood",
                                "flood-color": "#000",
                                "flood-opacity": "0.2"
                            },
                            {
                                elementType: "feComposite",
                                in2: "shadowDiff",
                                operator: "in"
                            },
                            {
                                elementType: "feComposite",
                                in2: "firstfilter",
                                operator: "over"
                            }
                        ]
                    }
                ]
            });
            const svgTriangleLeft = (0, _bb.BB).createSvg({
                elementType: "path",
                "vector-effect": "non-scaling-stroke",
                d: "M0,0 L 100,0 0,100 z",
                fill: "rgba(0,0,0,0)",
                class: "toolspace-svg-triangle-button"
            });
            svgTriangleLeft.onclick = ()=>{
                p.onLeft();
                svgTriangleLeft.classList.remove("toolspace-svg-triangle-button-hover");
            };
            const svgTriangleRight = (0, _bb.BB).createSvg({
                elementType: "path",
                "vector-effect": "non-scaling-stroke",
                d: "M100,100 L 100,0 0,100 z",
                fill: "rgba(0,0,0,0)",
                class: "toolspace-svg-triangle-button"
            });
            svgTriangleRight.onclick = ()=>{
                p.onRight();
                svgTriangleRight.classList.remove("toolspace-svg-triangle-button-hover");
            };
            // because :hover causes problems w touch
            const leftPointerListener = new (0, _bb.BB).PointerListener({
                target: svgTriangleLeft,
                onEnterLeave: (isOver)=>{
                    svgTriangleLeft.classList.toggle("toolspace-svg-triangle-button-hover", isOver);
                }
            });
            const rightPointerListener = new (0, _bb.BB).PointerListener({
                target: svgTriangleRight,
                onEnterLeave: (isOver)=>{
                    svgTriangleRight.classList.toggle("toolspace-svg-triangle-button-hover", isOver);
                }
            });
            svg.append(defs, svgTriangleLeft, svgTriangleRight);
            result.append(svg);
            const leftIm = (0, _bb.BB).el({
                parent: result,
                className: "dark-invert",
                css: {
                    backgroundImage: "url('" + p.leftImage + "')",
                    backgroundRepeat: "no-repeat",
                    backgroundSize: "contain",
                    width: "20px",
                    height: "20px",
                    position: "absolute",
                    left: "10px",
                    top: "8px",
                    //transform: p.doMirror ? 'scale(-1, 1)' : '',
                    pointerEvents: "none"
                }
            });
            result.append(leftIm);
            const rightIm = (0, _bb.BB).el({
                parent: result,
                className: "dark-invert",
                css: {
                    backgroundImage: "url('" + (p.rightImage ? p.rightImage : p.leftImage) + "')",
                    backgroundRepeat: "no-repeat",
                    backgroundSize: "contain",
                    width: "20px",
                    height: "20px",
                    position: "absolute",
                    right: "10px",
                    bottom: "8px",
                    transform: p.rightImage ? "" : "scale(-1, 1)",
                    pointerEvents: "none"
                }
            });
            const setIsEnabledLeft = (b)=>{
                svgTriangleLeft.classList.toggle("toolspace-row-button-disabled", !b);
                leftIm.classList.toggle("toolspace-row-button-disabled", !b);
            };
            const setIsEnabledRight = (b)=>{
                svgTriangleRight.classList.toggle("toolspace-row-button-disabled", !b);
                rightIm.classList.toggle("toolspace-row-button-disabled", !b);
            };
            return {
                el: result,
                setIsEnabledLeft,
                setIsEnabledRight,
                leftPointerListener,
                rightPointerListener
            };
        };
        this.toolDropdown = new (0, _toolDropdown.ToolDropdown)({
            onChange: (activeStr)=>{
                this.setActive(activeStr, true);
            }
        });
        this.rootEl.append(this.toolDropdown.getElement());
        this.handButton = createButton({
            onClick: ()=>{
                this.setActive("hand", true);
            },
            image: (0, _toolHandSvgDefault.default),
            contain: true,
            doLighten: true
        });
        this.handButton.el.classList.add("kl-tool-row-border-right");
        this.handButton.el.title = (0, _language.LANG)("tool-hand");
        this.rootEl.append(this.handButton.el);
        this.zoomInNOutButton = createTriangleButton({
            onLeft: p.onZoomIn,
            onRight: p.onZoomOut,
            leftImage: (0, _toolZoomInSvgDefault.default),
            rightImage: (0, _toolZoomOutSvgDefault.default)
        });
        this.zoomInNOutButton.el.title = (0, _language.LANG)("tool-zoom");
        this.rootEl.append(this.zoomInNOutButton.el);
        this.zoomInButton = createButton({
            onClick: p.onZoomIn,
            image: (0, _toolZoomInSvgDefault.default),
            contain: true
        });
        this.zoomInButton.el.title = (0, _language.LANG)("zoom-in");
        this.rootEl.append(this.zoomInButton.el);
        this.zoomOutButton = createButton({
            onClick: p.onZoomOut,
            image: (0, _toolZoomOutSvgDefault.default),
            contain: true
        });
        this.zoomOutButton.el.title = (0, _language.LANG)("zoom-out");
        this.rootEl.append(this.zoomOutButton.el);
        this.undoNRedoButton = createTriangleButton({
            onLeft: p.onUndo,
            onRight: p.onRedo,
            leftImage: (0, _toolUndoSvgDefault.default),
            rightImage: null
        });
        this.undoNRedoButton.el.title = (0, _language.LANG)("undo") + "/" + (0, _language.LANG)("redo");
        this.undoNRedoButton.setIsEnabledLeft(false);
        this.undoNRedoButton.setIsEnabledRight(false);
        this.rootEl.append(this.undoNRedoButton.el);
        this.undoButton = createButton({
            onClick: p.onUndo,
            image: (0, _toolUndoSvgDefault.default),
            contain: true
        });
        this.undoButton.el.title = (0, _language.LANG)("undo");
        this.undoButton.el.classList.add("toolspace-row-button-disabled");
        this.rootEl.append(this.undoButton.el);
        this.redoButton = createButton({
            onClick: p.onRedo,
            image: (0, _toolUndoSvgDefault.default),
            contain: true,
            doMirror: true
        });
        this.redoButton.el.title = (0, _language.LANG)("redo");
        this.redoButton.el.classList.add("toolspace-row-button-disabled");
        this.rootEl.append(this.redoButton.el);
        this.zoomInButton.el.style.display = "none";
        this.zoomOutButton.el.style.display = "none";
        this.undoButton.el.style.display = "none";
        this.redoButton.el.style.display = "none";
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    setIsSmall(b) {
        (0, _bb.BB).css(this.rootEl, {
            height: b ? "36px" : "54px"
        });
        this.toolDropdown.setIsSmall(b);
        this.handButton.setIsSmall(b);
        this.zoomInButton.setIsSmall(b);
        this.zoomOutButton.setIsSmall(b);
        this.undoButton.setIsSmall(b);
        this.redoButton.setIsSmall(b);
        if (b) {
            this.zoomInNOutButton.el.style.display = "none";
            this.undoNRedoButton.el.style.display = "none";
            this.zoomInButton.el.style.display = "block";
            this.zoomOutButton.el.style.display = "block";
            this.undoButton.el.style.display = "block";
            this.redoButton.el.style.display = "block";
        } else {
            this.zoomInNOutButton.el.style.display = "block";
            this.undoNRedoButton.el.style.display = "block";
            this.zoomInButton.el.style.display = "none";
            this.zoomOutButton.el.style.display = "none";
            this.undoButton.el.style.display = "none";
            this.redoButton.el.style.display = "none";
        }
    }
    setEnableZoomIn(b) {
        this.zoomInButton.el.classList.toggle("toolspace-row-button-disabled", !b);
        this.zoomInNOutButton.setIsEnabledLeft(b);
    }
    setEnableZoomOut(b) {
        this.zoomOutButton.el.classList.toggle("toolspace-row-button-disabled", !b);
        this.zoomInNOutButton.setIsEnabledRight(b);
    }
    setEnableUndo(b) {
        this.undoButton.el.classList.toggle("toolspace-row-button-disabled", !b);
        this.undoNRedoButton.setIsEnabledLeft(b);
    }
    setEnableRedo(b) {
        this.redoButton.el.classList.toggle("toolspace-row-button-disabled", !b);
        this.undoNRedoButton.setIsEnabledRight(b);
    }
    setActive(activeStr, doEmit) {
        if (this.currentActiveStr === activeStr) return;
        this.currentActiveStr = activeStr;
        this.toolDropdown.setActive(this.currentActiveStr);
        this.handButton.el.classList.toggle("toolspace-row-button-activated", this.currentActiveStr === "hand");
        if (doEmit) this.onActivate(this.currentActiveStr);
    }
    getActive() {
        return this.currentActiveStr;
    }
}

},{"../../../bb/bb":"dcQKo","./tool-dropdown":"3fI3r","/src/app/img/ui/tool-hand.svg":"anjr6","/src/app/img/ui/tool-zoom-in.svg":"cnuMH","/src/app/img/ui/tool-zoom-out.svg":"9Sixr","/src/app/img/ui/tool-undo.svg":"3JepG","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3JepG":[function(require,module,exports) {
module.exports = require("9a4c6927a0f47b33").getBundleURL("d3gnI") + "tool-undo.4ac4ddba.svg" + "?" + Date.now();

},{"9a4c6927a0f47b33":"lgJ39"}],"84zrw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Ui to select stabilizer level. 4 options. returned as 0-3
 */ parcelHelpers.export(exports, "ToolspaceStabilizerRow", ()=>ToolspaceStabilizerRow);
var _bb = require("../../../bb/bb");
var _select = require("./select");
var _language = require("../../../language/language");
class ToolspaceStabilizerRow {
    // ---- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            tagName: "label",
            className: "kl-stabilizer",
            content: (0, _language.LANG)("stabilizer") + "&nbsp;",
            title: (0, _language.LANG)("stabilizer-title")
        });
        const strengthSelect = new (0, _select.Select)({
            optionArr: [
                [
                    "0",
                    "0"
                ],
                [
                    "1",
                    "1"
                ],
                [
                    "2",
                    "2"
                ],
                [
                    "3",
                    "3"
                ],
                [
                    "4",
                    "4"
                ],
                [
                    "5",
                    "5"
                ]
            ],
            initValue: "" + p.smoothing,
            onChange: function(val) {
                p.onSelect(parseInt(val));
            }
        });
        this.rootEl.append(strengthSelect.getElement());
        this.pointerListener = new (0, _bb.BB).PointerListener({
            target: this.rootEl,
            onWheel: function(e) {
                strengthSelect.setDeltaValue(e.deltaY);
            }
        });
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"dcQKo","./select":"jmugN","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fLnal":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * row of tabs. uses css class .tabrow__tab
 */ parcelHelpers.export(exports, "TabRow", ()=>TabRow);
var _bb = require("../../../bb/bb");
var _invertedBorderSvg = require("/src/app/img/ui/inverted-border.svg");
var _invertedBorderSvgDefault = parcelHelpers.interopDefault(_invertedBorderSvg);
class TabRow {
    // update
    update() {
        for(let i = 0; i < this.tabArr.length; i++)this.tabArr[i].update(this.activeTab);
    }
    // ---- public ----
    constructor(p){
        const height = p.height ?? 35;
        this.rootEl = (0, _bb.BB).el({
            className: "tabrow",
            css: {
                height: height + 1 + "px"
            }
        });
        this.tabArr = []; //creates its own internal arr
        const roundSize = 10;
        this.roundRight = (0, _bb.BB).el({
            css: {
                width: roundSize + "px",
                height: roundSize + "px",
                backgroundImage: `url('${(0, _invertedBorderSvgDefault.default)}')`,
                backgroundSize: "cover",
                position: "absolute",
                right: -roundSize + "px",
                bottom: "0",
                pointerEvents: "none"
            }
        });
        this.roundLeft = (0, _bb.BB).el({
            css: {
                width: roundSize + "px",
                height: roundSize + "px",
                backgroundImage: `url('${(0, _invertedBorderSvgDefault.default)}')`,
                backgroundSize: "cover",
                position: "absolute",
                left: -roundSize + "px",
                bottom: "0",
                transform: "scale(-1,1)",
                pointerEvents: "none"
            }
        });
        const createTab = (pTabObj, initialId, useAccent)=>{
            const isVisible = "isVisible" in pTabObj && pTabObj.isVisible !== undefined ? pTabObj.isVisible : true;
            const result = {
                id: pTabObj.id,
                isVisible: isVisible,
                onOpen: pTabObj.onOpen,
                onClose: pTabObj.onClose,
                update: (openedTabObj)=>{
                    result.el.className = openedTabObj === result ? useAccent ? "tabrow__tab tabrow__tab--opened-accented" : "tabrow__tab tabrow__tab--opened" : "tabrow__tab";
                    result.el.style.display = result.isVisible ? "block" : "none";
                },
                el: (0, _bb.BB).el({
                    parent: this.rootEl,
                    content: "label" in pTabObj ? pTabObj.label : "",
                    title: "title" in pTabObj ? pTabObj.title : undefined,
                    className: initialId === pTabObj.id ? useAccent ? "tabrow__tab tabrow__tab--opened-accented" : "tabrow__tab tabrow__tab--opened" : "tabrow__tab",
                    css: {
                        lineHeight: height + "px",
                        display: isVisible ? "block" : "none",
                        zIndex: "0"
                    },
                    onClick: ()=>{
                        if (this.activeTab === result) return;
                        this.open(result.id);
                    }
                }),
                pointerListener: {}
            };
            if ("image" in pTabObj) (0, _bb.BB).el({
                tagName: "span",
                parent: result.el,
                className: "dark-invert",
                css: {
                    backgroundImage: `url("${pTabObj.image}")`,
                    backgroundSize: "contain",
                    backgroundPosition: "center",
                    backgroundRepeat: "no-repeat",
                    display: "flex",
                    height: height - 7 + "px",
                    justifyContent: "center",
                    margin: "4px auto"
                }
            });
            if ("css" in pTabObj && pTabObj.css !== undefined) (0, _bb.BB).css(result.el, pTabObj.css);
            result.pointerListener = new (0, _bb.BB).PointerListener({
                target: result.el,
                onEnterLeave: (isOver)=>{
                    result.el.classList.toggle("tabrow__tab-hover", isOver);
                }
            });
            if (initialId === result.id) {
                result.onOpen();
                result.el.append(this.roundRight, this.roundLeft);
            } else result.onClose();
            return result;
        };
        let initTabObj = null;
        for(let i = 0; i < p.tabArr.length; i++){
            const tab = createTab(p.tabArr[i], p.initialId, p.useAccent || false);
            if (tab.id === p.initialId) initTabObj = tab;
            this.tabArr.push(tab);
        }
        if (!initTabObj) throw "invalid initialId";
        this.activeTab = initTabObj;
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    open(tabId) {
        for(let i = 0; i < this.tabArr.length; i++)if (this.tabArr[i].id === tabId) {
            if (this.activeTab === this.tabArr[i]) return;
            this.activeTab.onClose();
            this.activeTab = this.tabArr[i];
            this.activeTab.onOpen();
            this.activeTab.el.append(this.roundRight, this.roundLeft);
            this.update();
            return;
        }
        throw "TabRow.open - invalid tabId";
    }
    getOpenedTabId() {
        return "" + this.activeTab.id;
    }
    setIsVisible(tabId, isVisible) {
        for(let i = 0; i < this.tabArr.length; i++)if (this.tabArr[i].id === tabId) {
            this.tabArr[i].isVisible = isVisible;
            this.update();
            return;
        }
        throw "TabRow.setIsVisible - invalid tabId";
    }
    destroy() {
        this.tabArr.forEach((item)=>{
            (0, _bb.BB).destroyEl(item.el);
            item.pointerListener.destroy();
        });
    }
}

},{"../../../bb/bb":"dcQKo","/src/app/img/ui/inverted-border.svg":"hmEMs","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"hmEMs":[function(require,module,exports) {
module.exports = require("8b2549353e8e7805").getBundleURL("d3gnI") + "inverted-border.07365ee7.svg" + "?" + Date.now();

},{"8b2549353e8e7805":"lgJ39"}],"brsBa":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Ui, when hand tool tab is open.
 */ parcelHelpers.export(exports, "HandUi", ()=>HandUi);
var _bb = require("../../../bb/bb");
var _angleSvg = require("/src/app/img/ui/angle.svg");
var _angleSvgDefault = parcelHelpers.interopDefault(_angleSvg);
var _editRotateSvg = require("/src/app/img/ui/edit-rotate.svg");
var _editRotateSvgDefault = parcelHelpers.interopDefault(_editRotateSvg);
var _language = require("../../../language/language");
class HandUi {
    updateUi() {
        this.scaleEl.innerHTML = Math.round(this.scale * 100) + "%";
        this.angleEl.innerHTML = Math.round(this.angleDeg) + "\xb0";
        this.angleIm.style.transform = "rotate(" + this.angleDeg + "deg)";
        if (this.angleDeg % 90 === 0) this.angleIm.style.boxShadow = "inset 0 0 0 1px rgba(255,255,255, 1), 0 0 0 1px rgba(0, 0, 0, 0.3)";
        else this.angleIm.style.boxShadow = "";
    }
    // ---- public ----
    constructor(p){
        this.isVisible = true;
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: "10px"
            }
        });
        this.scale = p.scale;
        this.angleDeg = p.angleDeg;
        this.onAngleChange = p.onAngleChange;
        const row1 = (0, _bb.BB).el({
            css: {
                marginBottom: "10px",
                display: "flex"
            }
        });
        const row2 = (0, _bb.BB).el({
            css: {
                display: "flex",
                marginBottom: "10px"
            }
        });
        const row3 = (0, _bb.BB).el({
            css: {
                display: "flex"
            }
        });
        this.rootEl.append(row1, row2, row3);
        this.scaleEl = (0, _bb.BB).el({
            css: {
                width: "55px",
                userSelect: "none"
            }
        });
        row1.append(this.scaleEl);
        this.angleIm = new Image();
        this.angleIm.src = (0, _angleSvgDefault.default);
        (0, _bb.BB).css(this.angleIm, {
            verticalAlign: "bottom",
            width: "20px",
            height: "20px",
            marginRight: "5px",
            borderRadius: "10px",
            background: "rgba(0,0,0,0.2)",
            userSelect: "none"
        });
        row1.append(this.angleIm);
        this.angleEl = (0, _bb.BB).el({
            parent: row1,
            css: {
                userSelect: "none"
            }
        });
        this.updateUi();
        const resetButton = (0, _bb.BB).el({
            tagName: "button",
            content: (0, _language.LANG)("hand-reset"),
            onClick: p.onReset
        });
        (0, _bb.BB).makeUnfocusable(resetButton);
        const fitButton = (0, _bb.BB).el({
            tagName: "button",
            content: (0, _language.LANG)("hand-fit"),
            css: {
                marginLeft: "10px"
            },
            onClick: p.onFit
        });
        (0, _bb.BB).makeUnfocusable(fitButton);
        row2.append(resetButton, fitButton);
        const leftRotateButton = (0, _bb.BB).el({
            tagName: "button",
            content: '<img height="20" src="' + (0, _editRotateSvgDefault.default) + '" alt="Rotate" style="transform: scale(-1, 1)"/>',
            onClick: function() {
                p.onAngleChange(-15, true);
            }
        });
        (0, _bb.BB).makeUnfocusable(leftRotateButton);
        const resetAngleButton = (0, _bb.BB).el({
            tagName: "button",
            content: "0\xb0",
            css: {
                marginLeft: "10px"
            },
            onClick: function() {
                p.onAngleChange(0);
            }
        });
        (0, _bb.BB).makeUnfocusable(resetAngleButton);
        const rightRotateButton = (0, _bb.BB).el({
            tagName: "button",
            content: '<img height="20" src="' + (0, _editRotateSvgDefault.default) + '" alt="Rotate"/>',
            css: {
                marginLeft: "10px"
            },
            onClick: function() {
                p.onAngleChange(15, true);
            }
        });
        (0, _bb.BB).makeUnfocusable(rightRotateButton);
        row3.append(leftRotateButton, resetAngleButton, rightRotateButton);
    }
    getElement() {
        return this.rootEl;
    }
    setIsVisible(pIsVisible) {
        this.isVisible = !!pIsVisible;
        this.rootEl.style.display = this.isVisible ? "block" : "none";
        if (this.isVisible) this.updateUi();
    }
    update(pScale, pAngleDeg) {
        this.scale = pScale;
        this.angleDeg = pAngleDeg;
        if (this.isVisible) this.updateUi();
    }
}

},{"../../../bb/bb":"dcQKo","/src/app/img/ui/angle.svg":"sK9n5","/src/app/img/ui/edit-rotate.svg":"bDgUa","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bDgUa":[function(require,module,exports) {
module.exports = require("8523254dce4e7880").getBundleURL("d3gnI") + "edit-rotate.22f2f03d.svg" + "?" + Date.now();

},{"8523254dce4e7880":"lgJ39"}],"5n3hF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Paint Bucket tab contents (color slider, opacity slider, etc)
 */ parcelHelpers.export(exports, "FillUi", ()=>FillUi);
var _bb = require("../../../bb/bb");
var _klSlider = require("../components/kl-slider");
var _select = require("../components/select");
var _checkbox = require("../components/checkbox");
var _language = require("../../../language/language");
class FillUi {
    // ---- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: "10px"
            }
        });
        this.isVisible = true;
        this.colorDiv = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                marginBottom: "10px"
            }
        });
        this.colorSlider = p.colorSlider;
        this.opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("opacity"),
            width: 250,
            height: 30,
            min: 0.01,
            max: 1,
            value: 1,
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100
        });
        this.rootEl.append(this.opacitySlider.getElement());
        this.toleranceSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("bucket-tolerance"),
            width: 250,
            height: 30,
            min: 0,
            max: 255,
            value: 51,
            toValue: (displayValue)=>displayValue * 2.55,
            toDisplayValue: (value)=>value / 2.55
        });
        (0, _bb.BB).css(this.toleranceSlider.getElement(), {
            marginTop: "10px"
        });
        this.rootEl.append(this.toleranceSlider.getElement());
        const selectRow = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: "flex",
                marginTop: "10px"
            }
        });
        const modeWrapper = (0, _bb.BB).el({
            content: (0, _language.LANG)("bucket-sample") + "&nbsp;",
            title: (0, _language.LANG)("bucket-sample-title"),
            css: {
                fontSize: "15px"
            }
        });
        this.modeSelect = new (0, _select.Select)({
            optionArr: [
                [
                    "all",
                    (0, _language.LANG)("bucket-sample-all")
                ],
                [
                    "current",
                    (0, _language.LANG)("bucket-sample-active")
                ],
                [
                    "above",
                    (0, _language.LANG)("bucket-sample-above")
                ]
            ],
            initValue: "all"
        });
        const modePointerListener = new (0, _bb.BB).PointerListener({
            target: this.modeSelect.getElement(),
            onWheel: (e)=>{
                this.modeSelect.setDeltaValue(e.deltaY);
            }
        });
        modeWrapper.append(this.modeSelect.getElement());
        selectRow.append(modeWrapper);
        const growWrapper = (0, _bb.BB).el({
            content: (0, _language.LANG)("bucket-grow") + "&nbsp;",
            title: (0, _language.LANG)("bucket-grow-title"),
            css: {
                fontSize: "15px",
                marginLeft: "10px"
            }
        });
        this.growSelect = new (0, _select.Select)({
            optionArr: [
                [
                    "0",
                    "0"
                ],
                [
                    "1",
                    "1"
                ],
                [
                    "2",
                    "2"
                ],
                [
                    "3",
                    "3"
                ],
                [
                    "4",
                    "4"
                ],
                [
                    "5",
                    "5"
                ],
                [
                    "6",
                    "6"
                ],
                [
                    "7",
                    "7"
                ]
            ],
            initValue: "0"
        });
        const growPointerListener = new (0, _bb.BB).PointerListener({
            target: this.growSelect.getElement(),
            onWheel: (e)=>{
                this.growSelect.setDeltaValue(e.deltaY);
            }
        });
        growWrapper.append(this.growSelect.getElement());
        selectRow.append(growWrapper);
        this.isContiguous = true;
        const contiguousToggle = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)("bucket-contiguous"),
            title: (0, _language.LANG)("bucket-contiguous-title"),
            callback: (b)=>{
                this.isContiguous = b;
            },
            css: {
                paddingRight: "5px",
                display: "inline-block",
                width: "50%"
            }
        });
        this.eraserToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("eraser"),
            css: {
                paddingRight: "5px",
                display: "inline-block",
                width: "50%"
            }
        });
        this.rootEl.append((0, _bb.BB).el({
            content: [
                contiguousToggle.getElement(),
                this.eraserToggle.getElement()
            ],
            css: {
                display: "flex",
                marginTop: "10px"
            }
        }));
    }
    getElement() {
        return this.rootEl;
    }
    setIsVisible(pIsVisible) {
        this.isVisible = !!pIsVisible;
        this.rootEl.style.display = this.isVisible ? "block" : "none";
        if (this.isVisible) this.colorDiv.append(this.colorSlider.getElement(), this.colorSlider.getOutputElement());
    }
    /**
     * [0, 1]
     */ getTolerance() {
        return this.toleranceSlider.getValue();
    }
    getOpacity() {
        return this.opacitySlider.getValue();
    }
    getSample() {
        return this.modeSelect.getValue();
    }
    getGrow() {
        return parseInt(this.growSelect.getValue(), 10);
    }
    getContiguous() {
        return this.isContiguous;
    }
    getIsEraser() {
        return this.eraserToggle.getValue();
    }
}

},{"../../../bb/bb":"dcQKo","../components/kl-slider":"4hcvv","../components/select":"jmugN","../components/checkbox":"8fYiz","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jaulB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Text Tool tab contents (color slider)
 */ parcelHelpers.export(exports, "TextUi", ()=>TextUi);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
class TextUi {
    // ---- public ----
    constructor(p){
        this.isVisible = true;
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: "10px"
            }
        });
        this.colorSlider = p.colorSlider;
        this.colorDiv = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                marginBottom: "10px"
            }
        });
        const hint = (0, _bb.BB).el({
            parent: this.rootEl,
            content: (0, _language.LANG)("text-instruction")
        });
    }
    getElement() {
        return this.rootEl;
    }
    setIsVisible(pIsVisible) {
        this.isVisible = !!pIsVisible;
        this.rootEl.style.display = this.isVisible ? "block" : "none";
        if (this.isVisible) this.colorDiv.append(this.colorSlider.getElement(), this.colorSlider.getOutputElement());
    }
}

},{"../../../bb/bb":"dcQKo","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7GG7G":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Shape Tool tab contents
 */ parcelHelpers.export(exports, "ShapeUi", ()=>ShapeUi);
var _bb = require("../../../bb/bb");
var _options = require("../components/options");
var _checkbox = require("../components/checkbox");
var _klSlider = require("../components/kl-slider");
var _language = require("../../../language/language");
class ShapeUi {
    // ---- public ----
    constructor(p){
        this.shape = "rect";
        this.mode = "stroke";
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: "10px"
            }
        });
        this.isVisible = true;
        this.colorDiv = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                marginBottom: "10px"
            }
        });
        this.colorSlider = p.colorSlider;
        const previewSize = 35;
        const previewPadding = 8;
        const rectStrokeSvgRect = (0, _bb.BB).createSvg({
            elementType: "rect",
            x: "" + previewPadding,
            width: "" + (previewSize - previewPadding * 2)
        });
        const rectStrokeSvg = (0, _bb.BB).createSvg({
            elementType: "svg",
            width: "" + previewSize,
            height: "" + previewSize
        });
        rectStrokeSvg.classList.add("dark-invert");
        rectStrokeSvg.append(rectStrokeSvgRect);
        (0, _bb.BB).css(rectStrokeSvg, {
            display: "block"
        });
        const rectFilledSvgRect = (0, _bb.BB).createSvg({
            elementType: "rect",
            x: "" + previewPadding,
            width: "" + (previewSize - previewPadding * 2)
        });
        const rectFilledSvg = (0, _bb.BB).createSvg({
            elementType: "svg",
            width: "" + previewSize,
            height: "" + previewSize
        });
        rectFilledSvg.classList.add("dark-invert");
        rectFilledSvg.append(rectFilledSvgRect);
        (0, _bb.BB).css(rectFilledSvg, {
            display: "block"
        });
        const ellipseStrokeSvgEllipse = (0, _bb.BB).createSvg({
            elementType: "ellipse",
            cx: "" + previewSize / 2,
            cy: "" + previewSize / 2,
            rx: "" + (previewSize / 2 - previewPadding)
        });
        const ellipseStrokeSvg = (0, _bb.BB).createSvg({
            elementType: "svg",
            width: "" + previewSize,
            height: "" + previewSize
        });
        ellipseStrokeSvg.classList.add("dark-invert");
        ellipseStrokeSvg.append(ellipseStrokeSvgEllipse);
        (0, _bb.BB).css(ellipseStrokeSvg, {
            display: "block"
        });
        const ellipseFilledSvgEllipse = (0, _bb.BB).createSvg({
            elementType: "ellipse",
            cx: "" + previewSize / 2,
            cy: "" + previewSize / 2,
            rx: "" + (previewSize / 2 - previewPadding)
        });
        const ellipseFilledSvg = (0, _bb.BB).createSvg({
            elementType: "svg",
            width: "" + previewSize,
            height: "" + previewSize
        });
        ellipseFilledSvg.classList.add("dark-invert");
        ellipseFilledSvg.append(ellipseFilledSvgEllipse);
        (0, _bb.BB).css(ellipseFilledSvg, {
            display: "block"
        });
        const lineSvgLine = (0, _bb.BB).createSvg({
            elementType: "line",
            x1: "" + previewPadding,
            x2: "" + (previewSize - previewPadding)
        });
        const lineSvg = (0, _bb.BB).createSvg({
            elementType: "svg",
            width: "" + previewSize,
            height: "" + previewSize
        });
        lineSvg.classList.add("dark-invert");
        lineSvg.append(lineSvgLine);
        (0, _bb.BB).css(lineSvg, {
            display: "block"
        });
        const updatePreviews = ()=>{
            const strokeWidth = (0, _bb.BB).clamp(Math.round(this.lineWidthSlider.getValue() / 10), 1, 10) + "px";
            const squish = 1.35;
            (0, _bb.BB).css(rectStrokeSvgRect, {
                fill: "none",
                stroke: "black",
                strokeWidth: strokeWidth
            });
            (0, _bb.BB).css(rectFilledSvgRect, {
                fill: "black",
                stroke: "none"
            });
            (0, _bb.BB).css(ellipseStrokeSvgEllipse, {
                fill: "none",
                stroke: "black",
                strokeWidth: strokeWidth
            });
            (0, _bb.BB).css(ellipseFilledSvgEllipse, {
                fill: "black",
                stroke: "none"
            });
            (0, _bb.BB).css(lineSvgLine, {
                fill: "none",
                stroke: "black",
                strokeWidth: strokeWidth
            });
            if (this.fixedToggle.getValue()) {
                rectStrokeSvgRect.setAttribute("y", "" + previewPadding);
                rectStrokeSvgRect.setAttribute("height", "" + (previewSize - previewPadding * 2));
                rectFilledSvgRect.setAttribute("y", "" + previewPadding);
                rectFilledSvgRect.setAttribute("height", "" + (previewSize - previewPadding * 2));
                ellipseStrokeSvgEllipse.setAttribute("ry", "" + (previewSize / 2 - previewPadding));
                ellipseFilledSvgEllipse.setAttribute("ry", "" + (previewSize / 2 - previewPadding));
            } else {
                rectStrokeSvgRect.setAttribute("y", "" + previewPadding * squish);
                rectStrokeSvgRect.setAttribute("height", "" + (previewSize - previewPadding * squish * 2));
                rectFilledSvgRect.setAttribute("y", "" + previewPadding * squish);
                rectFilledSvgRect.setAttribute("height", "" + (previewSize - previewPadding * squish * 2));
                ellipseStrokeSvgEllipse.setAttribute("ry", "" + (previewSize / 2 - previewPadding * squish));
                ellipseFilledSvgEllipse.setAttribute("ry", "" + (previewSize / 2 - previewPadding * squish));
            }
            if (this.snapToggle.getValue()) {
                lineSvgLine.setAttribute("y1", "" + (previewSize - previewPadding));
                lineSvgLine.setAttribute("y2", "" + previewPadding);
            } else {
                lineSvgLine.setAttribute("y1", "" + (previewSize - previewPadding * squish));
                lineSvgLine.setAttribute("y2", "" + previewPadding * squish);
            }
        };
        const row1 = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "start"
            }
        });
        const shapeOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: "rect-stroke",
                    label: rectStrokeSvg,
                    title: (0, _language.LANG)("shape-rect") + " " + (0, _language.LANG)("shape-stroke")
                },
                {
                    id: "ellipse-stroke",
                    label: ellipseStrokeSvg,
                    title: (0, _language.LANG)("shape-ellipse") + " " + (0, _language.LANG)("shape-stroke")
                },
                {
                    id: "line",
                    label: lineSvg,
                    title: (0, _language.LANG)("shape-line")
                },
                {
                    id: "rect-fill",
                    label: rectFilledSvg,
                    title: (0, _language.LANG)("shape-rect") + " " + (0, _language.LANG)("shape-fill")
                },
                {
                    id: "ellipse-fill",
                    label: ellipseFilledSvg,
                    title: (0, _language.LANG)("shape-ellipse") + " " + (0, _language.LANG)("shape-fill")
                }
            ],
            initId: this.shape + " " + this.mode,
            onChange: (id)=>{
                const split = id.split("-");
                this.shape = split[0];
                this.mode = split[1];
                (0, _bb.BB).css(this.fixedToggle.getElement(), {
                    display: this.shape === "line" ? "none" : ""
                });
                (0, _bb.BB).css(this.snapToggle.getElement(), {
                    display: this.shape === "line" ? "" : "none"
                });
                (0, _bb.BB).css(this.lineWidthSlider.getElement(), {
                    display: this.shape !== "line" && this.mode === "fill" ? "none" : ""
                });
            },
            changeOnInit: true
        });
        shapeOptions.getElement().style.width = "120px";
        row1.append(shapeOptions.getElement());
        this.eraserToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("eraser"),
            callback: ()=>{
                updatePreviews();
            }
        });
        this.lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("lock-alpha"),
            title: (0, _language.LANG)("lock-alpha-title"),
            doHighlight: true
        });
        this.lockAlphaToggle.getElement().style.marginTop = "10px";
        row1.append((0, _bb.BB).el({
            content: [
                this.eraserToggle.getElement(),
                this.lockAlphaToggle.getElement()
            ]
        }));
        this.lineWidthSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("shape-line-width"),
            width: 250,
            height: 30,
            min: 1,
            max: 200,
            value: 4,
            curve: "quadratic",
            onChange: ()=>{
                updatePreviews();
            }
        });
        (0, _bb.BB).css(this.lineWidthSlider.getElement(), {
            marginTop: "10px"
        });
        this.rootEl.append(this.lineWidthSlider.getElement());
        this.opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("opacity"),
            width: 250,
            height: 30,
            min: 0.01,
            max: 1,
            value: 1,
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100
        });
        (0, _bb.BB).css(this.opacitySlider.getElement(), {
            marginTop: "10px"
        });
        this.rootEl.append(this.opacitySlider.getElement());
        const row2 = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: "flex",
                alignItems: "center",
                marginTop: "10px"
            }
        });
        this.outwardsToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("shape-outwards"),
            css: {
                width: "50%",
                marginRight: "10px"
            }
        });
        row2.append(this.outwardsToggle.getElement());
        this.fixedToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("shape-fixed"),
            callback: ()=>{
                updatePreviews();
            },
            css: {
                flexGrow: "1"
            }
        });
        row2.append(this.fixedToggle.getElement());
        this.snapToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("angle-snap"),
            title: (0, _language.LANG)("angle-snap-title"),
            callback: ()=>{
                updatePreviews();
            },
            css: {
                flexGrow: "1"
            }
        });
        row2.append(this.snapToggle.getElement());
        updatePreviews();
    }
    getElement() {
        return this.rootEl;
    }
    setIsVisible(pIsVisible) {
        this.isVisible = !!pIsVisible;
        this.rootEl.style.display = this.isVisible ? "block" : "none";
        if (this.isVisible) {
            this.colorDiv.append(this.colorSlider.getElement());
            this.colorDiv.append(this.colorSlider.getOutputElement());
        //update();
        }
    }
    getShape() {
        return this.shape;
    }
    getMode() {
        return this.mode;
    }
    getIsEraser() {
        return this.eraserToggle.getValue();
    }
    getOpacity() {
        return this.opacitySlider.getValue();
    }
    getLineWidth() {
        return this.lineWidthSlider.getValue();
    }
    getIsOutwards() {
        return this.outwardsToggle.getValue();
    }
    getIsFixed() {
        return this.fixedToggle.getValue();
    }
    getIsSnap() {
        return this.snapToggle.getValue();
    }
    getDoLockAlpha() {
        return this.lockAlphaToggle.getValue();
    }
}

},{"../../../bb/bb":"dcQKo","../components/options":"hNLP6","../components/checkbox":"8fYiz","../components/kl-slider":"4hcvv","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5IVi4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "newImageDialog", ()=>newImageDialog);
var _bb = require("../../../bb/bb");
var _select = require("../components/select");
var _colorOptions = require("../components/color-options");
var _showModal = require("./base/showModal");
var _language = require("../../../language/language");
var _table = require("../components/table");
var _eraseColor = require("../../brushes/erase-color");
var _theme = require("../../../theme/theme");
function newImageDialog(p) {
    const currentColor = p.currentColor;
    const secondaryColor = p.secondaryColor;
    const maxCanvasSize = p.maxCanvasSize;
    const canvasWidth = p.canvasWidth;
    const canvasHeight = p.canvasHeight;
    const workspaceWidth = p.workspaceWidth;
    const workspaceHeight = p.workspaceHeight;
    const onConfirm = p.onConfirm;
    const onCancel = p.onCancel;
    function createRatioSize(ratioX, ratioY, width, height, padding) {
        return (0, _bb.BB).fitInto(ratioX, ratioY, Math.min(maxCanvasSize, width - padding), Math.min(maxCanvasSize, height - padding), 1);
    }
    const newImDiv = (0, _bb.BB).el();
    const widthInput = (0, _bb.BB).el({
        tagName: "input"
    });
    const unitStyle = {
        color: "#888",
        fontSize: "12px",
        marginLeft: "5px"
    };
    const widthUnit = (0, _bb.BB).el({
        textContent: (0, _language.LANG)("new-px"),
        css: unitStyle
    });
    const heightInput = (0, _bb.BB).el({
        tagName: "input"
    });
    const heightUnit = (0, _bb.BB).el({
        textContent: (0, _language.LANG)("new-px"),
        css: unitStyle
    });
    widthInput.setAttribute("data-ignore-focus", "true");
    heightInput.setAttribute("data-ignore-focus", "true");
    widthInput.type = "number";
    widthInput.min = "1";
    widthInput.max = "" + maxCanvasSize;
    (0, _bb.BB).css(widthInput, {
        width: "70px"
    });
    heightInput.type = "number";
    heightInput.min = "1";
    heightInput.max = "" + maxCanvasSize;
    heightInput.style.width = "70px";
    widthInput.value = "" + canvasWidth;
    heightInput.value = "" + canvasHeight;
    widthInput.onclick = ()=>{
        widthInput.focus();
        updateRatio();
    };
    heightInput.onclick = ()=>{
        heightInput.focus();
        updateRatio();
    };
    const sizeTable = (0, _table.table)([
        [
            (0, _language.LANG)("width") + ":&nbsp;",
            widthInput,
            widthUnit
        ],
        [
            (0, _bb.BB).el({
                css: {
                    height: "5px"
                }
            }),
            "",
            ""
        ],
        [
            (0, _language.LANG)("height") + ":&nbsp;",
            heightInput,
            heightUnit
        ]
    ]);
    (0, _bb.BB).css(sizeTable, {
        marginBottom: "10px"
    });
    const ratioWrapper = (0, _bb.BB).el({
        css: {
            marginTop: "5px",
            color: "#888"
        }
    });
    const templateWrapper = (0, _bb.BB).el();
    //BB.appendTextDiv(templateWrapper, "Preset Resolutions: <br />");
    const presetFitBtn = (0, _bb.BB).el({
        tagName: "button"
    });
    templateWrapper.style.marginBottom = "10px";
    const presetCurrentBtn = (0, _bb.BB).el({
        tagName: "button"
    });
    const presetSquareBtn = (0, _bb.BB).el({
        tagName: "button"
    });
    const presetLandscapeBtn = (0, _bb.BB).el({
        tagName: "button"
    });
    const presetPortraitBtn = (0, _bb.BB).el({
        tagName: "button"
    });
    const presetOversizeBtn = (0, _bb.BB).el({
        tagName: "button"
    });
    presetCurrentBtn.textContent = (0, _language.LANG)("new-current");
    presetFitBtn.textContent = (0, _language.LANG)("new-fit");
    presetOversizeBtn.textContent = (0, _language.LANG)("new-oversize");
    presetLandscapeBtn.textContent = (0, _language.LANG)("new-landscape");
    presetPortraitBtn.textContent = (0, _language.LANG)("new-portrait");
    presetSquareBtn.textContent = (0, _language.LANG)("new-square");
    presetCurrentBtn.style.marginRight = "5px";
    presetFitBtn.style.marginRight = "5px";
    presetOversizeBtn.style.marginRight = "5px";
    presetLandscapeBtn.style.marginTop = "5px";
    presetLandscapeBtn.style.marginRight = "5px";
    presetPortraitBtn.style.marginTop = "5px";
    presetPortraitBtn.style.marginRight = "5px";
    templateWrapper.append(presetCurrentBtn, presetFitBtn, presetOversizeBtn, presetSquareBtn, presetLandscapeBtn, presetPortraitBtn);
    const templatePadding = 0;
    presetCurrentBtn.onclick = function() {
        widthInput.value = "" + canvasWidth;
        heightInput.value = "" + canvasHeight;
        updateRatio();
    };
    presetFitBtn.onclick = function() {
        widthInput.value = "" + workspaceWidth;
        heightInput.value = "" + workspaceHeight;
        updateRatio();
    };
    presetOversizeBtn.onclick = function() {
        widthInput.value = "" + (workspaceWidth + 500);
        heightInput.value = "" + (workspaceHeight + 500);
        updateRatio();
    };
    presetSquareBtn.onclick = function() {
        const sizeObj = createRatioSize(1, 1, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = "" + Math.round(sizeObj.width);
        heightInput.value = "" + Math.round(sizeObj.height);
        updateRatio();
    };
    presetLandscapeBtn.onclick = function() {
        const sizeObj = createRatioSize(4, 3, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = "" + Math.round(sizeObj.width);
        heightInput.value = "" + Math.round(sizeObj.height);
        updateRatio();
    };
    presetPortraitBtn.onclick = function() {
        const sizeObj = createRatioSize(3, 4, workspaceWidth, workspaceHeight, templatePadding);
        widthInput.value = "" + Math.round(sizeObj.width);
        heightInput.value = "" + Math.round(sizeObj.height);
        updateRatio();
    };
    const select = new (0, _select.Select)({
        isFocusable: true,
        optionArr: [
            [
                "screen",
                (0, _language.LANG)("new-screen")
            ],
            [
                "16 9",
                (0, _language.LANG)("new-video") + " 16:9"
            ],
            [
                "3 2",
                "3:2"
            ],
            [
                "5 3",
                "5:3"
            ],
            [
                "2 1",
                "2:1"
            ],
            [
                "paper",
                (0, _language.LANG)("new-din-paper") + " √2:1"
            ],
            [
                "9 16",
                "9:16"
            ],
            [
                "2 3",
                "2:3"
            ],
            [
                "3 5",
                "3:5"
            ],
            [
                "1 2",
                "1:2"
            ],
            [
                "1 1.4142135623730951",
                "1:√2"
            ]
        ],
        onChange: function(val) {
            if (val === "screen") {
                widthInput.value = "" + window.screen.width;
                heightInput.value = "" + window.screen.height;
            } else if (val === "paper") {
                const sizeObj = createRatioSize(Math.sqrt(2), 1, workspaceWidth, workspaceHeight, templatePadding);
                widthInput.value = "" + Math.round(sizeObj.width);
                heightInput.value = "" + Math.round(sizeObj.height);
            } else {
                const split = val.split(" ");
                const sizeObj = createRatioSize(parseFloat(split[0]), parseFloat(split[1]), workspaceWidth, workspaceHeight, templatePadding);
                widthInput.value = "" + Math.round(sizeObj.width);
                heightInput.value = "" + Math.round(sizeObj.height);
            }
            updateRatio();
            select.setValue(undefined);
        }
    });
    setTimeout(()=>{
        // safari: not empty without also setting it to null via timeout
        select.setValue(undefined);
    }, 0);
    (0, _bb.BB).css(select.getElement(), {
        width: "80px"
    });
    templateWrapper.append(select.getElement());
    let backgroundRGBA = {
        r: 255,
        g: 255,
        b: 255,
        a: 1
    };
    const colorOptionsArr = [
        {
            r: 255,
            g: 255,
            b: 255,
            a: 1
        },
        {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        },
        {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        },
        {
            r: currentColor.r,
            g: currentColor.g,
            b: currentColor.b,
            a: 1
        },
        {
            r: secondaryColor.r,
            g: secondaryColor.g,
            b: secondaryColor.b,
            a: 1
        }
    ];
    let initColorIndex = 0;
    if ((0, _theme.theme).isDark()) colorOptionsArr.forEach((item, index)=>{
        if (item.r === (0, _eraseColor.ERASE_COLOR) && item.g === (0, _eraseColor.ERASE_COLOR) && item.b === (0, _eraseColor.ERASE_COLOR)) {
            initColorIndex = index;
            backgroundRGBA = item;
        }
    });
    const colorOptions = new (0, _colorOptions.ColorOptions)({
        colorArr: colorOptionsArr,
        initialIndex: initColorIndex,
        onChange: function(rgbaObj) {
            backgroundRGBA = rgbaObj;
            preview.style.backgroundColor = "rgba(" + rgbaObj.r + "," + rgbaObj.g + "," + rgbaObj.b + ", " + rgbaObj.a + ")";
        }
    });
    const previewWrapper = (0, _bb.BB).el({
        className: "kl-transparent-preview",
        css: {
            boxSizing: "border-box",
            width: "340px",
            height: "140px",
            display: "table",
            padding: "10px",
            marginTop: "10px",
            marginLeft: "-20px"
        }
    });
    const preview = (0, _bb.BB).el({
        className: "kl-transparent-preview__canvas",
        css: {
            width: "200px",
            height: "100px",
            backgroundColor: "rgba(" + backgroundRGBA.r + "," + backgroundRGBA.g + "," + backgroundRGBA.b + ", " + backgroundRGBA.a + ")",
            marginLeft: "auto",
            marginRight: "auto",
            color: "#aaa",
            fontSize: "16px",
            fontWeight: "bold",
            textAlign: "center",
            verticalAlign: "center",
            display: "table",
            overflow: "hidden"
        }
    });
    (0, _bb.BB).el({
        parent: previewWrapper,
        content: preview,
        css: {
            display: "table-cell",
            verticalAlign: "middle"
        }
    });
    (0, _bb.BB).el({
        parent: preview,
        css: {
            display: "table-cell",
            verticalAlign: "middle"
        }
    });
    function updateRatio() {
        widthInput.value = "" + Math.min(maxCanvasSize, parseInt(widthInput.value));
        heightInput.value = "" + Math.min(maxCanvasSize, parseInt(heightInput.value));
        function hcf(u, v) {
            let U = u, V = v;
            // eslint-disable-next-line no-constant-condition
            while(true){
                if (!(U %= V)) return V;
                if (!(V %= U)) return U;
            }
        }
        let w = parseInt(widthInput.value);
        let h = parseInt(heightInput.value);
        if (w < 1 || w > maxCanvasSize || h < 1 || h > maxCanvasSize) {
            if (w > maxCanvasSize) w = maxCanvasSize;
            else if (h > maxCanvasSize) h = maxCanvasSize;
            widthInput.value = "" + w;
            heightInput.value = "" + h;
        }
        //generated canvas size doesn't always match ratio. so check if a common ratio is very close
        const commonRatios = [
            [
                1,
                2
            ],
            [
                2,
                1
            ],
            [
                2,
                3
            ],
            [
                3,
                2
            ],
            [
                3,
                4
            ],
            [
                4,
                3
            ],
            [
                4,
                5
            ],
            [
                5,
                4
            ],
            [
                16,
                9
            ],
            [
                9,
                16
            ],
            [
                3,
                2
            ],
            [
                2,
                3
            ],
            [
                5,
                3
            ],
            [
                3,
                5
            ],
            [
                2,
                1
            ],
            [
                1,
                2
            ],
            [
                1.414,
                1
            ],
            [
                1,
                1.414
            ]
        ];
        const reducedArr = (0, _bb.BB).reduce(w, h);
        let closestRatio = commonRatios[0];
        let closestDistance = Math.abs(commonRatios[0][0] / commonRatios[0][1] - reducedArr[0] / reducedArr[1]);
        for(let i = 0; i < commonRatios.length; i++)if (Math.abs(commonRatios[i][0] / commonRatios[i][1] - reducedArr[0] / reducedArr[1]) < closestDistance) {
            closestRatio = commonRatios[i];
            closestDistance = Math.abs(commonRatios[i][0] / commonRatios[i][1] - reducedArr[0] / reducedArr[1]);
        }
        //display ratio
        if (closestDistance > 0 && closestDistance < 0.005) ratioWrapper.innerText = (0, _language.LANG)("new-ratio") + ": ~" + closestRatio[0] + ":" + closestRatio[1];
        else ratioWrapper.innerText = (0, _language.LANG)("new-ratio") + ": " + reducedArr[0] + ":" + reducedArr[1];
        const realw = w;
        const T = hcf(w, h);
        w /= T;
        h /= T;
        w *= 260;
        h *= 260;
        if (w > 260) {
            h = 260 / w * h;
            w = 260;
        }
        if (h > 100) {
            w = 100 / h * w;
            h = 100;
        }
        preview.style.width = w + "px";
        preview.style.height = h + "px";
        (0, _bb.BB).createCheckerDataUrl(parseInt("" + 30 * (w / realw)), function(url) {
            previewWrapper.style.background = "url(" + url + ")";
        }, (0, _theme.theme).isDark());
    }
    (0, _theme.theme).addIsDarkListener(updateRatio);
    widthInput.onchange = ()=>{
        if (widthInput.value === "" || parseInt(widthInput.value) < 0) widthInput.value = "1";
        updateRatio();
    };
    widthInput.onkeyup = ()=>{
        updateRatio();
    };
    heightInput.onchange = ()=>{
        if (heightInput.value === "" || parseFloat(heightInput.value) < 0) heightInput.value = "1";
        updateRatio();
    };
    heightInput.onkeyup = ()=>{
        updateRatio();
    };
    updateRatio();
    newImDiv.append(templateWrapper);
    const secondRow = (0, _bb.BB).el({
        parent: newImDiv,
        css: {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "flex-end"
        }
    });
    const secondRowLeft = (0, _bb.BB).el({
        parent: secondRow
    });
    secondRowLeft.append(sizeTable, ratioWrapper);
    secondRow.append(colorOptions.getElement());
    newImDiv.append(previewWrapper);
    (0, _showModal.showModal)({
        target: document.body,
        message: `<b>${(0, _language.LANG)("new-title")}</b>`,
        div: newImDiv,
        buttons: [
            "Ok",
            "Cancel"
        ],
        callback: function(result) {
            (0, _bb.BB).unsetEventHandler(widthInput, "onclick", "onchange", "onkeyup");
            (0, _bb.BB).unsetEventHandler(widthInput, "onclick", "onchange", "onkeyup");
            (0, _bb.BB).unsetEventHandler(presetCurrentBtn, "onclick");
            (0, _bb.BB).unsetEventHandler(presetFitBtn, "onclick");
            (0, _bb.BB).unsetEventHandler(presetOversizeBtn, "onclick");
            (0, _bb.BB).unsetEventHandler(presetSquareBtn, "onclick");
            (0, _bb.BB).unsetEventHandler(presetLandscapeBtn, "onclick");
            (0, _bb.BB).unsetEventHandler(presetPortraitBtn, "onclick");
            select.destroy();
            colorOptions.destroy();
            (0, _theme.theme).removeIsDarkListener(updateRatio);
            if (result === "Cancel" || parseInt(widthInput.value) <= 0 || parseInt(heightInput.value) <= 0 || isNaN(parseInt(widthInput.value)) || isNaN(parseInt(heightInput.value))) {
                onCancel();
                return;
            }
            onConfirm(parseInt(widthInput.value), parseInt(heightInput.value), backgroundRGBA);
        },
        clickOnEnter: "Ok"
    });
}

},{"../../../bb/bb":"dcQKo","../components/select":"jmugN","../components/color-options":"iXzf7","./base/showModal":"hr9Po","../../../language/language":"iiYGN","../components/table":"cV3Jw","../../brushes/erase-color":"lUgDd","../../../theme/theme":"4G3JB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cV3Jw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "table", ()=>table);
var _bb = require("../../../bb/bb");
function table(data, cellProps) {
    const result = (0, _bb.BB).el({
        tagName: "table",
        className: "kl-table"
    });
    data.forEach((row, rowIndex)=>{
        const rowEl = (0, _bb.BB).el({
            tagName: "tr"
        });
        rowEl.append(...row.map((el, colIndex)=>{
            const cellEl = (0, _bb.BB).el({
                tagName: "td",
                content: el
            });
            const key = rowIndex + "." + colIndex;
            if (cellProps !== undefined && key in cellProps) cellEl.rowSpan = cellProps[key].rowspan;
            return cellEl;
        }));
        result.append(rowEl);
    });
    return result;
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"l6lvr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * button that allows to collapse toolspace (for mobile)
 */ parcelHelpers.export(exports, "ToolspaceCollapser", ()=>ToolspaceCollapser);
var _bb = require("../../../bb/bb");
var _uiCollapseSvg = require("/src/app/img/ui/ui-collapse.svg");
var _uiCollapseSvgDefault = parcelHelpers.interopDefault(_uiCollapseSvg);
var _language = require("../../../language/language");
class ToolspaceCollapser {
    update() {
        if (this.directionStr === "left") this.icon.style.transform = this.stateIsOpen ? "rotate(180deg)" : "";
        else this.icon.style.transform = this.stateIsOpen ? "" : "rotate(180deg)";
    }
    // ---- public ----
    constructor(p){
        this.stateIsOpen = true;
        this.directionStr = "right";
        this.rootEl = (0, _bb.BB).el({
            className: "kl-toolspace-toggle",
            css: {
                width: "36px",
                height: "36px",
                background: "rgba(100, 100, 100, 0.9)",
                color: "#fff",
                position: "absolute",
                top: "0",
                textAlign: "center",
                lineHeight: "36px",
                cursor: "pointer",
                userSelect: "none",
                padding: "6px",
                boxSizing: "border-box"
            },
            title: (0, _language.LANG)("toggle-show-tools"),
            onClick: (e)=>{
                e.preventDefault();
                this.stateIsOpen = !this.stateIsOpen;
                this.update();
                p.onChange();
            }
        });
        this.icon = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                backgroundImage: `url(${(0, _uiCollapseSvgDefault.default)})`,
                width: "100%",
                height: "100%",
                backgroundSize: "contain",
                backgroundRepeat: "no-repeat",
                backgroundPosition: "center",
                userSelect: "none"
            }
        });
        this.rootEl.oncontextmenu = ()=>{
            return false;
        };
    }
    // ---- interface ----
    isOpen() {
        return this.stateIsOpen;
    }
    setDirection(dirStr) {
        this.directionStr = dirStr;
        this.update();
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"dcQKo","/src/app/img/ui/ui-collapse.svg":"jkuHh","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jkuHh":[function(require,module,exports) {
module.exports = require("e8ec421ed4c3b933").getBundleURL("d3gnI") + "ui-collapse.a786a8db.svg" + "?" + Date.now();

},{"e8ec421ed4c3b933":"lgJ39"}],"9SsS6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "textToolDialog", ()=>textToolDialog);
var _bb = require("../../../../bb/bb");
var _showModal = require("../base/showModal");
var _language = require("../../../../language/language");
var _textToolFillUi = require("./text-tool-fill-ui");
var _textToolFontUi = require("./text-tool-font-ui");
var _textToolStrokeUi = require("./text-tool-stroke-ui");
var _textToolTextUi = require("./text-tool-text-ui");
var _textToolViewportUi = require("./text-tool-viewport-ui");
var _textToolDialogModuleScss = require("./text-tool-dialog.module.scss");
var _c = require("../../../../bb/base/c");
var _css = require("@emotion/css");
var _tabRow = require("../../components/tab-row");
function textToolDialog(p) {
    const rootEl = (0, _bb.BB).el({});
    let text = (0, _bb.BB).copyObj(p.text);
    const viewportWrapper = (0, _bb.BB).el({
        className: _textToolDialogModuleScss.viewportWrapper
    });
    const viewportUI = new (0, _textToolViewportUi.TextToolViewportUI)({
        text: text,
        klCanvas: p.klCanvas,
        layerIndex: p.layerIndex,
        onDragEnd: ()=>tabs.getOpenedTabId() === "text" ? textUI.focus() : 0
    });
    viewportUI.render();
    function onUpdate(p) {
        text = {
            ...text,
            ...p
        };
        viewportUI.setText(text);
    }
    const fontUI = new (0, _textToolFontUi.TextToolFontUI)({
        ...text,
        onUpdate: (p)=>{
            onUpdate(p);
        }
    });
    const colorWrapper = (0, _bb.BB).el({
        css: {
            display: "flex",
            gap: "10px",
            flexDirection: "column"
        }
    });
    const fillUI = new (0, _textToolFillUi.TextToolFillUI)({
        fill: text.fill,
        primaryColor: p.primaryColor,
        secondaryColor: p.secondaryColor,
        onUpdate: (p)=>{
            onUpdate(p);
        }
    });
    const strokeUI = new (0, _textToolStrokeUi.TextToolStrokeUI)({
        stroke: text.stroke,
        primaryColor: p.primaryColor,
        secondaryColor: p.secondaryColor,
        onUpdate: (p)=>{
            onUpdate(p);
        }
    });
    const textUI = new (0, _textToolTextUi.TextToolTextUI)({
        text: text.text,
        onUpdate: (p)=>{
            p.text !== undefined && modal.setIgnoreBackground(p.text.length > 0);
            onUpdate(p);
        }
    });
    const tabs = new (0, _tabRow.TabRow)({
        initialId: "text",
        height: 40,
        tabArr: [
            {
                id: "text",
                label: (0, _language.LANG)("text-text"),
                onOpen: ()=>{
                    textUI.getElement().style.display = "";
                    textUI.focus();
                },
                onClose: ()=>{
                    textUI.getElement().style.display = "none";
                }
            },
            {
                id: "font",
                label: (0, _language.LANG)("text-font"),
                onOpen: ()=>{
                    fontUI.getElement().style.display = "flex";
                },
                onClose: ()=>{
                    fontUI.getElement().style.display = "none";
                }
            },
            {
                id: "color",
                label: (0, _language.LANG)("text-color"),
                onOpen: ()=>{
                    colorWrapper.style.display = "flex";
                },
                onClose: ()=>{
                    colorWrapper.style.display = "none";
                }
            }
        ]
    });
    tabs.getElement().classList.add((0, _css.css)({
        minWidth: "200px",
        maxWidth: "500px",
        flexGrow: "1",
        borderBottom: "none !important"
    }));
    const viewportInputsCss = (0, _css.css)({
        position: "relative",
        ">*": {
            position: "absolute",
            right: 0,
            top: 10
        }
    });
    const tabWrapperCss = (0, _css.css)({
        display: "flex",
        justifyContent: "space-between",
        flexDirection: "row-reverse",
        flexWrap: "wrap",
        marginTop: "10px",
        marginLeft: "-20px",
        marginRight: "-20px",
        padding: "0 20px",
        "@media (min-width: 700px) and (min-height: 700px)": {
            display: "none !important"
        }
    });
    const inputsCss = (0, _css.css)({
        minHeight: 72,
        marginTop: "10px",
        "@media (min-width: 700px) and (min-height: 700px)": {
            display: "flex",
            flexDirection: "column",
            gap: "10px",
            ">*": {
                display: "flex !important"
            }
        }
    });
    rootEl.append((0, _c.c)("", [
        (0, _c.c)(viewportWrapper, [
            viewportUI.getElement()
        ]),
        (0, _c.c)("." + viewportInputsCss, [
            viewportUI.getInputsElement()
        ]),
        (0, _c.c)(".tabrow." + tabWrapperCss, [
            (0, _c.c)(",w-240,h-40"),
            tabs.getElement()
        ]),
        (0, _c.c)("." + inputsCss, [
            (0, _c.c)(colorWrapper, [
                fillUI.getElement(),
                strokeUI.getElement()
            ]),
            fontUI.getElement(),
            textUI.getElement()
        ])
    ]));
    const onResize = ()=>{
        const b = viewportWrapper.getBoundingClientRect();
        const w = Math.ceil(b.width);
        const h = Math.ceil(b.height);
        viewportUI.setSize(w, h);
    };
    window.addEventListener("resize", onResize);
    setTimeout(()=>{
        onResize();
    });
    setTimeout(()=>{
        textUI.focus();
    }, 100);
    // prevent mobile keyboards scrolling page
    function onScroll() {
        window.scrollTo(0, 0);
    }
    window.addEventListener("scroll", onScroll);
    const onModalExit = (val)=>{
        window.removeEventListener("resize", onResize);
        window.removeEventListener("scroll", onScroll);
        viewportUI.destroy();
        fontUI.destroy();
        fillUI.destroy();
        strokeUI.destroy();
        textUI.destroy();
        tabs.destroy();
        if (val === "Ok") p.onConfirm({
            ...viewportUI.getValues(),
            ...fontUI.getValues(),
            ...fillUI.getValues(),
            ...strokeUI.getValues(),
            ...textUI.getValues()
        });
    };
    const modal = (0, _showModal.showModal)({
        target: document.body,
        message: `<b>${(0, _language.LANG)("text-title")}</b>`,
        div: rootEl,
        buttons: [
            "Ok",
            "Cancel"
        ],
        ignoreBackground: p.text.text.length > 0,
        callback: onModalExit,
        style: {
            width: "calc(100% - 50px)",
            maxWidth: "1000px",
            minWidth: "300px",
            boxSizing: "border-box"
        },
        clickOnEnter: "Ok"
    });
}

},{"../../../../bb/bb":"dcQKo","../base/showModal":"hr9Po","../../../../language/language":"iiYGN","./text-tool-fill-ui":"aaiIY","./text-tool-font-ui":"iQdba","./text-tool-stroke-ui":"7Jp9i","./text-tool-text-ui":"10HCb","./text-tool-viewport-ui":"jIp7t","./text-tool-dialog.module.scss":"8UXcD","../../../../bb/base/c":"eg9k9","@emotion/css":"gyRZs","../../components/tab-row":"fLnal","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"aaiIY":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextToolFillUI", ()=>TextToolFillUI);
var _colorOptions = require("../../components/color-options");
var _klSlider = require("../../components/kl-slider");
var _language = require("../../../../language/language");
var _c = require("../../../../bb/base/c");
var _base = require("../../../../bb/base/base");
class TextToolFillUI {
    // ---- public ----
    constructor(p){
        const emit = ()=>{
            p.onUpdate(this.getValues());
        };
        const colorOptionsArr = [
            null,
            p.fill ? {
                ...p.fill.color,
                a: 1
            } : null,
            {
                ...p.primaryColor,
                a: 1
            },
            {
                ...p.secondaryColor,
                a: 1
            },
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            }
        ];
        this.colorOptions = new (0, _colorOptions.ColorOptions)({
            colorArr: colorOptionsArr,
            initialIndex: p.fill ? 1 : 0,
            title: (0, _language.LANG)("shape-fill"),
            onChange: (c)=>{
                this.opacitySlider.getElement().style.display = c !== null ? "" : "none";
                emit();
            }
        });
        this.opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("opacity"),
            width: 150,
            height: 30,
            min: 0.01,
            max: 1,
            value: p.fill ? p.fill.color.a : 1,
            resolution: 225,
            eventResMs: 1000 / 30,
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100,
            onChange: ()=>emit()
        });
        this.opacitySlider.getElement().style.display = p.fill ? "" : "none";
        const svg = (0, _base.createSvg)({
            elementType: "svg",
            class: "dark-invert",
            width: "25px",
            height: "25px",
            viewBox: "0 0 30 30",
            childrenArr: [
                {
                    elementType: "polyline",
                    points: "0,0 30,0 30,8 19,8 19,30 11,30 11,8 0,8 0,0 1,0",
                    "transform-origin": "15px 15px",
                    transform: "scale(0.8)",
                    fill: "#000c"
                }
            ]
        });
        this.rootEl = (0, _c.c)(",flex,gap-10,items-center,flexWrap,minh-30", [
            svg,
            this.colorOptions.getElement(),
            this.opacitySlider.getElement()
        ]);
    }
    getElement() {
        return this.rootEl;
    }
    getValues() {
        const c = this.colorOptions.getValue();
        if (c === null || c?.a === 0) return {
            fill: undefined
        };
        const color = {
            ...c,
            a: this.opacitySlider.getValue()
        };
        return {
            fill: {
                color
            }
        };
    }
    destroy() {
        this.colorOptions.destroy();
        this.opacitySlider.destroy();
    }
}

},{"../../components/color-options":"iXzf7","../../components/kl-slider":"4hcvv","../../../../language/language":"iiYGN","../../../../bb/base/c":"eg9k9","../../../../bb/base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iQdba":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextToolFontUI", ()=>TextToolFontUI);
var _bb = require("../../../../bb/bb");
var _input = require("../../components/input");
var _language = require("../../../../language/language");
var _imageRadioList = require("../../components/image-radio-list");
var _alignLeftSvg = require("/src/app/img/ui/align-left.svg");
var _alignLeftSvgDefault = parcelHelpers.interopDefault(_alignLeftSvg);
var _alignCenterSvg = require("/src/app/img/ui/align-center.svg");
var _alignCenterSvgDefault = parcelHelpers.interopDefault(_alignCenterSvg);
var _alignRightSvg = require("/src/app/img/ui/align-right.svg");
var _alignRightSvgDefault = parcelHelpers.interopDefault(_alignRightSvg);
var _typoItalicSvg = require("/src/app/img/ui/typo-italic.svg");
var _typoItalicSvgDefault = parcelHelpers.interopDefault(_typoItalicSvg);
var _typoBoldSvg = require("/src/app/img/ui/typo-bold.svg");
var _typoBoldSvgDefault = parcelHelpers.interopDefault(_typoBoldSvg);
var _imageToggle = require("../../components/image-toggle");
var _select = require("../../components/select");
var _c = require("../../../../bb/base/c");
var _fonts = require("../../../../../fonts/fonts");
const importedFonts = [
    {
        fontFamily: "sans-serif",
        fontName: "Sans-serif"
    },
    {
        fontFamily: "serif",
        fontName: "Serif"
    },
    {
        fontFamily: "monospace",
        fontName: "Monospace"
    },
    {
        fontFamily: "cursive",
        fontName: "Cursive"
    },
    {
        fontFamily: "fantasy",
        fontName: "Fantasy"
    },
    ...(0, _fonts.fonts).map((item)=>{
        return {
            fontFamily: item.name,
            fontName: item.name
        };
    })
];
let didLoadBundledFonts = false;
async function loadBundledFonts() {
    if (didLoadBundledFonts) return;
    didLoadBundledFonts = true;
    const promises = [];
    for(let i = 0; i < (0, _fonts.fonts).length; i++)promises.push((async ()=>{
        const item = (0, _fonts.fonts)[i];
        const response = await fetch(item.url);
        const buffer = await response.arrayBuffer();
        const font = new FontFace(item.name, buffer);
        document.fonts.add(font);
    })());
    await Promise.all(promises);
}
class TextToolFontUI {
    // only load fonts when interacting with the font input
    loadBundledFonts() {
        !didLoadBundledFonts && loadBundledFonts().then(()=>{
            this.onUpdate({
                font: this.fontSelect.getValue()
            });
        });
    }
    importFont() {
        const input = document.createElement("input");
        input.type = "file";
        input.multiple = true;
        input.accept = ".ttf, .otf, .woff, .woff2, .eot";
        input.focus();
        input.click();
        input.onchange = async ()=>{
            if (!input.files || input.files.length === 0) return;
            let toSelect = undefined;
            const fontFamilies = importedFonts.map((i)=>i.fontFamily);
            for(let i = 0; i < input.files.length; i++){
                const file = input.files[i];
                const fontName = "kl-" + importedFonts.length;
                if (fontFamilies.includes(fontName)) continue;
                if (!toSelect) {
                    toSelect = fontName;
                    this.importButton.disabled = true;
                    this.importButton.innerText = (0, _language.LANG)("loading");
                }
                const split = file.name.split(".");
                split.pop();
                importedFonts.push({
                    fontFamily: fontName,
                    fontName: split.join(".")
                });
                const font = new FontFace(fontName, await file.arrayBuffer());
                document.fonts.add(font);
            }
            // update font selection
            setTimeout(()=>{
                this.fontSelect.setOptionArr(importedFonts.map((i)=>{
                    return [
                        i.fontFamily,
                        i.fontName,
                        {
                            css: {
                                fontFamily: i.fontFamily,
                                fontSize: "1.2em"
                            }
                        }
                    ];
                }));
                this.fontSelect.setValue(toSelect);
                this.onUpdate({
                    font: toSelect
                });
                this.importButton.disabled = false;
                this.importButton.innerText = (0, _language.LANG)("file-import");
            });
        };
    }
    // ---- public ----
    constructor(p){
        this.onUpdate = p.onUpdate;
        this.fontSelect = new (0, _select.Select)({
            initValue: p.font,
            optionArr: importedFonts.map((i)=>{
                return [
                    i.fontFamily,
                    i.fontName,
                    {
                        css: {
                            fontFamily: i.fontFamily,
                            fontSize: "1.2em"
                        }
                    }
                ];
            }),
            isFocusable: true,
            css: {
                width: "180px"
            },
            onChange: (v)=>{
                this.loadBundledFonts();
                p.onUpdate({
                    font: v
                });
            }
        });
        this.onFocus = ()=>this.loadBundledFonts();
        this.fontSelect.getElement().addEventListener("focus", this.onFocus);
        this.fontPointerListener = new (0, _bb.BB).PointerListener({
            target: this.fontSelect.getElement(),
            onWheel: (e)=>this.fontSelect.setDeltaValue(e.deltaY)
        });
        this.importButton = (0, _bb.BB).el({
            tagName: "button",
            content: (0, _language.LANG)("file-import"),
            onClick: ()=>{
                this.importFont();
            }
        });
        const sizeLabel = (0, _bb.BB).el({
            content: '<div><span style="font-size: 0.6em; margin-right: -1px">A</span>A</div>',
            css: {
                width: "25px",
                height: "25px",
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                fontSize: "1.2em",
                userSelect: "none"
            }
        });
        this.sizeInput = new (0, _input.Input)({
            title: (0, _language.LANG)("text-size"),
            type: "number",
            min: 0,
            max: 1000,
            init: p.size,
            onChange: (v)=>{
                p.onUpdate({
                    size: parseFloat(v)
                });
            },
            doResetIfInvalid: true,
            doScrollWithoutFocus: true,
            css: {
                width: "70px"
            }
        });
        this.lineHeightInput = new (0, _input.Input)({
            label: (0, _language.LANG)("text-line-height"),
            type: "number",
            min: 0,
            max: 10,
            step: 0.1,
            init: p.lineHeight ?? 1,
            onChange: (v)=>{
                p.onUpdate({
                    lineHeight: parseFloat(v)
                });
            },
            doResetIfInvalid: true,
            doScrollWithoutFocus: true,
            css: {
                width: "60px"
            }
        });
        this.letterSpacingInput = new (0, _input.Input)({
            label: (0, _language.LANG)("text-letter-spacing"),
            type: "number",
            min: -100,
            max: 100,
            init: p.letterSpacing ?? 0,
            onChange: (v)=>{
                p.onUpdate({
                    letterSpacing: parseFloat(v)
                });
            },
            doResetIfInvalid: true,
            doScrollWithoutFocus: true,
            css: {
                width: "60px"
            }
        });
        this.alignRadioList = new (0, _imageRadioList.ImageRadioList)({
            optionArr: [
                {
                    id: "left",
                    title: (0, _language.LANG)("text-left"),
                    image: (0, _alignLeftSvgDefault.default),
                    darkInvert: true
                },
                {
                    id: "center",
                    title: (0, _language.LANG)("text-center"),
                    image: (0, _alignCenterSvgDefault.default),
                    darkInvert: true
                },
                {
                    id: "right",
                    title: (0, _language.LANG)("text-right"),
                    image: (0, _alignRightSvgDefault.default),
                    darkInvert: true
                }
            ],
            initId: p.align,
            onChange: (v)=>p.onUpdate({
                    align: v
                })
        });
        this.italicToggle = new (0, _imageToggle.ImageToggle)({
            image: (0, _typoItalicSvgDefault.default),
            title: (0, _language.LANG)("text-italic"),
            initValue: p.isItalic,
            onChange: (v)=>p.onUpdate({
                    isItalic: v
                }),
            darkInvert: true
        });
        this.boldToggle = new (0, _imageToggle.ImageToggle)({
            image: (0, _typoBoldSvgDefault.default),
            title: (0, _language.LANG)("text-bold"),
            initValue: p.isBold,
            onChange: (v)=>p.onUpdate({
                    isBold: v
                }),
            darkInvert: true
        });
        this.rootEl = (0, _c.c)(",flex,flexWrap,gap-10-15,items-center", [
            (0, _c.c)(",flex,gap-5,items-center", [
                sizeLabel,
                this.sizeInput.getElement()
            ]),
            (0, _c.c)(",flex,gap-5", [
                this.fontSelect.getElement(),
                this.importButton
            ]),
            (0, _c.c)(",flex,gap-7", [
                this.alignRadioList.getElement(),
                this.italicToggle.getElement(),
                this.boldToggle.getElement()
            ]),
            this.letterSpacingInput.getElement(),
            this.lineHeightInput.getElement()
        ]);
    }
    getElement() {
        return this.rootEl;
    }
    getValues() {
        return {
            font: this.fontSelect.getValue(),
            size: +this.sizeInput.getValue(),
            letterSpacing: +this.letterSpacingInput.getValue(),
            lineHeight: +this.lineHeightInput.getValue(),
            align: this.alignRadioList.getValue(),
            isItalic: this.italicToggle.getValue(),
            isBold: this.boldToggle.getValue()
        };
    }
    destroy() {
        this.fontPointerListener.destroy();
        this.fontSelect.getElement().removeEventListener("focus", this.onFocus);
        this.fontSelect.destroy();
        (0, _bb.BB).destroyEl(this.importButton);
        this.sizeInput.destroy();
        this.lineHeightInput.destroy();
        this.letterSpacingInput.destroy();
        this.alignRadioList.destroy();
        this.italicToggle.destroy();
        this.boldToggle.destroy();
    }
}

},{"../../../../bb/bb":"dcQKo","../../components/input":"je8IE","../../../../language/language":"iiYGN","../../components/image-radio-list":"cHp0o","/src/app/img/ui/align-left.svg":"k02ho","/src/app/img/ui/align-center.svg":"b6ZNm","/src/app/img/ui/align-right.svg":"3eXla","/src/app/img/ui/typo-italic.svg":"2FQYk","/src/app/img/ui/typo-bold.svg":"7tu17","../../components/image-toggle":"jkvyd","../../components/select":"jmugN","../../../../bb/base/c":"eg9k9","../../../../../fonts/fonts":"cwSY8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"k02ho":[function(require,module,exports) {
module.exports = require("ee995c1bd9120c5d").getBundleURL("d3gnI") + "align-left.1cd0ddfe.svg" + "?" + Date.now();

},{"ee995c1bd9120c5d":"lgJ39"}],"b6ZNm":[function(require,module,exports) {
module.exports = require("d11dcf9563b34479").getBundleURL("d3gnI") + "align-center.91068397.svg" + "?" + Date.now();

},{"d11dcf9563b34479":"lgJ39"}],"3eXla":[function(require,module,exports) {
module.exports = require("cfbca77b9f4b36ca").getBundleURL("d3gnI") + "align-right.fe8f26ce.svg" + "?" + Date.now();

},{"cfbca77b9f4b36ca":"lgJ39"}],"2FQYk":[function(require,module,exports) {
module.exports = require("6ab1e661cf985b80").getBundleURL("d3gnI") + "typo-italic.9b78c576.svg" + "?" + Date.now();

},{"6ab1e661cf985b80":"lgJ39"}],"7tu17":[function(require,module,exports) {
module.exports = require("be292e0b48e4df2f").getBundleURL("d3gnI") + "typo-bold.c02eed23.svg" + "?" + Date.now();

},{"be292e0b48e4df2f":"lgJ39"}],"cwSY8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fonts", ()=>fonts);
var _caveatRegularWoff2 = require("url:./Caveat-Regular.woff2");
var _caveatRegularWoff2Default = parcelHelpers.interopDefault(_caveatRegularWoff2);
var _climateCrisisRegularVariableFontYEARWoff2 = require("url:./ClimateCrisis-Regular-VariableFont_YEAR.woff2");
var _climateCrisisRegularVariableFontYEARWoff2Default = parcelHelpers.interopDefault(_climateCrisisRegularVariableFontYEARWoff2);
var _correctionBrushWoff2 = require("url:./CorrectionBrush.woff2");
var _correctionBrushWoff2Default = parcelHelpers.interopDefault(_correctionBrushWoff2);
var _dancingScriptRegularWoff2 = require("url:./DancingScript-Regular.woff2");
var _dancingScriptRegularWoff2Default = parcelHelpers.interopDefault(_dancingScriptRegularWoff2);
var _diabolikRegularVFWoff2 = require("url:./Diabolik-Regular-VF.woff2");
var _diabolikRegularVFWoff2Default = parcelHelpers.interopDefault(_diabolikRegularVFWoff2);
var _freckleFaceRegularWoff2 = require("url:./FreckleFace-Regular.woff2");
var _freckleFaceRegularWoff2Default = parcelHelpers.interopDefault(_freckleFaceRegularWoff2);
var _gloockRegularWoff2 = require("url:./Gloock-Regular.woff2");
var _gloockRegularWoff2Default = parcelHelpers.interopDefault(_gloockRegularWoff2);
var _pachaWoff2 = require("url:./Pacha.woff2");
var _pachaWoff2Default = parcelHelpers.interopDefault(_pachaWoff2);
var _gochiHandRegularWoff2 = require("url:./GochiHand-Regular.woff2");
var _gochiHandRegularWoff2Default = parcelHelpers.interopDefault(_gochiHandRegularWoff2);
var _passionOneBoldWoff2 = require("url:./PassionOne-Bold.woff2");
var _passionOneBoldWoff2Default = parcelHelpers.interopDefault(_passionOneBoldWoff2);
var _pixeloidSansWoff2 = require("url:./PixeloidSans.woff2");
var _pixeloidSansWoff2Default = parcelHelpers.interopDefault(_pixeloidSansWoff2);
var _playpenSansThinWoff2 = require("url:./PlaypenSans-Thin.woff2");
var _playpenSansThinWoff2Default = parcelHelpers.interopDefault(_playpenSansThinWoff2);
var _quicksandLightWoff2 = require("url:./Quicksand-Light.woff2");
var _quicksandLightWoff2Default = parcelHelpers.interopDefault(_quicksandLightWoff2);
var _silkscreenRegularWoff2 = require("url:./Silkscreen-Regular.woff2");
var _silkscreenRegularWoff2Default = parcelHelpers.interopDefault(_silkscreenRegularWoff2);
var _tehrocRegularWoff2 = require("url:./Tehroc-Regular.woff2");
var _tehrocRegularWoff2Default = parcelHelpers.interopDefault(_tehrocRegularWoff2);
var _yungaDisplayWoff2 = require("url:./YUNGA-Display.woff2");
var _yungaDisplayWoff2Default = parcelHelpers.interopDefault(_yungaDisplayWoff2);
const fonts = [
    {
        name: "Caveat",
        url: (0, _caveatRegularWoff2Default.default)
    },
    {
        name: "ClimateCrisis",
        url: (0, _climateCrisisRegularVariableFontYEARWoff2Default.default)
    },
    {
        name: "CorrectionBrush",
        url: (0, _correctionBrushWoff2Default.default)
    },
    {
        name: "DancingScript",
        url: (0, _dancingScriptRegularWoff2Default.default)
    },
    {
        name: "Diabolik",
        url: (0, _diabolikRegularVFWoff2Default.default)
    },
    {
        name: "FreckleFace",
        url: (0, _freckleFaceRegularWoff2Default.default)
    },
    {
        name: "Gloock",
        url: (0, _gloockRegularWoff2Default.default)
    },
    {
        name: "GochiHand",
        url: (0, _gochiHandRegularWoff2Default.default)
    },
    {
        name: "Pacha",
        url: (0, _pachaWoff2Default.default)
    },
    {
        name: "PassionOne",
        url: (0, _passionOneBoldWoff2Default.default)
    },
    {
        name: "PixeloidSans",
        url: (0, _pixeloidSansWoff2Default.default)
    },
    {
        name: "PlaypenSans",
        url: (0, _playpenSansThinWoff2Default.default)
    },
    {
        name: "Quicksand",
        url: (0, _quicksandLightWoff2Default.default)
    },
    {
        name: "Silkscreen",
        url: (0, _silkscreenRegularWoff2Default.default)
    },
    {
        name: "Tehroc",
        url: (0, _tehrocRegularWoff2Default.default)
    },
    {
        name: "YUNGA",
        url: (0, _yungaDisplayWoff2Default.default)
    }
];

},{"url:./Caveat-Regular.woff2":"f369o","url:./ClimateCrisis-Regular-VariableFont_YEAR.woff2":"7ihzw","url:./CorrectionBrush.woff2":"7qpCV","url:./DancingScript-Regular.woff2":"hrq2q","url:./Diabolik-Regular-VF.woff2":"aKGD1","url:./FreckleFace-Regular.woff2":"9Dolc","url:./Gloock-Regular.woff2":"litVf","url:./Pacha.woff2":"3uJw2","url:./GochiHand-Regular.woff2":"kG0EX","url:./PassionOne-Bold.woff2":"1NV86","url:./PixeloidSans.woff2":"jBPjR","url:./PlaypenSans-Thin.woff2":"5ANS9","url:./Quicksand-Light.woff2":"2NMcC","url:./Silkscreen-Regular.woff2":"kw3Fw","url:./Tehroc-Regular.woff2":"3k0Bz","url:./YUNGA-Display.woff2":"4L8xB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"f369o":[function(require,module,exports) {
module.exports = require("24c22c489369a5c6").getBundleURL("d3gnI") + "Caveat-Regular.82781654.woff2" + "?" + Date.now();

},{"24c22c489369a5c6":"lgJ39"}],"7ihzw":[function(require,module,exports) {
module.exports = require("323b0ee6a441e85a").getBundleURL("d3gnI") + "ClimateCrisis-Regular-VariableFont_YEAR.4b717a97.woff2" + "?" + Date.now();

},{"323b0ee6a441e85a":"lgJ39"}],"7qpCV":[function(require,module,exports) {
module.exports = require("76cd88b19ba64e83").getBundleURL("d3gnI") + "CorrectionBrush.7e93d053.woff2" + "?" + Date.now();

},{"76cd88b19ba64e83":"lgJ39"}],"hrq2q":[function(require,module,exports) {
module.exports = require("553d6ac92a1e539e").getBundleURL("d3gnI") + "DancingScript-Regular.6a9980f0.woff2" + "?" + Date.now();

},{"553d6ac92a1e539e":"lgJ39"}],"aKGD1":[function(require,module,exports) {
module.exports = require("b0f9a05f59cf0df").getBundleURL("d3gnI") + "Diabolik-Regular-VF.998fc076.woff2" + "?" + Date.now();

},{"b0f9a05f59cf0df":"lgJ39"}],"9Dolc":[function(require,module,exports) {
module.exports = require("26902ee45e28e9b5").getBundleURL("d3gnI") + "FreckleFace-Regular.dcda4608.woff2" + "?" + Date.now();

},{"26902ee45e28e9b5":"lgJ39"}],"litVf":[function(require,module,exports) {
module.exports = require("7495af3f43d3a034").getBundleURL("d3gnI") + "Gloock-Regular.d8de80e9.woff2" + "?" + Date.now();

},{"7495af3f43d3a034":"lgJ39"}],"3uJw2":[function(require,module,exports) {
module.exports = require("1a537f73d09163d7").getBundleURL("d3gnI") + "Pacha.cb11bfd1.woff2" + "?" + Date.now();

},{"1a537f73d09163d7":"lgJ39"}],"kG0EX":[function(require,module,exports) {
module.exports = require("f14988f8647de3b1").getBundleURL("d3gnI") + "GochiHand-Regular.18c88720.woff2" + "?" + Date.now();

},{"f14988f8647de3b1":"lgJ39"}],"1NV86":[function(require,module,exports) {
module.exports = require("da9c04f225abd9f0").getBundleURL("d3gnI") + "PassionOne-Bold.188f3581.woff2" + "?" + Date.now();

},{"da9c04f225abd9f0":"lgJ39"}],"jBPjR":[function(require,module,exports) {
module.exports = require("2fcc3fea4c404a90").getBundleURL("d3gnI") + "PixeloidSans.7fcd9812.woff2" + "?" + Date.now();

},{"2fcc3fea4c404a90":"lgJ39"}],"5ANS9":[function(require,module,exports) {
module.exports = require("fd54d05ac30b2617").getBundleURL("d3gnI") + "PlaypenSans-Thin.c554a6eb.woff2" + "?" + Date.now();

},{"fd54d05ac30b2617":"lgJ39"}],"2NMcC":[function(require,module,exports) {
module.exports = require("3be88d6baa278348").getBundleURL("d3gnI") + "Quicksand-Light.d3279d6f.woff2" + "?" + Date.now();

},{"3be88d6baa278348":"lgJ39"}],"kw3Fw":[function(require,module,exports) {
module.exports = require("a7df491e4a6079cf").getBundleURL("d3gnI") + "Silkscreen-Regular.cf20f5aa.woff2" + "?" + Date.now();

},{"a7df491e4a6079cf":"lgJ39"}],"3k0Bz":[function(require,module,exports) {
module.exports = require("249a559d634b188e").getBundleURL("d3gnI") + "Tehroc-Regular.7c6f6c4e.woff2" + "?" + Date.now();

},{"249a559d634b188e":"lgJ39"}],"4L8xB":[function(require,module,exports) {
module.exports = require("74533283aea9d5b6").getBundleURL("d3gnI") + "YUNGA-Display.08d6be9f.woff2" + "?" + Date.now();

},{"74533283aea9d5b6":"lgJ39"}],"7Jp9i":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextToolStrokeUI", ()=>TextToolStrokeUI);
var _bb = require("../../../../bb/bb");
var _colorOptions = require("../../components/color-options");
var _klSlider = require("../../components/kl-slider");
var _language = require("../../../../language/language");
var _c = require("../../../../bb/base/c");
var _base = require("../../../../bb/base/base");
class TextToolStrokeUI {
    // ---- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: {
                boxShadow: "0 0 0 1px #aaa"
            }
        });
        const emit = ()=>{
            p.onUpdate(this.getValues());
        };
        const colorOptionsArr = [
            null,
            p.stroke ? {
                ...p.stroke.color,
                a: 1
            } : null,
            {
                ...p.secondaryColor,
                a: 1
            },
            {
                ...p.primaryColor,
                a: 1
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            },
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }
        ];
        this.colorOptions = new (0, _colorOptions.ColorOptions)({
            colorArr: colorOptionsArr,
            initialIndex: p.stroke ? 1 : 0,
            title: (0, _language.LANG)("shape-stroke"),
            onChange: (c)=>{
                this.opacitySlider.getElement().style.display = c !== null ? "" : "none";
                this.lineWidthSlider.getElement().style.display = c !== null ? "" : "none";
                emit();
            }
        });
        this.opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("opacity"),
            width: 150,
            height: 30,
            min: 0.01,
            max: 1,
            value: p.stroke ? p.stroke.color.a : 1,
            resolution: 225,
            eventResMs: 1000 / 30,
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100,
            onChange: ()=>emit()
        });
        this.lineWidthSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("shape-line-width"),
            width: 150,
            height: 30,
            min: 0.5,
            max: 100,
            value: p.stroke ? p.stroke.lineWidth : 2,
            eventResMs: 1000 / 30,
            curve: "quadratic",
            onChange: ()=>emit()
        });
        this.opacitySlider.getElement().style.display = p.stroke ? "" : "none";
        this.lineWidthSlider.getElement().style.display = p.stroke ? "" : "none";
        const svg = (0, _base.createSvg)({
            elementType: "svg",
            class: "dark-invert",
            width: "25px",
            height: "25px",
            viewBox: "0 0 30 30",
            childrenArr: [
                {
                    elementType: "polyline",
                    points: "0,0 30,0 30,8 19,8 19,30 11,30 11,8 0,8 0,0 1,0",
                    fill: "none",
                    stroke: "#000c",
                    "stroke-width": "3",
                    "transform-origin": "15px 15px",
                    transform: "scale(0.8)"
                }
            ]
        });
        this.rootEl = (0, _c.c)(",flex,gap-10,items-center,flexWrap,minh-30", [
            svg,
            this.colorOptions.getElement(),
            this.opacitySlider.getElement(),
            this.lineWidthSlider.getElement()
        ]);
    }
    getElement() {
        return this.rootEl;
    }
    getValues() {
        const c = this.colorOptions.getValue();
        if (c === null || c?.a === 0) return {
            stroke: undefined
        };
        const color = {
            ...c,
            a: this.opacitySlider.getValue()
        };
        return {
            stroke: {
                color,
                lineWidth: this.lineWidthSlider.getValue()
            }
        };
    }
    destroy() {
        this.colorOptions.destroy();
        this.opacitySlider.destroy();
        this.lineWidthSlider.destroy();
    }
}

},{"../../../../bb/bb":"dcQKo","../../components/color-options":"iXzf7","../../components/kl-slider":"4hcvv","../../../../language/language":"iiYGN","../../../../bb/base/c":"eg9k9","../../../../bb/base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"10HCb":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextToolTextUI", ()=>TextToolTextUI);
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
var _c = require("../../../../bb/base/c");
class TextToolTextUI {
    emit() {
        const text = this.textInput.value;
        if (text === this.lastEmittedText) return;
        this.lastEmittedText = text;
        this.onUpdate({
            text
        });
    }
    // ---- public ----
    constructor(p){
        this.onInput = ()=>{
            this.emit();
        };
        this.lastEmittedText = p.text;
        this.onUpdate = p.onUpdate;
        this.rootEl = (0, _c.c)("");
        this.textInput = (0, _bb.BB).el({
            tagName: "textarea",
            parent: this.rootEl,
            content: p.text,
            custom: {
                placeholder: (0, _language.LANG)("text-placeholder")
            },
            css: {
                whiteSpace: "pre",
                overflow: "auto",
                width: "100%",
                height: "70px",
                resize: "vertical"
            },
            onChange: ()=>{
                this.emit();
            }
        });
        this.textInput.addEventListener("input", this.onInput);
    }
    getElement() {
        return this.rootEl;
    }
    getValues() {
        return {
            text: this.textInput.value
        };
    }
    focus() {
        this.textInput.focus();
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.textInput);
        this.textInput.removeEventListener("input", this.onInput);
    }
}

},{"../../../../bb/bb":"dcQKo","../../../../language/language":"iiYGN","../../../../bb/base/c":"eg9k9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jIp7t":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "TextToolViewportUI", ()=>TextToolViewportUI);
var _bb = require("../../../../bb/bb");
var _base = require("../../../../bb/base/base");
var _theme = require("../../../../theme/theme");
var _renderText = require("../../../image-operations/render-text");
var _klSlider = require("../../components/kl-slider");
var _language = require("../../../../language/language");
var _toolZoomInSvg = require("/src/app/img/ui/tool-zoom-in.svg");
var _toolZoomInSvgDefault = parcelHelpers.interopDefault(_toolZoomInSvg);
var _toolZoomOutSvg = require("/src/app/img/ui/tool-zoom-out.svg");
var _toolZoomOutSvgDefault = parcelHelpers.interopDefault(_toolZoomOutSvg);
var _c = require("../../../../bb/base/c");
class TextToolViewportUI {
    canZoom(d) {
        return this.zoomFac !== Math.min(2, Math.max(-2, this.zoomFac + d));
    }
    changeZoomFac(d) {
        this.zoomFac = Math.min(2, Math.max(-2, this.zoomFac + d));
        this.render();
        this.zoomInBtn.disabled = !this.canZoom(1);
        this.zoomOutBtn.disabled = !this.canZoom(-1);
    }
    /** Move text by x y **/ move(x, y) {
        const rotated = (0, _bb.BB).rotate(x, y, -this.rotationSlider.getValue() / Math.PI * 180);
        this.text.x += rotated.x / this.scale;
        this.text.y += rotated.y / this.scale;
        this.render();
    }
    // ---- public ----
    constructor(p){
        this.offset = {
            x: 0,
            y: 0
        };
        this.zoomFac = 0;
        this.scale = 1;
        this.layerArr = [];
        this.onDarkChange = ()=>{
            this.checkerPattern = (0, _base.throwIfNull)(this.previewCtx.createPattern((0, _bb.BB).createCheckerCanvas(8, (0, _theme.theme).isDark()), "repeat"));
            this.render();
        };
        this.rootEl = (0, _c.c)();
        this.text = p.text;
        this.layerIndex = p.layerIndex;
        const isSmallWidth = window.innerWidth < 550;
        const isSmallHeight = window.innerHeight < 630;
        // --- preview ---
        // Text drawn on klCanvas-sized canvas: textCanvas
        // LayerArr[target].canvas & textCanvas then drawn on targetCanvas
        //      they are transformed. canvas size of final preview
        // All layers and targetCanvas drawn on layersCanvas. transformed and size of final preview
        // Checkerboard, layersCanvas, and outline then drawn on previewCanvas
        this.width = isSmallWidth ? 340 : 540;
        this.height = isSmallWidth ? isSmallHeight ? 210 : 260 : isSmallHeight ? 230 : 350;
        this.layerArr = p.klCanvas.getLayersFast();
        this.textCanvas = (0, _bb.BB).canvas(p.klCanvas.getWidth(), p.klCanvas.getHeight());
        this.textCtx = (0, _bb.BB).ctx(this.textCanvas);
        this.targetCanvas = (0, _bb.BB).canvas(this.width, this.height);
        this.targetCtx = (0, _bb.BB).ctx(this.targetCanvas);
        this.layersCanvas = (0, _bb.BB).canvas(this.width, this.height);
        this.layersCtx = (0, _bb.BB).ctx(this.layersCanvas);
        this.previewCanvas = (0, _bb.BB).canvas(this.width, this.height); // the one that is visible
        this.previewCtx = (0, _bb.BB).ctx(this.previewCanvas);
        (0, _bb.BB).css(this.previewCanvas, {
            display: "block"
        });
        this.previewWrapper = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                position: "relative",
                width: this.width + "px",
                cursor: "move",
                touchAction: "none"
            }
        });
        (0, _bb.BB).el({
            parent: this.previewWrapper,
            className: "kl-text-preview-wrapper"
        });
        this.previewWrapper.append(this.previewCanvas);
        this.checkerPattern = (0, _base.throwIfNull)(this.previewCtx.createPattern((0, _bb.BB).createCheckerCanvas(8, (0, _theme.theme).isDark()), "repeat"));
        this.emptyCanvas = (0, _bb.BB).canvas(1, 1);
        this.emptyCanvasLight = (0, _bb.BB).canvas(1, 1);
        {
            let ctx = (0, _bb.BB).ctx(this.emptyCanvas);
            ctx.fillRect(0, 0, 1, 1);
            ctx = (0, _bb.BB).ctx(this.emptyCanvasLight);
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, 0, 1, 1);
        }
        (0, _theme.theme).addIsDarkListener(this.onDarkChange);
        this.previewCanvas.oncontextmenu = (e)=>e.preventDefault();
        let dragged = false;
        let isDown = false;
        let offsetDragged = false;
        this.previewPointerListener = new (0, _bb.BB).PointerListener({
            target: this.previewCanvas,
            onPointer: (e)=>{
                // drag detect
                if (e.type === "pointerdown") {
                    dragged = false;
                    isDown = true;
                }
                if (e.type === "pointermove" && isDown) dragged = true;
                if (e.type === "pointerup") {
                    if (isDown && dragged && e.pointerType === "mouse") // With touch/pen it would be annoying to focus again,
                    // because it probably pops out the keyboard.
                    p.onDragEnd();
                    dragged = false;
                    isDown = false;
                }
                if (e.type === "pointermove" && e.button === "left") {
                    e.eventPreventDefault();
                    this.offset = {
                        x: 0,
                        y: 0
                    };
                    this.move(-e.dX, -e.dY);
                }
                if (e.type === "pointerdown" && e.button === "right") document.body.append(this.eventCapture);
                if (e.type === "pointerup") setTimeout(()=>this.eventCapture.remove(), 20);
                if (e.type === "pointermove" && e.button === "right") {
                    offsetDragged = true;
                    e.eventPreventDefault();
                    this.offset.x -= e.dX;
                    this.offset.y -= e.dY;
                    this.render();
                }
                if (e.type === "pointerup" && offsetDragged) {
                    let count = 0;
                    this.interval = setInterval(()=>{
                        if (count > 8) {
                            clearInterval(this.interval);
                            this.offset = {
                                x: 0,
                                y: 0
                            };
                            this.render();
                        }
                        this.offset = {
                            x: this.offset.x * 0.6,
                            y: this.offset.y * 0.6
                        };
                        this.render();
                        count++;
                    }, 10);
                    this.offset = {
                        x: this.offset.x * 0.6,
                        y: this.offset.y * 0.6
                    };
                    this.render();
                }
            },
            onWheel: (e)=>{
                this.changeZoomFac(-e.deltaY);
            }
        });
        const wheelPrevent = (event)=>event.preventDefault();
        this.previewCanvas.addEventListener("wheel", wheelPrevent);
        this.rotationSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("filter-transform-rotation"),
            width: 150,
            height: 30,
            min: -Math.PI,
            max: Math.PI,
            value: p.text.angleRad,
            resolution: 225,
            // eventResMs: 1000 / 30,
            toValue: (deg)=>deg * Math.PI / 180,
            toDisplayValue: (rad)=>rad / Math.PI * 180,
            onChange: ()=>{
                this.offset = {
                    x: 0,
                    y: 0
                };
                this.render();
            },
            unit: "\xb0"
        });
        this.zoomInBtn = (0, _bb.BB).el({
            tagName: "button",
            content: `<img height="20" src="${(0, _toolZoomInSvgDefault.default)}">`,
            title: (0, _language.LANG)("zoom-in"),
            onClick: ()=>this.changeZoomFac(1),
            css: {
                fontWeight: "bold"
            }
        });
        this.zoomOutBtn = (0, _bb.BB).el({
            tagName: "button",
            content: `<img height="20" src="${(0, _toolZoomOutSvgDefault.default)}">`,
            title: (0, _language.LANG)("zoom-out"),
            onClick: ()=>this.changeZoomFac(-1),
            css: {
                fontWeight: "bold"
            }
        });
        this.eventCapture = (0, _bb.BB).el({
            css: {
                position: "absolute",
                left: "0",
                top: "0",
                right: "0",
                bottom: "0",
                zIndex: "999",
                cursor: "move"
            }
        });
        this.eventCapture.oncontextmenu = (e)=>e.preventDefault();
        this.keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr)=>{
                if ((0, _bb.BB).isInputFocused(true)) return;
                const factor = this.keyListener.isPressed("shift") ? 4 : 1;
                if (keyStr === "left") this.move(-factor, 0);
                if (keyStr === "right") this.move(factor, 0);
                if (keyStr === "up") this.move(0, -factor);
                if (keyStr === "down") this.move(0, factor);
            }
        });
        this.inputsRootEl = (0, _c.c)(",flex,gap-5", [
            this.rotationSlider.getElement(),
            (0, _c.c)(),
            this.zoomInBtn,
            this.zoomOutBtn
        ]);
    }
    render() {
        // try to draw very much like klCanvasWorkspace
        const angleRad = this.rotationSlider.getValue();
        // --- draw text ---
        this.textCtx.clearRect(0, 0, this.textCanvas.width, this.textCanvas.height);
        const bounds = (0, _renderText.renderText)(this.textCanvas, {
            ...this.text,
            x: this.text.x,
            y: this.text.y,
            angleRad: this.rotationSlider.getValue()
        });
        // transform offset
        const transformedOffset = (0, _bb.BB).Vec2.mul((0, _bb.BB).rotate(this.offset.x, this.offset.y, -angleRad / Math.PI * 180), 1 / this.scale);
        // --- determine transformation of viewport ---
        // text should always be visible
        bounds.width = Math.max(bounds.width, 1);
        bounds.height = Math.max(bounds.height, 1);
        const rotatedXY = (0, _bb.BB).rotate(bounds.x, bounds.y, -angleRad / Math.PI * 180);
        const rotatedWH = (0, _bb.BB).rotate(bounds.width, bounds.height, -angleRad / Math.PI * 180);
        const centerX = this.text.x + rotatedXY.x + rotatedWH.x / 2 + transformedOffset.x;
        const centerY = this.text.y + rotatedXY.y + rotatedWH.y / 2 + transformedOffset.y;
        const padding = 100;
        const fitBounds = (0, _bb.BB).fitInto(bounds.width, bounds.height, this.width - padding, this.height - padding);
        this.scale = Math.min(1, fitBounds.width / bounds.width);
        this.scale = Math.min(4, this.scale * Math.pow(2, this.zoomFac));
        // --- compose text and target layer ---
        this.targetCtx.save();
        if (this.scale >= 4) this.targetCtx.imageSmoothingEnabled = false;
        else {
            this.targetCtx.imageSmoothingEnabled = true;
            this.targetCtx.imageSmoothingQuality = this.scale >= 1 ? "low" : "medium";
        }
        this.targetCtx.clearRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
        this.targetCtx.translate(this.width / 2, this.height / 2);
        this.targetCtx.scale(this.scale, this.scale);
        this.targetCtx.rotate(angleRad);
        this.targetCtx.drawImage(this.layerArr[this.layerIndex].canvas, -centerX, -centerY);
        this.targetCtx.drawImage(this.textCanvas, -centerX, -centerY);
        this.targetCtx.restore();
        const isDark = (0, _theme.theme).isDark();
        // --- layers ---
        this.layersCtx.save();
        this.layersCtx.fillStyle = isDark ? "rgb(33,33,33)" : "rgb(158,158,158)";
        this.layersCtx.fillRect(0, 0, this.width, this.height);
        {
            this.layersCtx.save();
            this.layersCtx.translate(this.width / 2, this.height / 2);
            this.layersCtx.scale(this.scale, this.scale);
            this.layersCtx.rotate(angleRad);
            this.layersCtx.imageSmoothingEnabled = false;
            //outline
            const borderSize = 1 / this.scale;
            this.layersCtx.globalAlpha = isDark ? 0.25 : 0.2;
            this.layersCtx.drawImage(isDark ? this.emptyCanvasLight : this.emptyCanvas, -centerX - borderSize, -centerY - borderSize, this.textCanvas.width + borderSize * 2, this.textCanvas.height + borderSize * 2);
            this.layersCtx.globalAlpha = 1;
            //erase
            this.layersCtx.globalCompositeOperation = "destination-out";
            this.layersCtx.drawImage(this.emptyCanvas, -centerX, -centerY, this.textCanvas.width, this.textCanvas.height);
            this.layersCtx.restore();
        }
        if (this.scale >= 4) this.layersCtx.imageSmoothingEnabled = false;
        else {
            this.layersCtx.imageSmoothingEnabled = true;
            this.layersCtx.imageSmoothingQuality = this.scale >= 1 ? "low" : "medium";
        }
        // layers below
        this.layersCtx.save();
        this.layersCtx.translate(this.width / 2, this.height / 2);
        this.layersCtx.scale(this.scale, this.scale);
        this.layersCtx.rotate(angleRad);
        for(let i = 0; i < this.layerIndex; i++)if (this.layerArr[i].isVisible && this.layerArr[i].opacity > 0) {
            this.layersCtx.globalAlpha = this.layerArr[i].opacity;
            this.layersCtx.globalCompositeOperation = this.layerArr[i].mixModeStr;
            this.layersCtx.drawImage(this.layerArr[i].canvas, -centerX, -centerY);
        }
        this.layersCtx.restore();
        // target layer
        this.layersCtx.globalAlpha = this.layerArr[this.layerIndex].opacity * (this.layerArr[this.layerIndex].isVisible ? 1 : 0);
        this.layersCtx.globalCompositeOperation = this.layerArr[this.layerIndex].mixModeStr;
        this.layersCtx.drawImage(this.targetCanvas, 0, 0);
        // layers above
        this.layersCtx.save();
        this.layersCtx.translate(this.width / 2, this.height / 2);
        this.layersCtx.scale(this.scale, this.scale);
        this.layersCtx.rotate(angleRad);
        for(let i = this.layerIndex + 1; i < this.layerArr.length; i++)if (this.layerArr[i].isVisible && this.layerArr[i].opacity > 0) {
            this.layersCtx.globalAlpha = this.layerArr[i].opacity;
            this.layersCtx.globalCompositeOperation = this.layerArr[i].mixModeStr;
            this.layersCtx.drawImage(this.layerArr[i].canvas, -centerX, -centerY);
        }
        this.layersCtx.restore();
        this.layersCtx.restore();
        // --- final composite ---
        this.previewCtx.save();
        this.previewCtx.fillStyle = this.checkerPattern;
        this.previewCtx.fillRect(0, 0, this.previewCanvas.width, this.previewCanvas.height);
        this.previewCtx.drawImage(this.layersCanvas, 0, 0);
        this.previewCtx.restore();
        // bounds
        this.previewCtx.save();
        this.previewCtx.globalCompositeOperation = "difference";
        this.previewCtx.strokeStyle = "#fff";
        this.previewCtx.lineWidth = 0.5;
        this.previewCtx.translate(-this.offset.x, -this.offset.y);
        this.previewCtx.strokeRect(Math.round(this.width / 2 - bounds.width / 2 * this.scale) + 0.5, Math.round(this.height / 2 - bounds.height / 2 * this.scale) + 0.5, Math.round(bounds.width * this.scale), Math.round(bounds.height * this.scale));
        this.previewCtx.restore();
    }
    getElement() {
        return this.rootEl;
    }
    getInputsElement() {
        return this.inputsRootEl;
    }
    getValues() {
        return {
            x: this.text.x,
            y: this.text.y,
            angleRad: this.rotationSlider.getValue()
        };
    }
    setText(text) {
        const x = this.text.x;
        const y = this.text.y;
        const angleRad = this.text.angleRad;
        this.text = {
            ...text,
            x,
            y,
            angleRad
        };
        this.render();
    }
    setSize(width, height) {
        if (width === this.width && height === this.height) return;
        this.width = width;
        this.height = height;
        this.targetCanvas.width = this.width;
        this.targetCanvas.height = this.height;
        this.layersCanvas.width = this.width;
        this.layersCanvas.height = this.height;
        this.previewCanvas.width = this.width;
        this.previewCanvas.height = this.height;
        this.previewWrapper.style.width = this.width + "px";
        this.render();
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.rootEl);
        (0, _bb.BB).destroyEl(this.inputsRootEl);
        (0, _bb.BB).destroyEl(this.previewWrapper);
        clearInterval(this.interval);
        this.rotationSlider.destroy();
        (0, _bb.BB).destroyEl(this.zoomInBtn);
        (0, _bb.BB).destroyEl(this.zoomOutBtn);
        this.eventCapture.remove();
        this.previewPointerListener.destroy();
        this.keyListener.destroy();
        (0, _theme.theme).removeIsDarkListener(this.onDarkChange);
    }
}

},{"../../../../bb/bb":"dcQKo","../../../../bb/base/base":"k6nNY","../../../../theme/theme":"4G3JB","../../../image-operations/render-text":"fEvNY","../../components/kl-slider":"4hcvv","../../../../language/language":"iiYGN","/src/app/img/ui/tool-zoom-in.svg":"cnuMH","/src/app/img/ui/tool-zoom-out.svg":"9Sixr","../../../../bb/base/c":"eg9k9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8UXcD":[function(require,module,exports) {
module.exports["viewportWrapper"] = `_5vlQAW_viewportWrapper`;

},{}],"8CgvP":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Shows first dialog when importing an image.
 * Where you can crop, and select import as layer or as image.
 */ parcelHelpers.export(exports, "showImportImageDialog", ()=>showImportImageDialog);
var _bb = require("../../../bb/bb");
var _cropCopy = require("../components/crop-copy");
var _checkbox = require("../components/checkbox");
var _showModal = require("./base/showModal");
var _language = require("../../../language/language");
function showImportImageDialog(p) {
    const rootEl = (0, _bb.BB).el();
    const isSmall = window.innerWidth < 550 || window.innerHeight < 550;
    const style = isSmall ? {} : {
        width: "540px"
    };
    const resolutionEl = (0, _bb.BB).el({
        css: {
            marginTop: "10px",
            textAlign: "center",
            color: "#888",
            lineHeight: "20px"
        }
    });
    const cropCopy = new (0, _cropCopy.CropCopy)({
        width: isSmall ? 340 : 540,
        height: isSmall ? 300 : 400,
        canvas: p.image.canvas,
        isNotCopy: true,
        onChange: (width, height)=>{
            if (!resolutionEl) return;
            updateResolution(width, height);
        }
    });
    (0, _bb.BB).css(cropCopy.getEl(), {
        marginLeft: "-20px"
    });
    cropCopy.getEl().title = (0, _language.LANG)("crop-drag-to-crop");
    rootEl.append(cropCopy.getEl(), resolutionEl);
    function updateResolution(w, h) {
        const fit = (0, _bb.BB).fitInto(w, h, p.maxSize, p.maxSize);
        if (fit.width < w) {
            resolutionEl.innerHTML = `<span class="kl-text-error">${w} X ${h}</span> ⟶ ${Math.round(fit.width)} X ${Math.round(fit.height)}`;
            resolutionEl.title = (0, _language.LANG)("import-too-large");
        } else {
            resolutionEl.innerHTML = `${w} X ${h}`;
            resolutionEl.title = "";
        }
    }
    updateResolution(p.image.width, p.image.height);
    let doFlatten = false;
    function showWarnings(psdWarningArr) {
        const contentArr = [];
        const warningMap = {
            "mask": "Masks not supported. Mask was applied.",
            "clipping": "Clipping not supported. Clipping layers were merged.",
            "group": "Groups not supported. Layers were ungrouped.",
            "adjustment": "Adjustment layers not supported.",
            "layer-effect": "Layer effects not supported.",
            "smart-object": "Smart objects not supported.",
            "blend-mode": "Unsupported layer blend mode.",
            "bits-per-channel": "Unsupported color depth. Only 8bit per channel supported."
        };
        for(let i = 0; i < psdWarningArr.length; i++)contentArr.push("- " + warningMap[psdWarningArr[i]]);
        alert(contentArr.join("\n"));
    }
    let flattenCheckbox;
    let warningsEl;
    if (p.image.type === "psd") {
        if (p.image.layers) {
            flattenCheckbox = new (0, _checkbox.Checkbox)({
                init: doFlatten,
                label: (0, _language.LANG)("import-flatten"),
                callback: (b)=>{
                    doFlatten = b;
                }
            });
            rootEl.append(flattenCheckbox.getElement());
            if (p.image.warningArr) {
                const noteEl = (0, _bb.BB).el({
                    className: "kl-import-note",
                    content: (0, _language.LANG)("import-psd-limited-support")
                });
                const warnings = p.image.warningArr;
                warningsEl = (0, _bb.BB).el({
                    parent: noteEl,
                    tagName: "a",
                    content: "Details",
                    css: {
                        marginLeft: "5px"
                    },
                    onClick: ()=>showWarnings(warnings)
                });
                rootEl.append(noteEl);
            }
        } else {
            const noteEl = (0, _bb.BB).el({
                className: "kl-import-note",
                content: (0, _language.LANG)("import-psd-unsupported")
            });
            rootEl.append(noteEl);
        }
    }
    function callback(result) {
        const croppedImage = cropCopy.getCroppedCanvas();
        const cropRect = cropCopy.getRect();
        const isCropped = p.image.width !== cropRect.width && p.image.height !== cropRect.height;
        cropCopy.destroy();
        (0, _bb.BB).destroyEl(warningsEl);
        if (flattenCheckbox) flattenCheckbox.destroy();
        if (result === (0, _language.LANG)("import-btn-as-layer")) {
            p.callback({
                type: "as-layer",
                image: isCropped ? croppedImage : p.image.canvas
            });
            if (!isCropped) (0, _bb.BB).freeCanvas(croppedImage);
        } else if (result === (0, _language.LANG)("import-btn-as-image")) {
            if (p.image.type === "psd") {
                if (doFlatten) delete p.image.layers;
                p.callback({
                    type: "as-image-psd",
                    image: p.image,
                    cropObj: cropRect
                });
                (0, _bb.BB).freeCanvas(croppedImage);
            } else if (p.image.type === "image") p.callback({
                type: "as-image",
                image: croppedImage
            });
        } else {
            p.callback({
                type: "cancel"
            });
            (0, _bb.BB).freeCanvas(croppedImage);
        }
    }
    (0, _showModal.showModal)({
        target: p.target,
        message: `<b>${(0, _language.LANG)("import-title")}</b>`,
        div: rootEl,
        style,
        buttons: [
            (0, _language.LANG)("import-btn-as-layer"),
            (0, _language.LANG)("import-btn-as-image"),
            "Cancel"
        ],
        primaries: [
            (0, _language.LANG)("import-btn-as-layer"),
            (0, _language.LANG)("import-btn-as-image")
        ],
        callback,
        autoFocus: "As Image"
    });
}

},{"../../../bb/bb":"dcQKo","../components/crop-copy":"aTBXS","../components/checkbox":"8fYiz","./base/showModal":"hr9Po","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"Q3aBW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "blendPsdToKl", ()=>blendPsdToKl);
parcelHelpers.export(exports, "blendKlToPsd", ()=>blendKlToPsd);
/**
 * Converts ag-psd object into something that KlCanvas can represent
 * @param psdObj
 */ parcelHelpers.export(exports, "readPsd", ()=>readPsd);
parcelHelpers.export(exports, "klPsdToKlProject", ()=>klPsdToKlProject);
var _createCanvas = require("../../bb/base/create-canvas");
var _language = require("../../language/language");
var _klCanvas = require("../canvas/kl-canvas");
var _bb = require("../../bb/bb");
var _base = require("../../bb/base/base");
let kl2PsdMap;
let psd2KlMap;
function init() {
    if (kl2PsdMap) return;
    kl2PsdMap = {
        "source-over": "normal",
        "darken": "darken",
        "multiply": "multiply",
        "color-burn": "color burn",
        "lighten": "lighten",
        "screen": "screen",
        "color-dodge": "color dodge",
        "overlay": "overlay",
        "soft-light": "soft light",
        "hard-light": "hard light",
        "difference": "difference",
        "exclusion": "exclusion",
        "hue": "hue",
        "saturation": "saturation",
        "color": "color",
        "luminosity": "luminosity"
    };
    psd2KlMap = Object.fromEntries(Object.entries(kl2PsdMap).map((a)=>a.reverse()));
}
function blendPsdToKl(str) {
    init();
    return psd2KlMap[str];
}
function blendKlToPsd(str) {
    init();
    return kl2PsdMap[str];
}
function readPsd(psdObj) {
    if (!psdObj.canvas) throw new Error("psdObj.canvas undefined");
    const result = {
        type: "psd",
        canvas: psdObj.canvas,
        width: psdObj.width,
        height: psdObj.height
    };
    function addWarning(warningStr) {
        if (!result.warningArr) result.warningArr = [];
        if (result.warningArr.includes(warningStr)) return;
        result.warningArr.push(warningStr);
    }
    function getMixModeStr(blendMode) {
        let mixModeStr = blendPsdToKl(blendMode);
        if (!mixModeStr) {
            addWarning("blend-mode");
            mixModeStr = "source-over";
        }
        return mixModeStr;
    }
    if (psdObj.bitsPerChannel !== 8) addWarning("bits-per-channel");
    if (!psdObj.children) {
        result.error = true;
        return result;
    }
    // count resulting layers
    const maxLayers = (0, _klCanvas.MAX_LAYERS);
    let layerCount = 0;
    function countWithinGroup(groupObj) {
        let result = 0;
        if (groupObj.blendMode) {
            const mixModeStr = blendPsdToKl(groupObj.blendMode);
            if (mixModeStr && mixModeStr !== "source-over") return 1;
        }
        if (groupObj.children) for(let i = 0; i < groupObj.children.length; i++){
            const item = groupObj.children[i];
            if (item.clipping || item.adjustment) continue;
            if (item.children) {
                addWarning("group");
                result += countWithinGroup(item);
            } else result++;
        }
        return result;
    }
    layerCount += countWithinGroup(psdObj);
    if (layerCount > maxLayers) {
        result.error = true;
        return result;
    }
    result.layers = [];
    function prepareMask(maskCanvas, defaultColor) {
        const groupMaskCtx = (0, _bb.BB).ctx(maskCanvas);
        const imData = groupMaskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
        if (defaultColor === 0) for(let i = 0; i < imData.data.length; i += 4)imData.data[i + 3] = imData.data[i];
        else for(let i = 0; i < imData.data.length; i += 4)imData.data[i + 3] = 255 - imData.data[i];
        groupMaskCtx.putImageData(imData, 0, 0);
    }
    function convertGroup(psdGroupObj) {
        let resultArr = [];
        const groupIsVisible = !psdGroupObj.hidden;
        const groupOpacity = (0, _base.throwIfUndefined)(psdGroupObj.opacity, "groupOpacity is undefined");
        const groupMixModeStr = getMixModeStr(psdGroupObj.blendMode);
        let groupCanvas;
        let groupCtx;
        if (groupMixModeStr !== "source-over") {
            groupCanvas = (0, _createCanvas.createCanvas)(result.width, result.height);
            groupCtx = (0, _bb.BB).ctx(groupCanvas);
        }
        // prepare group mask
        if (psdGroupObj.mask) {
            addWarning("mask");
            prepareMask(psdGroupObj.mask.canvas, psdGroupObj.mask.defaultColor);
        }
        if (psdGroupObj.children) for(let i = 0; i < psdGroupObj.children.length; i++){
            const item = psdGroupObj.children[i];
            if (item.clipping) continue;
            if (item.adjustment) {
                addWarning("adjustment");
                continue;
            }
            const hasClipping = (item.children || item.canvas) && psdGroupObj.children[i + 1] && psdGroupObj.children[i + 1].clipping;
            if (hasClipping) addWarning("clipping");
            if (item.children) {
                const convertedChildGroupItems = convertGroup(item);
                for(let e = 0; e < convertedChildGroupItems.length; e++){
                    const innerItem = convertedChildGroupItems[e];
                    const innerCtx = (0, _bb.BB).ctx(innerItem.image);
                    // clipping
                    if (hasClipping) {
                        const clippingCanvas = (0, _createCanvas.createCanvas)(result.width, result.height);
                        const clippingCtx = (0, _bb.BB).ctx(clippingCanvas);
                        clippingCtx.drawImage(innerItem.image, 0, 0);
                        for(let f = i + 1; f < psdGroupObj.children.length && psdGroupObj.children[f].clipping; f++){
                            const clippingItem = psdGroupObj.children[f];
                            if (clippingItem.opacity === 0 || clippingItem.hidden) continue;
                            if (clippingItem.blendMode === undefined) throw new Error("clippingItem.blendMode undefined");
                            if (clippingItem.opacity === undefined) throw new Error("clippingItem.opacity undefined");
                            if (clippingItem.canvas === undefined) throw new Error("clippingItem.canvas undefined");
                            if (clippingItem.left === undefined) throw new Error("clippingItem.left undefined");
                            if (clippingItem.top === undefined) throw new Error("clippingItem.top undefined");
                            clippingCtx.globalCompositeOperation = getMixModeStr(clippingItem.blendMode);
                            clippingCtx.globalAlpha = clippingItem.opacity;
                            clippingCtx.drawImage(clippingItem.canvas, clippingItem.left, clippingItem.top);
                        }
                        innerCtx.globalCompositeOperation = "source-atop";
                        innerCtx.drawImage(clippingCanvas, 0, 0);
                    }
                    // group mask
                    if (psdGroupObj.mask) {
                        innerCtx.globalCompositeOperation = psdGroupObj.mask.defaultColor === 0 ? "destination-in" : "destination-out";
                        if (psdGroupObj.mask.canvas === undefined) throw new Error("psdGroupObj.mask.canvas undefined");
                        if (psdGroupObj.mask.left === undefined) throw new Error("psdGroupObj.mask.left undefined");
                        if (psdGroupObj.mask.top === undefined) throw new Error("psdGroupObj.mask.top undefined");
                        innerCtx.drawImage(psdGroupObj.mask.canvas, psdGroupObj.mask.left, psdGroupObj.mask.top);
                    }
                    if (groupCanvas) {
                        if (groupCtx === undefined) throw new Error("groupCtx undefined");
                        groupCtx.globalCompositeOperation = innerItem.mixModeStr;
                        groupCtx.globalAlpha = innerItem.opacity;
                        groupCtx.drawImage(innerItem.image, 0, 0);
                    } else {
                        innerItem.opacity = innerItem.opacity * groupOpacity;
                        resultArr.push(innerItem);
                    }
                }
                continue;
            }
            const canvas = (0, _createCanvas.createCanvas)(result.width, result.height);
            const ctx = (0, _bb.BB).ctx(canvas);
            if (item.canvas) {
                if (item.top === undefined) throw new Error("item.top undefined");
                if (item.left === undefined) throw new Error("item.left undefined");
                ctx.drawImage(item.canvas, item.left, item.top);
            }
            // effects
            if (item.effects) addWarning("layer-effect");
            // mask
            if (item.mask) {
                addWarning("mask");
                if (item.mask.canvas === undefined) throw new Error("item.mask.canvas undefined");
                if (item.mask.defaultColor === undefined) throw new Error("item.mask.defaultColor undefined");
                if (item.mask.left === undefined) throw new Error("item.mask.left undefined");
                if (item.mask.top === undefined) throw new Error("item.mask.top undefined");
                prepareMask(item.mask.canvas, item.mask.defaultColor);
                ctx.globalCompositeOperation = item.mask.defaultColor === 0 ? "destination-in" : "destination-out";
                ctx.drawImage(item.mask.canvas, item.mask.left, item.mask.top);
            }
            // clipping
            if (hasClipping) {
                if (item.right === undefined) throw new Error("item.right undefined");
                if (item.left === undefined) throw new Error("item.left undefined");
                if (item.bottom === undefined) throw new Error("item.bottom undefined");
                if (item.top === undefined) throw new Error("item.top undefined");
                if (item.canvas === undefined) throw new Error("item.canvas undefined");
                const clippingCanvas = (0, _createCanvas.createCanvas)(item.right - item.left, item.bottom - item.top);
                const clippingCtx = (0, _bb.BB).ctx(clippingCanvas);
                clippingCtx.drawImage(item.canvas, 0, 0);
                for(let e = i + 1; e < psdGroupObj.children.length && psdGroupObj.children[e].clipping; e++){
                    const clippingItem = psdGroupObj.children[e];
                    if (clippingItem.opacity === 0 || clippingItem.hidden) continue;
                    if (clippingItem.blendMode === undefined) throw new Error("clippingItem.blendMode undefined");
                    if (clippingItem.opacity === undefined) throw new Error("clippingItem.opacity undefined");
                    if (clippingItem.canvas === undefined) throw new Error("clippingItem.canvas undefined");
                    if (clippingItem.left === undefined) throw new Error("clippingItem.left undefined");
                    if (clippingItem.top === undefined) throw new Error("clippingItem.top undefined");
                    clippingCtx.globalCompositeOperation = getMixModeStr(clippingItem.blendMode);
                    clippingCtx.globalAlpha = clippingItem.opacity;
                    clippingCtx.drawImage(clippingItem.canvas, clippingItem.left - item.left, clippingItem.top - item.top);
                }
                ctx.globalCompositeOperation = "source-atop";
                ctx.drawImage(clippingCanvas, item.left, item.top);
            }
            // group mask
            if (psdGroupObj.mask) {
                ctx.globalCompositeOperation = psdGroupObj.mask.defaultColor === 0 ? "destination-in" : "destination-out";
                if (psdGroupObj.mask.canvas === undefined) throw new Error("psdGroupObj.mask.canvas undefined");
                if (psdGroupObj.mask.left === undefined) throw new Error("psdGroupObj.mask.left undefined");
                if (psdGroupObj.mask.top === undefined) throw new Error("psdGroupObj.mask.top undefined");
                ctx.drawImage(psdGroupObj.mask.canvas, psdGroupObj.mask.left, psdGroupObj.mask.top);
            }
            if (item.blendMode === undefined) throw new Error("item.blendMode undefined");
            if (item.hidden === undefined) throw new Error("item.hidden  undefined");
            if (item.opacity === undefined) throw new Error("item.opacity undefined");
            if (groupCanvas && groupCtx) {
                if (groupOpacity > 0) {
                    groupCtx.globalCompositeOperation = getMixModeStr(item.blendMode);
                    groupCtx.globalAlpha = item.hidden ? 0 : item.opacity;
                    groupCtx.drawImage(canvas, 0, 0);
                }
            } else {
                if (item.name === undefined) throw new Error("item.name undefined");
                resultArr.push({
                    name: item.name,
                    isVisible: !item.hidden && groupIsVisible,
                    opacity: item.opacity * groupOpacity,
                    mixModeStr: getMixModeStr(item.blendMode),
                    image: canvas
                });
            }
        }
        if (groupCanvas) {
            if (psdGroupObj.name === undefined) throw new Error("psdGroupObj.name undefined");
            resultArr = [
                {
                    name: psdGroupObj.name,
                    isVisible: groupIsVisible,
                    opacity: groupOpacity,
                    mixModeStr: groupMixModeStr,
                    image: groupCanvas
                }
            ];
        }
        return resultArr;
    }
    result.layers = convertGroup({
        name: "root",
        opacity: 1,
        blendMode: "normal",
        children: psdObj.children
    });
    return result;
}
function klPsdToKlProject(klPsd) {
    // only share references to Canvas elements
    const result = {
        width: klPsd.width,
        height: klPsd.height,
        layers: []
    };
    if (klPsd.layers) result.layers = klPsd.layers.map((item)=>{
        return {
            name: item.name,
            isVisible: item.isVisible,
            opacity: item.opacity,
            mixModeStr: item.mixModeStr,
            image: item.image
        };
    });
    else // flattened
    result.layers = [
        {
            name: (0, _language.LANG)("background"),
            isVisible: true,
            opacity: 1,
            mixModeStr: "source-over",
            image: klPsd.canvas
        }
    ];
    return result;
}

},{"../../bb/base/create-canvas":"4BLUK","../../language/language":"iiYGN","../canvas/kl-canvas":"l78MY","../../bb/bb":"dcQKo","../../bb/base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eCGtt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "setDbName", ()=>setDbName);
parcelHelpers.export(exports, "getKlProjectObj", ()=>getKlProjectObj);
/**
 * stores a project into id = 1 in database:dbNameStr > storage: storageNameStr
 */ parcelHelpers.export(exports, "storeKlProjectObj", ()=>storeKlProjectObj);
/**
 * deletes stored project, by removing id = 1 from database:dbNameStr > storage: storageNameStr
 */ parcelHelpers.export(exports, "clear", ()=>clear);
const indexedDbIsSupported = !!window.indexedDB;
let dbNameStr = "Klecks";
const storageNameStr = "ProjectStore";
function setDbName(name) {
    dbNameStr = "" + name;
}
/**
 * connects to db dbNameStr, then executes transaction on storageNameStr storage
 * with index 'id'
 *
 * @param actionFunction what to execute during transaction
 * @param successCallback on successful transaction
 * @param errorCallback on error
 */ function execIndexedDBTransaction(actionFunction, successCallback, errorCallback) {
    let hasFinished = false;
    function onSuccess() {
        if (hasFinished) return;
        hasFinished = true;
        successCallback();
    }
    function onError(errorStr) {
        if (hasFinished) return;
        hasFinished = true;
        errorCallback(errorStr);
    }
    if (!indexedDbIsSupported) {
        setTimeout(function() {
            onError("no indexed db available");
        }, 0);
        return;
    }
    let requestObj;
    try {
        requestObj = window.indexedDB.open(dbNameStr, 1);
    } catch (e) {
        onError(e.message);
        return;
    }
    requestObj.onupgradeneeded = function() {
        try {
            const db = requestObj.result;
            const store = db.createObjectStore(storageNameStr, {
                keyPath: "id"
            });
            store.createIndex("id", "id", {
                unique: true
            });
        } catch (e) {
            onError(e.message);
        }
    };
    requestObj.onerror = function() {
        onError("indexedDB.open failed, " + requestObj.error);
    };
    requestObj.onsuccess = function() {
        let databaseObj;
        let transactionObj;
        let storeObj;
        try {
            databaseObj = requestObj.result;
            if (!databaseObj.objectStoreNames.contains(storageNameStr)) {
                //someone maybe messed with the db, or creation failed earlier
                //it's broken -> destroy
                window.indexedDB.deleteDatabase(dbNameStr);
                onError("object store " + storageNameStr + " missing. destroying db");
                return;
            }
            transactionObj = databaseObj.transaction(storageNameStr, "readwrite");
            storeObj = transactionObj.objectStore(storageNameStr);
            storeObj.index("id");
        } catch (e) {
            onError(e.message);
            return;
        }
        databaseObj.onerror = function() {
            onError("database error, " + databaseObj.error);
        };
        try {
            actionFunction(storeObj);
        } catch (e) {
            onError(e.message);
            return;
        }
        transactionObj.oncomplete = function() {
            onSuccess();
            databaseObj.close();
        };
        transactionObj.onerror = function() {
            onError("transaction error, " + transactionObj.error);
        };
    };
}
function getKlProjectObj(successCallback, errorCallback) {
    if (indexedDbIsSupported) {
        let query;
        execIndexedDBTransaction(function(storeObj) {
            query = storeObj.get(1);
        }, function() {
            successCallback(query.result);
        }, function(errorStr) {
            errorCallback("execIndexedDBTransaction error, " + errorStr);
        });
    } else successCallback(undefined);
}
function storeKlProjectObj(storageProject, successCallback, errorCallback) {
    execIndexedDBTransaction(function(storeObj) {
        storeObj.put(storageProject);
    }, function() {
        successCallback();
    }, function(errorStr) {
        errorCallback(errorStr);
    });
}
function clear(successCallback, errorCallback) {
    execIndexedDBTransaction(function(storeObj) {
        storeObj.delete(1);
    }, function() {
        successCallback();
    }, function(error) {
        errorCallback(error);
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"lIjDv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterLibStatus", ()=>filterLibStatus);
parcelHelpers.export(exports, "filterLib", ()=>filterLib);
var _editBrightnessContrastSvg = require("/src/app/img/ui/edit-brightness-contrast.svg");
var _editBrightnessContrastSvgDefault = parcelHelpers.interopDefault(_editBrightnessContrastSvg);
var _editCropSvg = require("/src/app/img/ui/edit-crop.svg");
var _editCropSvgDefault = parcelHelpers.interopDefault(_editCropSvg);
var _editCurvesSvg = require("/src/app/img/ui/edit-curves.svg");
var _editCurvesSvgDefault = parcelHelpers.interopDefault(_editCurvesSvg);
var _editFlipSvg = require("/src/app/img/ui/edit-flip.svg");
var _editFlipSvgDefault = parcelHelpers.interopDefault(_editFlipSvg);
var _editHueSaturationSvg = require("/src/app/img/ui/edit-hue-saturation.svg");
var _editHueSaturationSvgDefault = parcelHelpers.interopDefault(_editHueSaturationSvg);
var _editInvertPng = require("/src/app/img/ui/edit-invert.png");
var _editInvertPngDefault = parcelHelpers.interopDefault(_editInvertPng);
var _editPerspectiveSvg = require("/src/app/img/ui/edit-perspective.svg");
var _editPerspectiveSvgDefault = parcelHelpers.interopDefault(_editPerspectiveSvg);
var _editResizeSvg = require("/src/app/img/ui/edit-resize.svg");
var _editResizeSvgDefault = parcelHelpers.interopDefault(_editResizeSvg);
var _editRotateSvg = require("/src/app/img/ui/edit-rotate.svg");
var _editRotateSvgDefault = parcelHelpers.interopDefault(_editRotateSvg);
var _editTiltShiftPng = require("/src/app/img/ui/edit-tilt-shift.png");
var _editTiltShiftPngDefault = parcelHelpers.interopDefault(_editTiltShiftPng);
var _editToAlphaSvg = require("/src/app/img/ui/edit-to-alpha.svg");
var _editToAlphaSvgDefault = parcelHelpers.interopDefault(_editToAlphaSvg);
var _editTransformSvg = require("/src/app/img/ui/edit-transform.svg");
var _editTransformSvgDefault = parcelHelpers.interopDefault(_editTransformSvg);
var _editTriangleBlurPng = require("/src/app/img/ui/edit-triangle-blur.png");
var _editTriangleBlurPngDefault = parcelHelpers.interopDefault(_editTriangleBlurPng);
var _editUnsharpMaskPng = require("/src/app/img/ui/edit-unsharp-mask.png");
var _editUnsharpMaskPngDefault = parcelHelpers.interopDefault(_editUnsharpMaskPng);
var _editGridSvg = require("/src/app/img/ui/edit-grid.svg");
var _editGridSvgDefault = parcelHelpers.interopDefault(_editGridSvg);
var _editNoiseSvg = require("/src/app/img/ui/edit-noise.svg");
var _editNoiseSvgDefault = parcelHelpers.interopDefault(_editNoiseSvg);
var _editPatternSvg = require("/src/app/img/ui/edit-pattern.svg");
var _editPatternSvgDefault = parcelHelpers.interopDefault(_editPatternSvg);
var _editVanishPointSvg = require("/src/app/img/ui/edit-vanish-point.svg");
var _editVanishPointSvgDefault = parcelHelpers.interopDefault(_editVanishPointSvg);
var _editDistortSvg = require("/src/app/img/ui/edit-distort.svg");
var _editDistortSvgDefault = parcelHelpers.interopDefault(_editDistortSvg);
const filterLibStatus = {
    isLoaded: false
};
const filterLib = {
    brightnessContrast: {
        lang: {
            name: "filter-bright-contrast-title",
            button: "filter-bright-contrast",
            description: "filter-bright-contrast-description"
        },
        icon: (0, _editBrightnessContrastSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    cropExtend: {
        lang: {
            name: "filter-crop-title",
            button: "filter-crop-extend",
            description: "filter-crop-description"
        },
        icon: (0, _editCropSvgDefault.default),
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    curves: {
        lang: {
            name: "filter-curves-title",
            button: "filter-curves",
            description: "filter-curves-description"
        },
        icon: (0, _editCurvesSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    distort: {
        lang: {
            name: "filter-distort",
            button: "filter-distort",
            description: "filter-distort-description"
        },
        icon: (0, _editDistortSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    flip: {
        lang: {
            name: "filter-flip-title",
            button: "filter-flip",
            description: "filter-flip-description"
        },
        icon: (0, _editFlipSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    hueSaturation: {
        lang: {
            name: "filter-hue-sat-title",
            button: "filter-hue-sat",
            description: "filter-hue-sat-description"
        },
        icon: (0, _editHueSaturationSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        darkNoInvert: true,
        webGL: true
    },
    invert: {
        lang: {
            name: "filter-invert",
            button: "filter-invert"
        },
        icon: (0, _editInvertPngDefault.default),
        updatePos: false,
        isInstant: true,
        getDialog: null,
        apply: null,
        inEmbed: true,
        darkNoInvert: true,
        webGL: true
    },
    perspective: {
        lang: {
            name: "filter-perspective-title",
            button: "filter-perspective",
            description: "filter-perspective-description"
        },
        icon: (0, _editPerspectiveSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    resize: {
        lang: {
            name: "filter-resize-title",
            button: "filter-resize",
            description: "filter-resize-description"
        },
        icon: (0, _editResizeSvgDefault.default),
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    rotate: {
        lang: {
            name: "filter-rotate-title",
            button: "filter-rotate",
            description: "filter-rotate-description"
        },
        icon: (0, _editRotateSvgDefault.default),
        updatePos: true,
        getDialog: null,
        apply: null,
        inEmbed: false
    },
    tiltShift: {
        lang: {
            name: "filter-tilt-shift-title",
            button: "filter-tilt-shift",
            description: "filter-tilt-shift-description"
        },
        icon: (0, _editTiltShiftPngDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    toAlpha: {
        lang: {
            name: "filter-to-alpha-title",
            button: "filter-to-alpha",
            description: "filter-to-alpha-description"
        },
        icon: (0, _editToAlphaSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        darkNoInvert: true,
        webGL: true
    },
    transform: {
        lang: {
            name: "filter-transform-title",
            button: "filter-transform",
            description: "filter-transform-description"
        },
        icon: (0, _editTransformSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    blur: {
        lang: {
            name: "filter-triangle-blur-title",
            button: "filter-triangle-blur",
            description: "filter-triangle-blur-description"
        },
        icon: (0, _editTriangleBlurPngDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        darkNoInvert: true,
        webGL: true
    },
    unsharpMask: {
        lang: {
            name: "filter-unsharp-mask-title",
            button: "filter-unsharp-mask",
            description: "filter-unsharp-mask-description"
        },
        icon: (0, _editUnsharpMaskPngDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        darkNoInvert: true,
        webGL: true
    },
    grid: {
        lang: {
            name: "filter-grid",
            button: "filter-grid",
            description: "filter-grid-description"
        },
        icon: (0, _editGridSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    noise: {
        lang: {
            name: "filter-noise",
            button: "filter-noise",
            description: "filter-noise-description"
        },
        icon: (0, _editNoiseSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true,
        webGL: true
    },
    pattern: {
        lang: {
            name: "filter-pattern",
            button: "filter-pattern",
            description: "filter-pattern-description"
        },
        icon: (0, _editPatternSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    },
    vanishPoint: {
        lang: {
            name: "filter-vanish-point-title",
            button: "filter-vanish-point",
            description: "filter-vanish-point-description"
        },
        icon: (0, _editVanishPointSvgDefault.default),
        updatePos: false,
        getDialog: null,
        apply: null,
        inEmbed: true
    }
};

},{"/src/app/img/ui/edit-brightness-contrast.svg":"2y5N7","/src/app/img/ui/edit-crop.svg":"tY4Ae","/src/app/img/ui/edit-curves.svg":"couVH","/src/app/img/ui/edit-flip.svg":"h0cWi","/src/app/img/ui/edit-hue-saturation.svg":"e16VO","/src/app/img/ui/edit-invert.png":"1HCKD","/src/app/img/ui/edit-perspective.svg":"e9qJ2","/src/app/img/ui/edit-resize.svg":"bJacj","/src/app/img/ui/edit-rotate.svg":"bDgUa","/src/app/img/ui/edit-tilt-shift.png":"gWxz1","/src/app/img/ui/edit-to-alpha.svg":"juZ2n","/src/app/img/ui/edit-transform.svg":"8s2Qf","/src/app/img/ui/edit-triangle-blur.png":"jGAbR","/src/app/img/ui/edit-unsharp-mask.png":"kx2Eu","/src/app/img/ui/edit-grid.svg":"1ev5t","/src/app/img/ui/edit-noise.svg":"3ALCY","/src/app/img/ui/edit-pattern.svg":"dF3d7","/src/app/img/ui/edit-vanish-point.svg":"gUhKf","/src/app/img/ui/edit-distort.svg":"kIJVM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2y5N7":[function(require,module,exports) {
module.exports = require("4ff590a76a35262a").getBundleURL("d3gnI") + "edit-brightness-contrast.2c9c4981.svg" + "?" + Date.now();

},{"4ff590a76a35262a":"lgJ39"}],"couVH":[function(require,module,exports) {
module.exports = require("e1a84abcad7d783d").getBundleURL("d3gnI") + "edit-curves.b414a834.svg" + "?" + Date.now();

},{"e1a84abcad7d783d":"lgJ39"}],"h0cWi":[function(require,module,exports) {
module.exports = require("63f9f11c59301a1d").getBundleURL("d3gnI") + "edit-flip.6941cde5.svg" + "?" + Date.now();

},{"63f9f11c59301a1d":"lgJ39"}],"e16VO":[function(require,module,exports) {
module.exports = require("c724f870a7533f76").getBundleURL("d3gnI") + "edit-hue-saturation.05bd5fe8.svg" + "?" + Date.now();

},{"c724f870a7533f76":"lgJ39"}],"1HCKD":[function(require,module,exports) {
module.exports = require("77cfeaa1638edfb8").getBundleURL("d3gnI") + "edit-invert.84a3e72f.png" + "?" + Date.now();

},{"77cfeaa1638edfb8":"lgJ39"}],"e9qJ2":[function(require,module,exports) {
module.exports = require("1c8d966ab148131f").getBundleURL("d3gnI") + "edit-perspective.afea99bb.svg" + "?" + Date.now();

},{"1c8d966ab148131f":"lgJ39"}],"bJacj":[function(require,module,exports) {
module.exports = require("5d94822c55ff285a").getBundleURL("d3gnI") + "edit-resize.c4f10e41.svg" + "?" + Date.now();

},{"5d94822c55ff285a":"lgJ39"}],"gWxz1":[function(require,module,exports) {
module.exports = require("94397d37ef662518").getBundleURL("d3gnI") + "edit-tilt-shift.70880153.png" + "?" + Date.now();

},{"94397d37ef662518":"lgJ39"}],"juZ2n":[function(require,module,exports) {
module.exports = require("f8ae9fbd55346f55").getBundleURL("d3gnI") + "edit-to-alpha.acfae5e2.svg" + "?" + Date.now();

},{"f8ae9fbd55346f55":"lgJ39"}],"8s2Qf":[function(require,module,exports) {
module.exports = require("89ddebea4a2c6a64").getBundleURL("d3gnI") + "edit-transform.7622dbf1.svg" + "?" + Date.now();

},{"89ddebea4a2c6a64":"lgJ39"}],"jGAbR":[function(require,module,exports) {
module.exports = require("c2920f6e8b3c1b26").getBundleURL("d3gnI") + "edit-triangle-blur.d12ea9e6.png" + "?" + Date.now();

},{"c2920f6e8b3c1b26":"lgJ39"}],"kx2Eu":[function(require,module,exports) {
module.exports = require("dabadbe98480483").getBundleURL("d3gnI") + "edit-unsharp-mask.b9482369.png" + "?" + Date.now();

},{"dabadbe98480483":"lgJ39"}],"1ev5t":[function(require,module,exports) {
module.exports = require("4bac4042b270abc7").getBundleURL("d3gnI") + "edit-grid.3787b0f4.svg" + "?" + Date.now();

},{"4bac4042b270abc7":"lgJ39"}],"3ALCY":[function(require,module,exports) {
module.exports = require("b4e056117d97358e").getBundleURL("d3gnI") + "edit-noise.e7fb4997.svg" + "?" + Date.now();

},{"b4e056117d97358e":"lgJ39"}],"dF3d7":[function(require,module,exports) {
module.exports = require("f5ee983563436637").getBundleURL("d3gnI") + "edit-pattern.3cc4b269.svg" + "?" + Date.now();

},{"f5ee983563436637":"lgJ39"}],"gUhKf":[function(require,module,exports) {
module.exports = require("7095e34e644ca6f3").getBundleURL("d3gnI") + "edit-vanish-point.c07d5afc.svg" + "?" + Date.now();

},{"7095e34e644ca6f3":"lgJ39"}],"kIJVM":[function(require,module,exports) {
module.exports = require("3b1b2160adef0f0e").getBundleURL("d3gnI") + "edit-distort.a3941278.svg" + "?" + Date.now();

},{"3b1b2160adef0f0e":"lgJ39"}],"8eOZC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "brushes", ()=>brushes);
var _penBrush = require("./pen-brush");
var _blendBrush = require("./blend-brush");
var _sketchyBrush = require("./sketchy-brush");
var _pixelBrush = require("./pixel-brush");
var _eraserBrush = require("./eraser-brush");
var _smudgeBrush = require("./smudge-brush");
var _chemyBrush = require("./chemy-brush");
const brushes = {
    PenBrush: (0, _penBrush.PenBrush),
    BlendBrush: (0, _blendBrush.BlendBrush),
    SketchyBrush: (0, _sketchyBrush.SketchyBrush),
    PixelBrush: (0, _pixelBrush.PixelBrush),
    ChemyBrush: (0, _chemyBrush.ChemyBrush),
    SmudgeBrush: (0, _smudgeBrush.SmudgeBrush),
    EraserBrush: (0, _eraserBrush.EraserBrush)
};

},{"./pen-brush":"1WbL7","./blend-brush":"1OcHF","./sketchy-brush":"goQ9y","./pixel-brush":"3s9Dy","./eraser-brush":"9XyVo","./smudge-brush":"8pk70","./chemy-brush":"3wxkc","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1WbL7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PenBrush", ()=>PenBrush);
var _bb = require("../../bb/bb");
var _brushesCommon = require("./brushes-common");
var _kl = require("../kl");
const ALPHA_CIRCLE = 0;
const ALPHA_CHALK = 1;
const ALPHA_CAL = 2; // calligraphy
const ALPHA_SQUARE = 3;
const TWO_PI = 2 * Math.PI;
class PenBrush {
    updateAlphaCanvas() {
        if (this.settingAlphaId === ALPHA_CIRCLE || this.settingAlphaId === ALPHA_SQUARE) return;
        const instructionArr = [
            [
                this.alphaCanvas128,
                128
            ],
            [
                this.alphaCanvas64,
                64
            ],
            [
                this.alphaCanvas32,
                32
            ]
        ];
        let ctx;
        for(let i = 0; i < instructionArr.length; i++){
            ctx = (0, _bb.BB).ctx(instructionArr[i][0]);
            ctx.save();
            ctx.clearRect(0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.fillStyle = "rgba(" + this.settingColor.r + ", " + this.settingColor.g + ", " + this.settingColor.b + ", " + this.alphaOpacityArr[this.settingAlphaId] + ")";
            ctx.fillRect(0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.globalCompositeOperation = "destination-in";
            ctx.imageSmoothingQuality = "high";
            ctx.drawImage((0, _brushesCommon.alphaImArr)[this.settingAlphaId], 0, 0, instructionArr[i][1], instructionArr[i][1]);
            ctx.restore();
        }
    }
    calcOpacity(pressure) {
        return this.settingOpacity * (this.settingHasOpacityPressure ? pressure * pressure : 1);
    }
    /**
     * @param x
     * @param y
     * @param size
     * @param opacity
     * @param angle
     * @param before - [x, y, size, opacity, angle] the drawDot call before
     */ drawDot(x, y, size, opacity, angle, before) {
        if (size <= 0) return;
        if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = "source-atop";
        if (!before || before[3] !== opacity) this.context.globalAlpha = opacity;
        if (!before && (this.settingAlphaId === ALPHA_CIRCLE || this.settingAlphaId === ALPHA_SQUARE)) this.context.fillStyle = this.settingColorStr;
        if (this.settingAlphaId === ALPHA_CIRCLE) {
            this.context.beginPath();
            this.context.arc(x, y, size, 0, TWO_PI);
            this.context.closePath();
            this.context.fill();
            this.hasDrawnDot = true;
        } else if (this.settingAlphaId === ALPHA_SQUARE) {
            if (angle !== undefined) {
                this.context.save();
                this.context.translate(x, y);
                this.context.rotate(angle / 180 * Math.PI);
                this.context.fillRect(-size, -size, size * 2, size * 2);
                this.context.restore();
                this.hasDrawnDot = true;
            }
        } else {
            this.context.save();
            this.context.translate(x, y);
            let targetMipmap = this.alphaCanvas128;
            if (size <= 32 && size > 16) targetMipmap = this.alphaCanvas64;
            else if (size <= 16) targetMipmap = this.alphaCanvas32;
            this.context.scale(size, size);
            if (this.settingAlphaId === ALPHA_CHALK) this.context.rotate((x + y) * 53123 % TWO_PI); // without mod it sometimes looks different
            this.context.drawImage(targetMipmap, -1, -1, 2, 2);
            this.context.restore();
            this.hasDrawnDot = true;
        }
    }
    // continueLine
    continueLine(x, y, size, pressure) {
        if (this.bezierLine === null) {
            this.bezierLine = new (0, _bb.BB).BezierLine();
            this.bezierLine.add(this.lastInput.x, this.lastInput.y, 0, ()=>{});
        }
        const drawArr = []; //draw instructions. will be all drawn at once
        const dotCallback = (val)=>{
            const localPressure = (0, _bb.BB).mix(this.lastInput2.pressure, pressure, val.t);
            const localOpacity = this.calcOpacity(localPressure);
            const localSize = Math.max(0.1, this.settingSize * (this.settingHasSizePressure ? localPressure : 1));
            drawArr.push([
                val.x,
                val.y,
                localSize,
                localOpacity,
                val.angle
            ]);
        };
        const localSpacing = size * this.settingSpacing;
        if (x === null || y === null) this.bezierLine.addFinal(localSpacing, dotCallback);
        else this.bezierLine.add(x, y, localSpacing, dotCallback);
        // execute draw instructions
        this.context.save();
        let before = undefined;
        for(let i = 0; i < drawArr.length; i++){
            const item = drawArr[i];
            this.drawDot(item[0], item[1], item[2], item[3], item[4], before);
            before = item;
        }
        this.context.restore();
    }
    // ---- public ----
    constructor(){
        this.context = {};
        this.history = new (0, _kl.KL).DecoyKlHistory();
        this.settingHasOpacityPressure = false;
        this.settingHasSizePressure = true;
        this.settingSize = 2;
        this.settingSpacing = 0.8489;
        this.settingOpacity = 1;
        this.settingColor = {};
        this.settingColorStr = "";
        this.settingAlphaId = ALPHA_CIRCLE;
        this.settingLockLayerAlpha = false;
        this.hasDrawnDot = false;
        this.lineToolLastDot = 0;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastInput2 = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.inputArr = [];
        this.inputIsDrawing = false;
        this.bezierLine = null;
        // mipmapping
        this.alphaCanvas128 = (0, _bb.BB).canvas(128, 128);
        this.alphaCanvas64 = (0, _bb.BB).canvas(64, 64);
        this.alphaCanvas32 = (0, _bb.BB).canvas(32, 32);
        this.alphaOpacityArr = [
            1,
            0.9,
            1,
            1
        ];
    }
    // ---- interface ----
    startLine(x, y, p) {
        this.historyEntry = {
            tool: [
                "brush",
                "PenBrush"
            ],
            actions: [
                {
                    action: "opacityPressure",
                    params: [
                        this.settingHasOpacityPressure
                    ]
                },
                {
                    action: "sizePressure",
                    params: [
                        this.settingHasSizePressure
                    ]
                },
                {
                    action: "setSize",
                    params: [
                        this.settingSize
                    ]
                },
                {
                    action: "setSpacing",
                    params: [
                        this.settingSpacing
                    ]
                },
                {
                    action: "setOpacity",
                    params: [
                        this.settingOpacity
                    ]
                },
                {
                    action: "setColor",
                    params: [
                        this.settingColor
                    ]
                },
                {
                    action: "setAlpha",
                    params: [
                        this.settingAlphaId
                    ]
                },
                {
                    action: "setLockAlpha",
                    params: [
                        this.settingLockLayerAlpha
                    ]
                }
            ]
        };
        p = (0, _bb.BB).clamp(p, 0, 1);
        const localOpacity = this.calcOpacity(p);
        const localSize = this.settingHasSizePressure ? Math.max(0.1, p * this.settingSize) : Math.max(0.1, this.settingSize);
        this.hasDrawnDot = false;
        this.inputIsDrawing = true;
        this.context.save();
        this.drawDot(x, y, localSize, localOpacity);
        this.context.restore();
        this.lineToolLastDot = localSize * this.settingSpacing;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2.pressure = p;
        this.inputArr = [
            {
                x,
                y,
                pressure: p
            }
        ];
        this.historyEntry.actions.push({
            action: "startLine",
            params: [
                x,
                y,
                p
            ]
        });
    }
    goLine(x, y, p) {
        if (!this.inputIsDrawing) return;
        this.historyEntry.actions.push({
            action: "goLine",
            params: [
                x,
                y,
                p
            ]
        });
        const pressure = (0, _bb.BB).clamp(p, 0, 1);
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.context.save();
        this.continueLine(x, y, localSize, this.lastInput.pressure);
        /*context.fillStyle = 'red';
        context.fillRect(Math.floor(x), Math.floor(y - 10), 1, 20);
        context.fillRect(Math.floor(x - 10), Math.floor(y), 20, 1);*/ this.context.restore();
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput2.pressure = this.lastInput.pressure;
        this.lastInput.pressure = pressure;
        this.inputArr.push({
            x,
            y,
            pressure: p
        });
    }
    endLine(x, y) {
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.context.save();
        this.continueLine(null, null, localSize, this.lastInput.pressure);
        this.context.restore();
        this.inputIsDrawing = false;
        if (this.settingAlphaId === ALPHA_SQUARE && !this.hasDrawnDot) {
            // find max pressure input, use that one
            let maxInput = this.inputArr[0];
            this.inputArr.forEach((item)=>{
                if (item.pressure > maxInput.pressure) maxInput = item;
            });
            this.context.save();
            const p = (0, _bb.BB).clamp(maxInput.pressure, 0, 1);
            const localOpacity = this.calcOpacity(p);
            this.drawDot(maxInput.x, maxInput.y, localSize, localOpacity, 0);
            this.context.restore();
        }
        this.bezierLine = null;
        if (this.historyEntry) {
            this.historyEntry.actions.push({
                action: "endLine",
                params: [
                    x,
                    y
                ]
            });
            this.history.push(this.historyEntry);
            this.historyEntry = undefined;
        }
        this.hasDrawnDot = false;
        this.inputArr = [];
    }
    drawLineSegment(x1, y1, x2, y2) {
        this.lastInput.x = x2;
        this.lastInput.y = y2;
        this.lastInput.pressure = 1;
        if (this.inputIsDrawing || x1 === undefined) return;
        const angle = (0, _bb.BB).pointsToAngleDeg({
            x: x1,
            y: y1
        }, {
            x: x2,
            y: y2
        });
        const mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        const eX = (x2 - x1) / mouseDist;
        const eY = (y2 - y1) / mouseDist;
        let loopDist;
        const bdist = this.settingSize * this.settingSpacing;
        this.lineToolLastDot = this.settingSize * this.settingSpacing;
        this.context.save();
        for(loopDist = this.lineToolLastDot; loopDist <= mouseDist; loopDist += bdist)this.drawDot(x1 + eX * loopDist, y1 + eY * loopDist, this.settingSize, this.settingOpacity, angle);
        this.context.restore();
        const historyEntry = {
            tool: [
                "brush",
                "PenBrush"
            ],
            actions: [
                {
                    action: "opacityPressure",
                    params: [
                        this.settingHasOpacityPressure
                    ]
                },
                {
                    action: "sizePressure",
                    params: [
                        this.settingHasSizePressure
                    ]
                },
                {
                    action: "setSize",
                    params: [
                        this.settingSize
                    ]
                },
                {
                    action: "setSpacing",
                    params: [
                        this.settingSpacing
                    ]
                },
                {
                    action: "setOpacity",
                    params: [
                        this.settingOpacity
                    ]
                },
                {
                    action: "setColor",
                    params: [
                        this.settingColor
                    ]
                },
                {
                    action: "setAlpha",
                    params: [
                        this.settingAlphaId
                    ]
                },
                {
                    action: "setLockAlpha",
                    params: [
                        this.settingLockLayerAlpha
                    ]
                },
                {
                    action: "drawLineSegment",
                    params: [
                        x1,
                        y1,
                        x2,
                        y2
                    ]
                }
            ]
        };
        this.history.push(historyEntry);
    }
    //IS
    isDrawing() {
        return this.inputIsDrawing;
    }
    //SET
    setAlpha(a) {
        if (this.settingAlphaId === a) return;
        this.settingAlphaId = a;
        this.updateAlphaCanvas();
    }
    setColor(c) {
        if (this.settingColor === c) return;
        this.settingColor = {
            r: c.r,
            g: c.g,
            b: c.b
        };
        this.settingColorStr = "rgb(" + this.settingColor.r + "," + this.settingColor.g + "," + this.settingColor.b + ")";
        this.updateAlphaCanvas();
    }
    setContext(c) {
        this.context = c;
    }
    setHistory(l) {
        this.history = l;
    }
    setSize(s) {
        this.settingSize = s;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setSpacing(s) {
        this.settingSpacing = s;
    }
    sizePressure(b) {
        this.settingHasSizePressure = b;
    }
    opacityPressure(b) {
        this.settingHasOpacityPressure = b;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = b;
    }
    //GET
    getSpacing() {
        return this.settingSpacing;
    }
    getSize() {
        return this.settingSize;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
}

},{"../../bb/bb":"dcQKo","./brushes-common":"8A7GM","../kl":"8nmWp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8A7GM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "alphaImArr", ()=>alphaImArr);
var _brushAlphas = require("./alphas/brush-alphas");
const alphaImArr = []; //used by default brush
alphaImArr[1] = (0, _brushAlphas.genBrushAlpha01)(128);
alphaImArr[2] = (0, _brushAlphas.genBrushAlpha02)(128);

},{"./alphas/brush-alphas":"6o2bW","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6o2bW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// chalk
parcelHelpers.export(exports, "genBrushAlpha01", ()=>genBrushAlpha01);
// calligraphy
parcelHelpers.export(exports, "genBrushAlpha02", ()=>genBrushAlpha02);
var _bb = require("../../../bb/bb");
var _perlin = require("../../../bb/math/perlin");
function genBrushAlpha01(w) {
    const scaleFac = w / 500;
    const h = w;
    const canvas = (0, _bb.BB).canvas(w, h);
    const ctx = (0, _bb.BB).ctx(canvas);
    const imData = ctx.createImageData(w, h);
    for(let x = 0; x < w; x++)for(let y = 0; y < h; y++){
        const i = (y * w + x) * 4;
        // base noise
        const sFac2 = scaleFac + (0, _perlin.noise).simplex2(x / 50 / scaleFac, y / 50 / scaleFac) * 0.04;
        let noisePattern = 100 + ((0, _perlin.noise).simplex2(x / 50 / sFac2, y / 50 / sFac2) + 1) / 2 * 100;
        noisePattern -= ((0, _perlin.noise).simplex2(x / 10 / scaleFac, y / 10 / scaleFac) + 1) / 2 * 100;
        // fade out in circular shape
        const centerDist = (0, _bb.BB).dist(w / 2, h / 2, x, y);
        const falloff = (0, _bb.BB).clamp(1 - ((centerDist - w / 2.5) / (w / 14) + (0, _perlin.noise).simplex2(x / 22 / sFac2, y / 22 / sFac2)), 0, 1);
        noisePattern = noisePattern * falloff;
        // make the middle darker
        const falloff2 = (0, _bb.BB).clamp(1 - centerDist / w, 0, 1) * 2;
        noisePattern = noisePattern * falloff2;
        imData.data[i] = 0;
        imData.data[i + 1] = 0;
        imData.data[i + 2] = 0;
        imData.data[i + 3] = (0, _bb.BB).clamp(noisePattern, 0, 255);
    }
    ctx.putImageData(imData, 0, 0);
    return canvas;
}
// https://www.shadertoy.com/view/3tdSDj
function udSegment(p, a, b) {
    const ba = (0, _bb.BB).Vec2.sub(b, a);
    const pa = (0, _bb.BB).Vec2.sub(p, a);
    const h = (0, _bb.BB).clamp((0, _bb.BB).Vec2.dot(pa, ba) / (0, _bb.BB).Vec2.dot(ba, ba), 0.0, 1.0);
    return (0, _bb.BB).Vec2.len((0, _bb.BB).Vec2.sub(pa, (0, _bb.BB).Vec2.mul(ba, h)));
}
function genBrushAlpha02(w) {
    const pDist = 1 / 4;
    let centerSize = 2 / 3;
    let transitionSize = 1 / 3;
    centerSize *= pDist;
    transitionSize *= pDist;
    const p1 = {
        x: pDist * w,
        y: w - w * pDist
    };
    const p2 = {
        x: w - w * pDist,
        y: pDist * w
    };
    const h = w;
    const canvas = (0, _bb.BB).canvas(w, h);
    const ctx = (0, _bb.BB).ctx(canvas);
    const imData = ctx.createImageData(w, h);
    for(let x = 0; x < w; x++)for(let y = 0; y < h; y++){
        const i = (y * w + x) * 4;
        let col = udSegment({
            x: x,
            y: y
        }, p1, p2);
        col = (0, _bb.BB).clamp(255 - (col - w * centerSize) / (w * transitionSize) * 255, 0, 255);
        imData.data[i] = 0;
        imData.data[i + 1] = 0;
        imData.data[i + 2] = 0;
        imData.data[i + 3] = col;
    }
    ctx.putImageData(imData, 0, 0);
    return canvas;
}

},{"../../../bb/bb":"dcQKo","../../../bb/math/perlin":"9Bu1q","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9Bu1q":[function(require,module,exports) {
/*
 * A speed-improved perlin and simplex noise algorithms for 2D.
 *
 * Based on example code by Stefan Gustavson (stegu@itn.liu.se).
 * Optimisations by Peter Eastman (peastman@drizzle.stanford.edu).
 * Better rank ordering method by Stefan Gustavson in 2012.
 * Converted to Javascript by Joseph Gentle.
 *
 * Version 2012-03-09
 *
 * This code was placed in the public domain by its original author,
 * Stefan Gustavson. You may use it as you see fit, but
 * attribution is appreciated.
 *
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noise", ()=>noise);
const myModule = {};
class Grad {
    constructor(x, y, z){
        this.x = x;
        this.y = y;
        this.z = z;
    }
    dot2(x, y) {
        return this.x * x + this.y * y;
    }
}
/*
Grad.prototype.dot3 = function(x, y, z) {
    return this.x*x + this.y*y + this.z*z;
};*/ const grad3 = [
    new Grad(1, 1, 0),
    new Grad(-1, 1, 0),
    new Grad(1, -1, 0),
    new Grad(-1, -1, 0),
    new Grad(1, 0, 1),
    new Grad(-1, 0, 1),
    new Grad(1, 0, -1),
    new Grad(-1, 0, -1),
    new Grad(0, 1, 1),
    new Grad(0, -1, 1),
    new Grad(0, 1, -1),
    new Grad(0, -1, -1)
];
const p = [
    151,
    160,
    137,
    91,
    90,
    15,
    131,
    13,
    201,
    95,
    96,
    53,
    194,
    233,
    7,
    225,
    140,
    36,
    103,
    30,
    69,
    142,
    8,
    99,
    37,
    240,
    21,
    10,
    23,
    190,
    6,
    148,
    247,
    120,
    234,
    75,
    0,
    26,
    197,
    62,
    94,
    252,
    219,
    203,
    117,
    35,
    11,
    32,
    57,
    177,
    33,
    88,
    237,
    149,
    56,
    87,
    174,
    20,
    125,
    136,
    171,
    168,
    68,
    175,
    74,
    165,
    71,
    134,
    139,
    48,
    27,
    166,
    77,
    146,
    158,
    231,
    83,
    111,
    229,
    122,
    60,
    211,
    133,
    230,
    220,
    105,
    92,
    41,
    55,
    46,
    245,
    40,
    244,
    102,
    143,
    54,
    65,
    25,
    63,
    161,
    1,
    216,
    80,
    73,
    209,
    76,
    132,
    187,
    208,
    89,
    18,
    169,
    200,
    196,
    135,
    130,
    116,
    188,
    159,
    86,
    164,
    100,
    109,
    198,
    173,
    186,
    3,
    64,
    52,
    217,
    226,
    250,
    124,
    123,
    5,
    202,
    38,
    147,
    118,
    126,
    255,
    82,
    85,
    212,
    207,
    206,
    59,
    227,
    47,
    16,
    58,
    17,
    182,
    189,
    28,
    42,
    223,
    183,
    170,
    213,
    119,
    248,
    152,
    2,
    44,
    154,
    163,
    70,
    221,
    153,
    101,
    155,
    167,
    43,
    172,
    9,
    129,
    22,
    39,
    253,
    19,
    98,
    108,
    110,
    79,
    113,
    224,
    232,
    178,
    185,
    112,
    104,
    218,
    246,
    97,
    228,
    251,
    34,
    242,
    193,
    238,
    210,
    144,
    12,
    191,
    179,
    162,
    241,
    81,
    51,
    145,
    235,
    249,
    14,
    239,
    107,
    49,
    192,
    214,
    31,
    181,
    199,
    106,
    157,
    184,
    84,
    204,
    176,
    115,
    121,
    50,
    45,
    127,
    4,
    150,
    254,
    138,
    236,
    205,
    93,
    222,
    114,
    67,
    29,
    24,
    72,
    243,
    141,
    128,
    195,
    78,
    66,
    215,
    61,
    156,
    180
];
// To remove the need for index wrapping, double the permutation table length
const perm = new Array(512);
const gradP = new Array(512);
// This isn't a very good seeding function, but it works ok. It supports 2^16
// different seed values. Write something better if you need more seeds.
myModule.seed = function(seed) {
    if (seed > 0 && seed < 1) // Scale the seed out
    seed *= 65536;
    seed = Math.floor(seed);
    if (seed < 256) seed |= seed << 8;
    for(let i = 0; i < 256; i++){
        let v;
        if (i & 1) v = p[i] ^ seed & 255;
        else v = p[i] ^ seed >> 8 & 255;
        perm[i] = perm[i + 256] = v;
        gradP[i] = gradP[i + 256] = grad3[v % 12];
    }
};
myModule.seed(0);
/*
for (let i=0; i<256; i++) {
  perm[i] = perm[i + 256] = p[i];
  gradP[i] = gradP[i + 256] = grad3[perm[i] % 12];
}*/ // Skewing and unskewing factors for 2, 3, and 4 dimensions
const F2 = 0.5 * (Math.sqrt(3) - 1);
const G2 = (3 - Math.sqrt(3)) / 6;
/*let F3 = 1/3;
let G3 = 1/6;*/ // 2D simplex noise
myModule.simplex2 = function(xin, yin) {
    let n0, n1, n2; // Noise contributions from the three corners
    // Skew the input space to determine which simplex cell we're in
    const s = (xin + yin) * F2; // Hairy factor for 2D
    let i = Math.floor(xin + s);
    let j = Math.floor(yin + s);
    const t = (i + j) * G2;
    const x0 = xin - i + t; // The x,y distances from the cell origin, unskewed.
    const y0 = yin - j + t;
    // For the 2D case, the simplex shape is an equilateral triangle.
    // Determine which simplex we are in.
    let i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
    if (x0 > y0) {
        i1 = 1;
        j1 = 0;
    } else {
        i1 = 0;
        j1 = 1;
    }
    // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
    // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
    // c = (3-sqrt(3))/6
    const x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
    const y1 = y0 - j1 + G2;
    const x2 = x0 - 1 + 2 * G2; // Offsets for last corner in (x,y) unskewed coords
    const y2 = y0 - 1 + 2 * G2;
    // Work out the hashed gradient indices of the three simplex corners
    i &= 255;
    j &= 255;
    const gi0 = gradP[i + perm[j]];
    const gi1 = gradP[i + i1 + perm[j + j1]];
    const gi2 = gradP[i + 1 + perm[j + 1]];
    // Calculate the contribution from the three corners
    let t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 < 0) n0 = 0;
    else {
        t0 *= t0;
        n0 = t0 * t0 * gi0.dot2(x0, y0); // (x,y) of grad3 used for 2D gradient
    }
    let t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 < 0) n1 = 0;
    else {
        t1 *= t1;
        n1 = t1 * t1 * gi1.dot2(x1, y1);
    }
    let t2 = 0.5 - x2 * x2 - y2 * y2;
    if (t2 < 0) n2 = 0;
    else {
        t2 *= t2;
        n2 = t2 * t2 * gi2.dot2(x2, y2);
    }
    // Add contributions from each corner to get the final noise value.
    // The result is scaled to return values in the interval [-1,1].
    return 70 * (n0 + n1 + n2);
};
const noise = myModule;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1OcHF":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BlendBrush", ()=>BlendBrush);
var _bb = require("../../bb/bb");
var _math = require("../../bb/math/math");
const cellSize = 256;
class BlendBrush {
    updateRedrawBounds(bounds) {
        this.redrawBounds = (0, _bb.BB).updateBounds(this.redrawBounds, bounds);
    }
    getCellsWidth() {
        return Math.ceil(this.context.canvas.width / cellSize);
    }
    /**
     * draw changed cells (changed by brushstroke) onto context
     * @private
     */ drawChangedCells() {
        if (!this.redrawBounds) return;
        const cells = this.cells.map(()=>undefined);
        const touchedCells = this.getTouchedCells(this.redrawBounds);
        touchedCells.forEach((isTouched, index)=>{
            if (isTouched) cells[index] = this.cells[index];
        });
        this.drawCells(cells);
        this.redrawBounds = undefined;
    }
    getTouchedCells(bounds) {
        const touchedCells = this.cells.map(()=>false);
        const cellsW = this.getCellsWidth();
        bounds = {
            x1: Math.floor(bounds.x1 / cellSize),
            y1: Math.floor(bounds.y1 / cellSize),
            x2: Math.floor(bounds.x2 / cellSize),
            y2: Math.floor(bounds.y2 / cellSize)
        };
        for(let i = bounds.x1; i <= bounds.x2; i++)for(let e = bounds.y1; e <= bounds.y2; e++)touchedCells[e * cellsW + i] = true;
        return touchedCells;
    }
    /**
     * Slice up bounds according to cells
     * @param bounds
     * @private
     */ sliceBounds(bounds) {
        const cellsW = this.getCellsWidth();
        const result = [];
        const touchedCells = this.getTouchedCells(bounds);
        touchedCells.forEach((cell, i)=>{
            if (!cell) return;
            const cellOffsetX = i % cellsW * cellSize;
            const cellOffsetY = Math.floor(i / cellsW) * cellSize;
            const cellWidth = this.cells[i].width;
            const cellHeight = this.cells[i].height;
            const inCellBounds = {
                x1: Math.max(0, bounds.x1 - cellOffsetX),
                y1: Math.max(0, bounds.y1 - cellOffsetY),
                x2: Math.min(cellWidth - 1, bounds.x2 - cellOffsetX),
                y2: Math.min(cellHeight - 1, bounds.y2 - cellOffsetY)
            };
            if (inCellBounds.x1 > inCellBounds.x2 || inCellBounds.y1 > inCellBounds.y2) return;
            result.push({
                index: i,
                bounds: inCellBounds
            });
        });
        return result;
    }
    /**
     * update copyImageData. copy over new regions if needed
     */ copyFromCanvas(bounds) {
        if (!bounds) return;
        const touchedCells = this.getTouchedCells(bounds);
        const cellsW = this.getCellsWidth();
        touchedCells.forEach((item, i)=>{
            if (!item || this.cells[i]) // not touched, or already copied
            return;
            const x = i % cellsW;
            const y = Math.floor(i / cellsW);
            const w = (Math.min(x * cellSize + cellSize, this.context.canvas.width) - 1) % cellSize + 1;
            const h = (Math.min(y * cellSize + cellSize, this.context.canvas.height) - 1) % cellSize + 1;
            // temp canvas to prevent main canvas from getting slowed down in chrome
            const tmpCanvas = (0, _bb.BB).canvas(w, h);
            const tmpCtx = (0, _bb.BB).ctx(tmpCanvas);
            tmpCtx.drawImage(this.context.canvas, -x * cellSize, -y * cellSize);
            this.cells[i] = tmpCtx.getImageData(0, 0, w, h);
        });
    }
    getAverage(x, y, size) {
        size = Math.max(0.5, size * 0.75);
        const x1 = Math.max(0, Math.floor(x - size));
        const y1 = Math.max(0, Math.floor(y - size));
        const x2 = Math.min(this.context.canvas.width - 1, Math.ceil(x + size));
        const y2 = Math.min(this.context.canvas.height - 1, Math.ceil(y + size));
        if (x1 > x2 || y1 > y2) return {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        };
        let ar = 0, ag = 0, ab = 0, aa = 0, alpha;
        const slicedBounds = this.sliceBounds({
            x1,
            y1,
            x2,
            y2
        });
        slicedBounds.forEach((slice)=>{
            const width = this.cells[slice.index].width;
            const data = this.cells[slice.index].data;
            const bounds = slice.bounds;
            for(let i = bounds.y1; i <= bounds.y2; i += 4)for(let e = bounds.x1, e2 = i * width * 4 + bounds.x1 * 4; e <= bounds.x2; e += 4, e2 += 16){
                alpha = data[e2 + 3];
                ar += data[e2] * alpha;
                ag += data[e2 + 1] * alpha;
                ab += data[e2 + 2] * alpha;
                aa += alpha;
            }
        });
        if (aa !== 0) {
            ar /= aa;
            ag /= aa;
            ab /= aa;
            aa = Math.min(1, aa);
        }
        return {
            r: ar,
            g: ag,
            b: ab,
            a: aa
        };
    }
    prepDot(x, y, size) {
        size = Math.max(0.5, size);
        const x1 = Math.max(0, Math.floor(x - size));
        const y1 = Math.max(0, Math.floor(y - size));
        const x2 = Math.min(this.context.canvas.width - 1, Math.ceil(x + size));
        const y2 = Math.min(this.context.canvas.height - 1, Math.ceil(y + size));
        if (x1 > x2 || y1 > y2) return undefined;
        return {
            x1,
            y1,
            x2,
            y2
        };
    }
    drawDot(params) {
        // array with random numbers. faster than Math.random()
        let randI = 0;
        const randLen = params.size > 30 ? 1024 : 512; // lower lengths lead to noticeable patterns
        const randArr = [];
        for(let i = 0; i < randLen; i++)randArr[i] = (Math.random() - 0.5) / 1.001 + 0.5;
        // thin lines take more than just 1 sample
        const sampleArr = [
            8,
            4,
            4,
            4,
            2,
            2,
            2,
            2,
            2,
            2
        ]; // <0.5, 0.5, 1, 1.5, etc.
        const samples = sampleArr[Math.floor(params.size * 2)];
        const samplesSquared = samples ? samples * samples : 0;
        const sampleOffsets = [];
        if (samples) {
            let i = 0;
            for(let n = 0; n < samples; n++)for(let m = 0; m < samples; m++, i += 2){
                sampleOffsets[i] = (n + 1) / samples; // x offset
                sampleOffsets[i + 1] = (m + 1) / samples; // y offset
            }
        }
        const sharpness = Math.pow(params.opacity, 2) * 0.8;
        // to optimize calculations
        const invSharpness = 1 - sharpness;
        const sharpnessSubtrahend = sharpness / invSharpness;
        const sizeSquared = params.size * params.size;
        const distDivisor = sizeSquared * invSharpness / params.opacity;
        const alphaMinuend = (1 + sharpnessSubtrahend) * params.opacity;
        const slicedBounds = this.sliceBounds({
            x1: params.x1,
            y1: params.y1,
            x2: params.x2,
            y2: params.y2
        });
        const cellsW = this.getCellsWidth();
        slicedBounds.forEach((slice)=>{
            const cellOffsetX = slice.index % cellsW * cellSize;
            const cellOffsetY = Math.floor(slice.index / cellsW) * cellSize;
            const cellWidth = this.cells[slice.index].width;
            const data = this.cells[slice.index].data;
            // i - y index within cell
            // e - x index within cell
            // e2 - index in image data
            // ri - y index within image relative to dot-center
            // re - x index within image relative to dot-center
            for(let i = slice.bounds.y1, ri = i + cellOffsetY - params.y; i <= slice.bounds.y2; i++, ri++)for(let e = slice.bounds.x1, e2 = i * cellWidth * 4 + slice.bounds.x1 * 4, re = e + cellOffsetX - params.x; e <= slice.bounds.x2; e++, e2 += 4, re++){
                // O = over -> brush-dot
                // U = under -> image
                let alphaO = 0;
                if (samplesSquared) {
                    for(let f = 0; f < sampleOffsets.length; f += 2){
                        const dist = (0, _bb.BB).lenSquared(re + sampleOffsets[f], ri + sampleOffsets[f + 1]);
                        if (dist >= sizeSquared) continue;
                        alphaO += (0, _math.clamp)(alphaMinuend - dist / distDivisor, 0, params.opacity);
                    }
                    if (!alphaO) continue;
                    alphaO /= samplesSquared;
                } else {
                    // technically needs + 0.5 offset, but not noticeable with large brush
                    const dist = Math.pow(re, 2) + Math.pow(ri, 2);
                    if (dist >= sizeSquared) continue;
                    alphaO = (0, _math.clamp)(alphaMinuend - dist / distDivisor, 0, params.opacity);
                }
                const invAlphaO = 1 - alphaO;
                const alphaU = data[e2 + 3] / 255;
                if (this.settingLockLayerAlpha) {
                    const underR = params.r * alphaO + data[e2] * invAlphaO;
                    const underG = params.g * alphaO + data[e2 + 1] * invAlphaO;
                    const underB = params.b * alphaO + data[e2 + 2] * invAlphaO;
                    if (alphaU) {
                        data[e2] = Math.floor(underR + randArr[randI]);
                        data[e2 + 1] = Math.floor(underG + randArr[randI]);
                        data[e2 + 2] = Math.floor(underB + randArr[randI]);
                    }
                } else {
                    const underR = params.r * alphaO + data[e2] * alphaU * invAlphaO;
                    const underG = params.g * alphaO + data[e2 + 1] * alphaU * invAlphaO;
                    const underB = params.b * alphaO + data[e2 + 2] * alphaU * invAlphaO;
                    const newAlpha = 1 - invAlphaO * (1 - alphaU);
                    data[e2 + 3] = Math.floor(Math.min(255, newAlpha * 255) + 0.5);
                    if (newAlpha) {
                        data[e2] = Math.floor(underR / newAlpha + randArr[randI]);
                        data[e2 + 1] = Math.floor(underG / newAlpha + randArr[randI]);
                        data[e2 + 2] = Math.floor(underB / newAlpha + randArr[randI]);
                    }
                }
                randI = (randI + 1) % randLen;
            }
        });
    }
    calcSpacing(size) {
        return (0, _bb.BB).mix(size * 2 / 2, size * 2 / 9, (0, _math.clamp)((size - 2.7) / 9.3, 0, 1));
    }
    continueLine(x, y, p, isCoalesced) {
        this.drawBuffer = [];
        let localPressure;
        let localOpacity;
        let localSize = this.settingSizePressure ? Math.max(1, p * this.size) : Math.max(1, this.size);
        const bDist = this.calcSpacing(localSize);
        const avgX = x === undefined ? this.lastInput.x : x;
        const avgY = y === undefined ? this.lastInput.y : y;
        let localColNew;
        if (this.blending === 0) {
            this.mixCol.r = this.color.r;
            this.mixCol.g = this.color.g;
            this.mixCol.b = this.color.b;
        } else {
            let average;
            if (isCoalesced) average = {
                r: this.localColOld.r,
                g: this.localColOld.g,
                b: this.localColOld.b,
                a: 0
            };
            else {
                const avgParams = [
                    avgX,
                    avgY,
                    this.settingSizePressure ? Math.max(0.5, p * this.size) : Math.max(0.5, this.size)
                ];
                const bounds = this.prepDot(avgParams[0], avgParams[1], avgParams[2]);
                if (bounds) this.copyFromCanvas(bounds);
                average = this.getAverage(avgParams[0], avgParams[1], avgParams[2]);
            }
            localColNew = {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            };
            if (average.a > 0 && this.blendCol.a === 0) {
                this.blendCol.r = average.r;
                this.blendCol.g = average.g;
                this.blendCol.b = average.b;
                this.blendCol.a = average.a;
                localColNew.r = this.blendCol.r;
                localColNew.g = this.blendCol.g;
                localColNew.b = this.blendCol.b;
                localColNew.a = this.blendCol.a;
            } else {
                if (average.a === 0) {
                    average.r = this.color.r;
                    average.g = this.color.g;
                    average.b = this.color.b;
                    average.a = 1 - this.blending;
                }
                this.blendCol.r = (0, _bb.BB).mix(this.blendCol.r, (0, _bb.BB).mix(this.blendCol.r, average.r, this.blendMix), average.a);
                this.blendCol.g = (0, _bb.BB).mix(this.blendCol.g, (0, _bb.BB).mix(this.blendCol.g, average.g, this.blendMix), average.a);
                this.blendCol.b = (0, _bb.BB).mix(this.blendCol.b, (0, _bb.BB).mix(this.blendCol.b, average.b, this.blendMix), average.a);
                this.blendCol.a = Math.min(1, this.blendCol.a + average.a);
                localColNew.r = this.blendCol.r;
                localColNew.g = this.blendCol.g;
                localColNew.b = this.blendCol.b;
                localColNew.a = this.blendCol.a;
            }
        }
        const bezierCallback = (val)=>{
            if (this.blending >= 1 && this.blendCol.a <= 0) return;
            const factor = val.t;
            localPressure = this.lastInput2.pressure * (1 - factor) + p * factor;
            localOpacity = this.settingOpacityPressure ? this.opacity * localPressure * localPressure : this.opacity;
            localSize = this.settingSizePressure ? Math.max(0.1, localPressure * this.size) : Math.max(0.1, this.size);
            if (this.blending != 0) {
                this.mixCol.r = (0, _bb.BB).mix(this.localColOld.r, localColNew.r, factor);
                this.mixCol.g = (0, _bb.BB).mix(this.localColOld.g, localColNew.g, factor);
                this.mixCol.b = (0, _bb.BB).mix(this.localColOld.b, localColNew.b, factor);
            }
            if (this.blending === 1 && this.localColOld.a === 0) {
                this.mixCol.r = localColNew.r;
                this.mixCol.g = localColNew.g;
                this.mixCol.b = localColNew.b;
            }
            const bounds = this.prepDot(val.x, val.y, localSize);
            if (bounds) {
                this.updateRedrawBounds(bounds);
                this.drawBuffer.push({
                    x: val.x,
                    y: val.y,
                    size: localSize,
                    opacity: localOpacity,
                    x1: bounds.x1,
                    y1: bounds.y1,
                    x2: bounds.x2,
                    y2: bounds.y2,
                    r: (0, _bb.BB).mix(this.color.r, this.mixCol.r, this.blending),
                    g: (0, _bb.BB).mix(this.color.g, this.mixCol.g, this.blending),
                    b: (0, _bb.BB).mix(this.color.b, this.mixCol.b, this.blending)
                });
            }
        };
        if (x === undefined || y === undefined) this.bezierLine.addFinal(bDist, bezierCallback);
        else this.bezierLine.add(x, y, bDist, bezierCallback);
        this.copyFromCanvas(this.redrawBounds);
        this.drawBuffer.forEach((item)=>{
            this.drawDot(item);
        });
        this.drawBuffer = [];
        this.localColOld = localColNew;
    }
    // --- public ----
    constructor(){
        this.isTesting = false // testing mode - context only gets updated when line is finished
        ;
        this.context = {};
        this.color = {};
        this.size = 29 // radius - 0.5 - 99999
        ;
        this.opacity = 0.6 // 0-1
        ;
        this.blending = 0.65 // 0-1
        ;
        this.settingLockLayerAlpha = false;
        this.settingSizePressure = true;
        this.settingOpacityPressure = false;
        this.blendCol = {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        } // todo docs
        ;
        this.blendMix = 0.45 // todo docs
        ;
        this.mixCol = {
            r: 0,
            g: 0,
            b: 0
        } // todo docs
        ;
        this.localColOld = {} // todo docs
        ;
        this.isDrawing = false;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        } // todo docs
        ;
        this.lastInput2 = {
            x: 0,
            y: 0,
            pressure: 0
        } // todo docs
        ;
        this.cells = [];
        this.drawBuffer = [];
    }
    setHistory(h) {
        this.history = h;
    }
    getSize() {
        return this.size;
    }
    setSize(s) {
        this.size = s;
    }
    getOpacity() {
        return this.opacity;
    }
    setOpacity(o) {
        this.opacity = o;
    }
    getBlending() {
        return this.blending;
    }
    setBlending(b) {
        this.blending = b;
    }
    setColor(c) {
        this.color = (0, _bb.BB).copyObj(c);
    }
    setContext(c) {
        this.context = c;
    }
    setSizePressure(b) {
        this.settingSizePressure = b;
    }
    setOpacityPressure(b) {
        this.settingOpacityPressure = b;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = b;
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    setIsTesting(b) {
        this.isTesting = b;
    }
    startLine(x, y, p) {
        this.historyEntry = {
            tool: [
                "brush",
                "BlendBrush"
            ],
            actions: []
        };
        const totalCells = Math.ceil(this.context.canvas.width / cellSize) * Math.ceil(this.context.canvas.height / cellSize);
        this.cells = "0".repeat(totalCells).split("").map(()=>undefined);
        this.isDrawing = true;
        p = Math.max(0, Math.min(1, p));
        const localOpacity = this.settingOpacityPressure ? this.opacity * p * p : this.opacity;
        const localSize = this.settingSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size);
        if (this.blending === 0) {
            this.mixCol.r = this.color.r;
            this.mixCol.g = this.color.g;
            this.mixCol.b = this.color.b;
        } else {
            this.copyFromCanvas(this.prepDot(x, y, localSize));
            const average = this.getAverage(x, y, this.settingSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size));
            if (average.a === 0) this.blendCol = {
                r: this.color.r,
                g: this.color.g,
                b: this.color.b,
                a: 1 - this.blending
            };
            else this.blendCol = {
                r: average.r,
                g: average.g,
                b: average.b,
                a: average.a
            };
            this.mixCol.r = this.blendCol.r;
            this.mixCol.g = this.blendCol.g;
            this.mixCol.b = this.blendCol.b;
        }
        this.localColOld = {
            r: this.mixCol.r,
            g: this.mixCol.g,
            b: this.mixCol.b,
            a: this.blendCol.a
        };
        this.redrawBounds = undefined;
        this.drawBuffer = [];
        if (this.blending < 1 || this.blendCol.a > 0) {
            const bounds = this.prepDot(x, y, localSize);
            if (bounds) {
                this.updateRedrawBounds(bounds);
                this.drawBuffer.push({
                    x: x,
                    y: y,
                    size: localSize,
                    opacity: localOpacity,
                    x1: bounds.x1,
                    y1: bounds.y1,
                    x2: bounds.x2,
                    y2: bounds.y2,
                    r: (0, _bb.BB).mix(this.color.r, this.mixCol.r, this.blending),
                    g: (0, _bb.BB).mix(this.color.g, this.mixCol.g, this.blending),
                    b: (0, _bb.BB).mix(this.color.b, this.mixCol.b, this.blending)
                });
            }
        }
        this.copyFromCanvas(this.redrawBounds);
        this.drawBuffer.forEach((item)=>{
            this.drawDot(item);
        });
        this.drawBuffer = [];
        this.bezierLine = new (0, _bb.BB).BezierLine();
        this.bezierLine.add(x, y, 0, function() {});
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        if (!this.isTesting) this.drawChangedCells();
    }
    goLine(x, y, p, isCoalesced) {
        if (!this.isDrawing) return;
        this.continueLine(x, y, this.lastInput.pressure, isCoalesced);
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        if (!this.isTesting) this.drawChangedCells();
    }
    endLine() {
        if (this.bezierLine) this.continueLine(undefined, undefined, this.lastInput.pressure, false);
        this.isDrawing = false;
        this.bezierLine = undefined;
        this.drawChangedCells();
        if (this.historyEntry && this.history && this.cells.find((item)=>!!item)) {
            this.historyEntry.actions.push({
                action: "drawCells",
                params: [
                    this.cells
                ]
            });
            this.history.push(this.historyEntry);
            this.historyEntry = undefined;
        }
        this.cells = [];
    }
    /**
     * draw cells onto context
     * @param cells
     */ drawCells(cells) {
        const cellsW = this.getCellsWidth();
        cells.forEach((imageData, index)=>{
            if (!imageData) return;
            const cellOffsetX = index % cellsW * cellSize;
            const cellOffsetY = Math.floor(index / cellsW) * cellSize;
            this.context.putImageData(imageData, cellOffsetX, cellOffsetY);
        });
    }
    drawLineSegment(x1, y1, x2, y2) {
        this.lastInput.x = x2;
        this.lastInput.y = y2;
        if (this.isDrawing || x1 === undefined) return;
        const totalCells = Math.ceil(this.context.canvas.width / cellSize) * Math.ceil(this.context.canvas.height / cellSize);
        this.cells = "0".repeat(totalCells).split("").map(()=>undefined);
        this.redrawBounds = undefined;
        this.drawBuffer = [];
        this.copyFromCanvas(this.prepDot(x1, y1, Math.max(0.1, this.size)));
        const average = this.getAverage(x1, y1, Math.max(0.1, this.size));
        if (average.a === 0) this.blendCol = {
            r: this.color.r,
            g: this.color.g,
            b: this.color.b,
            a: 1 - this.blending
        };
        else this.blendCol = {
            r: average.r,
            g: average.g,
            b: average.b,
            a: average.a
        };
        this.mixCol.r = this.color.r * (1 - this.blendCol.a) + (this.blending * this.blendCol.r + this.color.r * (1 - this.blending)) * this.blendCol.a;
        this.mixCol.g = this.color.g * (1 - this.blendCol.a) + (this.blending * this.blendCol.g + this.color.g * (1 - this.blending)) * this.blendCol.a;
        this.mixCol.b = this.color.b * (1 - this.blendCol.a) + (this.blending * this.blendCol.b + this.color.b * (1 - this.blending)) * this.blendCol.a;
        const p = 1;
        const localOpacity = this.settingOpacityPressure ? this.opacity * p * p : this.opacity;
        const localSize = this.settingSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size);
        const mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        const eX = (x2 - x1) / mouseDist;
        const eY = (y2 - y1) / mouseDist;
        const bDist = this.calcSpacing(localSize);
        for(let loopDist = 0; loopDist <= mouseDist; loopDist += bDist){
            const bounds = this.prepDot(x1 + eX * loopDist, y1 + eY * loopDist, localSize);
            if (bounds) {
                this.copyFromCanvas(bounds);
                this.drawBuffer.push({
                    x: x1 + eX * loopDist,
                    y: y1 + eY * loopDist,
                    size: localSize,
                    opacity: localOpacity,
                    x1: bounds.x1,
                    y1: bounds.y1,
                    x2: bounds.x2,
                    y2: bounds.y2,
                    r: (0, _bb.BB).mix(this.color.r, this.mixCol.r, this.blending),
                    g: (0, _bb.BB).mix(this.color.g, this.mixCol.g, this.blending),
                    b: (0, _bb.BB).mix(this.color.b, this.mixCol.b, this.blending)
                });
            }
        }
        this.drawBuffer.forEach((item)=>{
            this.drawDot(item);
        });
        this.drawBuffer = [];
        if (this.history && this.cells.find((item)=>!!item)) {
            this.drawCells(this.cells);
            this.historyEntry = {
                tool: [
                    "brush",
                    "BlendBrush"
                ],
                actions: [
                    {
                        action: "drawCells",
                        params: [
                            this.cells
                        ]
                    }
                ]
            };
            this.history.push(this.historyEntry);
            this.historyEntry = undefined;
        }
        this.cells = [];
    }
}

},{"../../bb/bb":"dcQKo","../../bb/math/math":"7w6MZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"goQ9y":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SketchyBrush", ()=>SketchyBrush);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
const sampleCanvas = (0, _bb.BB).canvas(32, 32);
const sampleCtx = (0, _bb.BB).ctx(sampleCanvas);
class SketchyBrush {
    rand() {
        this.sketchySeed++;
        return Math.sin(6324634.2345 * Math.cos(this.sketchySeed * 5342.3423)) * 0.5 + 0.5;
    }
    // ---- public ----
    constructor(){
        this.context = {};
        this.settingColor = {};
        this.settingSize = 1;
        this.settingOpacity = 0.2;
        this.settingBlending = 0.5;
        this.settingScale = 1;
        this.lastX = 0;
        this.lastY = 0;
        this.inputIsDrawing = false;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.history = new (0, _kl.KL).DecoyKlHistory();
        this.sketchySeed = 0;
        this.points = [] // x y
        ;
        this.count = 0;
        this.mixMode = [
            (c1)=>{
                return c1;
            },
            (c1, c2)=>{
                const result = new (0, _bb.BB).RGB(c1.r, c1.g, c1.b);
                result.r *= c2.r / 255;
                result.g *= c2.g / 255;
                result.b *= c2.b / 255;
                return result;
            }
        ];
    }
    // ---- interface ----
    setHistory(l) {
        this.history = l;
    }
    setSeed(s) {
        this.sketchySeed = parseInt("" + s);
    }
    getSeed() {
        return parseInt("" + this.sketchySeed);
    }
    getSize() {
        return this.settingSize / 2;
    }
    setColor(c) {
        this.settingColor = c;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    getBlending() {
        return this.settingBlending;
    }
    setBlending(b) {
        this.settingBlending = b;
    }
    setSize(s) {
        this.settingSize = s * 2;
    }
    getScale() {
        return this.settingScale;
    }
    setScale(s) {
        this.settingScale = s;
    }
    setContext(c) {
        this.context = c;
    }
    startLine(x, y, pressure, shift) {
        if (shift && this.lastInput.x) {
            this.inputIsDrawing = true;
            this.endLine();
        } else {
            this.inputIsDrawing = true;
            this.lastX = x;
            this.lastY = y;
            this.lastInput.x = x;
            this.lastInput.y = y;
            this.historyEntry = {
                tool: [
                    "brush",
                    "SketchyBrush"
                ],
                actions: [
                    {
                        action: "setScale",
                        params: [
                            this.settingScale
                        ]
                    },
                    {
                        action: "setSize",
                        params: [
                            this.settingSize / 2
                        ]
                    },
                    {
                        action: "setOpacity",
                        params: [
                            this.settingOpacity
                        ]
                    },
                    {
                        action: "setColor",
                        params: [
                            this.settingColor
                        ]
                    },
                    {
                        action: "setBlending",
                        params: [
                            this.settingBlending
                        ]
                    },
                    {
                        action: "startLine",
                        params: [
                            x,
                            y,
                            pressure
                        ]
                    }
                ]
            };
        }
    }
    goLine(p_x, p_y, pressure, preMixedColor) {
        if (!this.inputIsDrawing || p_x === this.lastInput.x && p_y === this.lastInput.y) return;
        let e, b, a, g;
        const x = parseInt("" + p_x);
        const y = parseInt("" + p_y);
        this.points.push([
            x,
            y
        ]);
        let mixr = this.settingColor.r;
        let mixg = this.settingColor.g;
        let mixb = this.settingColor.b;
        if (preMixedColor) {
            mixr = preMixedColor.r;
            mixg = preMixedColor.g;
            mixb = preMixedColor.b;
        } else {
            if (this.settingBlending !== 0) {
                if (x + 5 >= 0 && y + 5 >= 0 && x - 5 < this.context.canvas.width - 1 && y - 5 < this.context.canvas.height - 1) {
                    mixr = 0;
                    mixg = 0;
                    mixb = 0;
                    const mixX = Math.min(this.context.canvas.width - 1, Math.max(0, x - 5));
                    const mixY = Math.min(this.context.canvas.height - 1, Math.max(0, y - 5));
                    let mixW = Math.min(this.context.canvas.width - 1, Math.max(0, x + 5));
                    let mixH = Math.min(this.context.canvas.height - 1, Math.max(0, y + 5));
                    mixW -= mixX;
                    mixH -= mixY;
                    if (mixW > 0 && mixH > 0) {
                        const imDat = this.context.getImageData(mixX, mixY, mixW, mixH);
                        let countMix = 0;
                        for(let i = 0; i < imDat.data.length; i += 4){
                            mixr += imDat.data[i + 0];
                            mixg += imDat.data[i + 1];
                            mixb += imDat.data[i + 2];
                            countMix++;
                        }
                        mixr /= countMix;
                        mixg /= countMix;
                        mixb /= countMix;
                    }
                    const mixed = this.mixMode[0](new (0, _bb.BB).RGB(mixr, mixg, mixb), this.settingColor);
                    mixr = parseInt("" + (0, _bb.BB).mix(this.settingColor.r, mixed.r, this.settingBlending));
                    mixg = parseInt("" + (0, _bb.BB).mix(this.settingColor.g, mixed.g, this.settingBlending));
                    mixb = parseInt("" + (0, _bb.BB).mix(this.settingColor.b, mixed.b, this.settingBlending));
                }
            }
        }
        this.context.save();
        this.context.strokeStyle = "rgba(" + mixr + ", " + mixg + ", " + mixb + ", " + this.settingOpacity + ")";
        this.context.lineWidth = this.settingSize;
        this.context.beginPath();
        this.context.moveTo(this.lastX, this.lastY);
        this.context.lineTo(x, y);
        for(e = 0; e < this.points.length; e++){
            b = this.points[e][0] - this.points[this.count][0];
            a = this.points[e][1] - this.points[this.count][1];
            g = b * b + a * a;
            if (g < 4000 * this.settingScale * this.settingScale && this.rand() > g / 2000 / this.settingScale / this.settingScale) {
                this.context.moveTo(this.points[this.count][0] + b * 0.3, this.points[this.count][1] + a * 0.3);
                this.context.lineTo(this.points[e][0] - b * 0.3, this.points[e][1] - a * 0.3);
            }
        }
        this.context.stroke();
        this.context.restore();
        this.count++;
        this.lastX = x;
        this.lastY = y;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.historyEntry.actions.push({
            action: "goLine",
            params: [
                p_x,
                p_y,
                pressure,
                {
                    r: mixr,
                    g: mixg,
                    b: mixb
                }
            ]
        });
    }
    endLine() {
        this.inputIsDrawing = false;
        this.count = 0;
        this.points = [];
        if (this.historyEntry) {
            this.historyEntry.actions.push({
                action: "endLine",
                params: []
            });
            this.history.push(this.historyEntry);
            this.historyEntry = undefined;
        }
    }
    //cheap 'n' ugly
    drawLineSegment(x1, y1, x2, y2) {
        this.lastInput.x = x2;
        this.lastInput.y = y2;
        if (this.inputIsDrawing || x1 === undefined) return;
        this.context.save();
        this.context.lineWidth = this.settingSize;
        const mixCol = {
            r: this.settingColor.r,
            g: this.settingColor.g,
            b: this.settingColor.b
        };
        if (x1 + 5 >= 0 && y1 + 5 >= 0 && x1 - 5 < this.context.canvas.width - 1 && y1 - 5 < this.context.canvas.height - 1) {
            mixCol.r = 0;
            mixCol.g = 0;
            mixCol.b = 0;
            const mixX = Math.min(this.context.canvas.width - 1, Math.max(0, x1 - 5));
            const mixY = Math.min(this.context.canvas.height - 1, Math.max(0, y1 - 5));
            let mixW = Math.min(this.context.canvas.width - 1, Math.max(0, x1 + 5));
            let mixH = Math.min(this.context.canvas.height - 1, Math.max(0, y1 + 5));
            mixW -= mixX;
            mixH -= mixY;
            if (mixW > 0 && mixH > 0) {
                const w = Math.min(sampleCanvas.width, mixW);
                const h = Math.min(sampleCanvas.height, mixH);
                sampleCtx.save();
                sampleCtx.globalCompositeOperation = "copy";
                sampleCtx.drawImage(this.context.canvas, mixX, mixY, mixW, mixH, 0, 0, w, h);
                sampleCtx.restore();
                const imDat = sampleCtx.getImageData(mixX, mixY, mixW, mixH);
                let countMix = 0;
                for(let i = 0; i < imDat.data.length; i += 4){
                    mixCol.r += imDat.data[i + 0];
                    mixCol.g += imDat.data[i + 1];
                    mixCol.b += imDat.data[i + 2];
                    countMix++;
                }
                mixCol.r /= countMix;
                mixCol.g /= countMix;
                mixCol.b /= countMix;
            }
        }
        const mixed = this.mixMode[0](new (0, _bb.BB).RGB(mixCol.r, mixCol.g, mixCol.b), this.settingColor);
        mixCol.r = parseInt("" + (this.settingBlending * mixed.r + this.settingColor.r * (1 - this.settingBlending)));
        mixCol.g = parseInt("" + (this.settingBlending * mixed.g + this.settingColor.g * (1 - this.settingBlending)));
        mixCol.b = parseInt("" + (this.settingBlending * mixed.b + this.settingColor.b * (1 - this.settingBlending)));
        this.context.strokeStyle = "rgba(" + mixCol.r + ", " + mixCol.g + ", " + mixCol.b + ", " + this.settingOpacity + ")";
        this.context.beginPath();
        this.context.moveTo(x1, y1);
        this.context.lineTo(x2, y2);
        this.context.stroke();
        this.context.strokeStyle = "rgba(" + mixCol.r + ", " + mixCol.g + ", " + mixCol.b + ", " + this.settingOpacity + ")";
        this.context.restore();
        const historyEntry = {
            tool: [
                "brush",
                "SketchyBrush"
            ],
            actions: [
                {
                    action: "setScale",
                    params: [
                        this.settingScale
                    ]
                },
                {
                    action: "setSize",
                    params: [
                        this.settingSize / 2
                    ]
                },
                {
                    action: "setOpacity",
                    params: [
                        this.settingOpacity
                    ]
                },
                {
                    action: "setColor",
                    params: [
                        this.settingColor
                    ]
                },
                {
                    action: "setBlending",
                    params: [
                        this.settingBlending
                    ]
                },
                {
                    action: "drawLineSegment",
                    params: [
                        x1,
                        y1,
                        x2,
                        y2
                    ]
                }
            ]
        };
        this.history.push(historyEntry);
    }
    isDrawing() {
        return this.inputIsDrawing;
    }
}

},{"../../bb/bb":"dcQKo","../kl":"8nmWp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3s9Dy":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "PixelBrush", ()=>PixelBrush);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
var _eraseColor = require("./erase-color");
var _base = require("../../bb/base/base");
class PixelBrush {
    updateDither() {
        this.ditherCtx.clearRect(0, 0, 4, 4);
        this.ditherCtx.fillStyle = this.settingIsEraser ? `rgb(${0, _eraseColor.ERASE_COLOR},${0, _eraseColor.ERASE_COLOR},${0, _eraseColor.ERASE_COLOR})` : this.settingColorStr;
        for(let i = 0; i < Math.max(1, Math.round(this.settingOpacity * this.ditherArr.length)); i++)this.ditherCtx.fillRect(this.ditherArr[i][0], this.ditherArr[i][1], 1, 1);
        this.ditherPattern = (0, _base.throwIfNull)(this.context.createPattern(this.ditherCanvas, "repeat"));
    }
    /**
     * Tests p1->p2 or p3->p4 deviate in their direction more than max, compared to p1->p4
     */ cubicCurveOverThreshold(p1, p2, p3, p4, maxAngleRad) {
        const d = (0, _bb.BB).Vec2.nor({
            x: p4.x - p1.x,
            y: p4.y - p1.y
        });
        const d2 = (0, _bb.BB).Vec2.nor({
            x: p2.x - p1.x,
            y: p2.y - p1.y
        });
        const d3 = (0, _bb.BB).Vec2.nor({
            x: p4.x - p3.x,
            y: p4.y - p3.y
        });
        // const a2 = Math.abs(BB.Vec2.angle(d, d2) % Math.PI) / Math.PI * 180;
        // const a3 = Math.abs(BB.Vec2.angle(d, d3) % Math.PI) / Math.PI * 180;
        return Math.max((0, _bb.BB).Vec2.dist(d, d2), (0, _bb.BB).Vec2.dist(d, d3)) > maxAngleRad;
    }
    plotCubicBezierLine(p1, p2, p3, p4) {
        const isOverThreshold = this.cubicCurveOverThreshold(p1, p2, p3, p4, 0.1);
        p1.x = Math.floor(p1.x);
        p1.y = Math.floor(p1.y);
        p4.x = Math.floor(p4.x);
        p4.y = Math.floor(p4.y);
        const dist = (0, _bb.BB).dist(p1.x, p1.y, p4.x, p4.y);
        if (!isOverThreshold || dist < 7) {
            this.plotLine(p1.x, p1.y, p4.x, p4.y, true);
            return;
        }
        const n = Math.max(2, Math.round(dist / 4));
        const pointArr = [];
        for(let i = 0; i <= n; i++){
            const t = i / n;
            const a = Math.pow(1 - t, 3);
            const b = 3 * t * Math.pow(1 - t, 2);
            const c = 3 * Math.pow(t, 2) * (1 - t);
            const d = Math.pow(t, 3);
            pointArr.push({
                x: a * p1.x + b * p2.x + c * p3.x + d * p4.x,
                y: a * p1.y + b * p2.y + c * p3.y + d * p4.y
            });
        }
        for(let i = 0; i < n; i++)this.plotLine(Math.round(pointArr[i].x), Math.round(pointArr[i].y), Math.round(pointArr[i + 1].x), Math.round(pointArr[i + 1].y), true);
    }
    drawDot(x, y, size, opacity) {
        this.context.save();
        if (this.settingIsEraser) {
            this.context.fillStyle = this.settingUseDither ? this.ditherPattern : "#fff";
            if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = "source-atop";
            else this.context.globalCompositeOperation = "destination-out";
        } else {
            this.context.fillStyle = this.settingUseDither ? this.ditherPattern : this.settingColorStr;
            if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = "source-atop";
        }
        this.context.globalAlpha = this.settingUseDither ? 1 : opacity;
        this.context.fillRect(Math.round(x + -size), Math.round(y + -size), Math.round(size * 2), Math.round(size * 2));
        this.context.restore();
    }
    continueLine(x, y, size, pressure) {
        if (this.bezierLine === null) {
            this.bezierLine = new (0, _bb.BB).BezierLine();
            this.bezierLine.add(this.lastInput.x, this.lastInput.y, 0, ()=>{});
        }
        this.context.save();
        const dotCallback = (val)=>{
            const localPressure = (0, _bb.BB).mix(this.lastInput2.pressure, pressure, val.t);
            const localOpacity = this.settingOpacity * (this.settingHasOpacityPressure ? localPressure * localPressure : 1);
            const localSize = Math.max(0.5, this.settingSize * (this.settingHasSizePressure ? localPressure : 1));
            this.drawDot(val.x, val.y, localSize, localOpacity);
        };
        const controlCallback = (controlObj)=>{
            this.plotCubicBezierLine(controlObj.p1, controlObj.p2, controlObj.p3, controlObj.p4);
        };
        if (Math.round(this.settingSize * 2) === 1) {
            if (x === null || y === null) this.bezierLine.addFinal(4, undefined, controlCallback);
            else this.bezierLine.add(x, y, 4, undefined, controlCallback);
        } else {
            const localSpacing = size * this.settingSpacing;
            if (x === null || y === null) this.bezierLine.addFinal(localSpacing, dotCallback);
            else this.bezierLine.add(x, y, localSpacing, dotCallback);
        }
        this.context.restore();
    }
    /**
     * bresenheim line drawing
     */ plotLine(x0, y0, x1, y1, skipFirst) {
        this.context.save();
        if (this.settingIsEraser) {
            this.context.fillStyle = this.settingUseDither ? this.ditherPattern : "#fff";
            if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = "source-atop";
            else this.context.globalCompositeOperation = "destination-out";
        } else {
            this.context.fillStyle = this.settingUseDither ? this.ditherPattern : this.settingColorStr;
            if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = "source-atop";
        }
        this.context.globalAlpha = this.settingUseDither ? 1 : this.settingOpacity;
        x0 = Math.floor(x0);
        y0 = Math.floor(y0);
        x1 = Math.floor(x1);
        y1 = Math.floor(y1);
        const dX = Math.abs(x1 - x0);
        const sX = x0 < x1 ? 1 : -1;
        const dY = -Math.abs(y1 - y0);
        const sY = y0 < y1 ? 1 : -1;
        let err = dX + dY;
        // eslint-disable-next-line no-constant-condition
        while(true){
            if (skipFirst) skipFirst = false;
            else this.context.fillRect(x0, y0, 1, 1);
            if (x0 === x1 && y0 === y1) break;
            const e2 = 2 * err;
            if (e2 >= dY) {
                err += dY;
                x0 += sX;
            }
            if (e2 <= dX) {
                err += dX;
                y0 += sY;
            }
        }
        this.context.restore();
    }
    // ---- public ----
    constructor(){
        this.history = new (0, _kl.KL).DecoyKlHistory();
        this.context = {};
        this.settingHasSizePressure = true;
        this.settingHasOpacityPressure = false;
        this.settingSize = 0.5;
        this.settingSpacing = 0.9;
        this.settingOpacity = 1;
        this.settingColor = {};
        this.settingColorStr = "";
        this.settingLockLayerAlpha = false;
        this.settingIsEraser = false;
        this.settingUseDither = true;
        this.inputIsDrawing = false;
        this.lineToolLastDot = 0;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastInput2 = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.bezierLine = null;
        this.ditherArr = [
            [
                3,
                2
            ],
            [
                1,
                0
            ],
            [
                3,
                0
            ],
            [
                1,
                2
            ],
            [
                2,
                1
            ],
            [
                0,
                3
            ],
            [
                0,
                1
            ],
            [
                2,
                3
            ],
            [
                2,
                0
            ],
            [
                0,
                2
            ],
            [
                0,
                0
            ],
            [
                2,
                2
            ],
            [
                1,
                1
            ],
            [
                3,
                3
            ],
            [
                3,
                1
            ],
            [
                1,
                3
            ]
        ];
        this.ditherPattern = {};
        this.ditherCanvas = (0, _bb.BB).canvas(4, 4);
        this.ditherCtx = (0, _bb.BB).ctx(this.ditherCanvas);
    }
    // ---- interface ----
    startLine(x, y, p) {
        this.historyEntry = {
            tool: [
                "brush",
                "PixelBrush"
            ],
            actions: [
                {
                    action: "sizePressure",
                    params: [
                        this.settingHasSizePressure
                    ]
                },
                {
                    action: "opacityPressure",
                    params: [
                        this.settingHasOpacityPressure
                    ]
                },
                {
                    action: "setSize",
                    params: [
                        this.settingSize
                    ]
                },
                {
                    action: "setSpacing",
                    params: [
                        this.settingSpacing
                    ]
                },
                {
                    action: "setOpacity",
                    params: [
                        this.settingOpacity
                    ]
                },
                {
                    action: "setColor",
                    params: [
                        this.settingColor
                    ]
                },
                {
                    action: "setLockAlpha",
                    params: [
                        this.settingLockLayerAlpha
                    ]
                },
                {
                    action: "setIsEraser",
                    params: [
                        this.settingIsEraser
                    ]
                },
                {
                    action: "setUseDither",
                    params: [
                        this.settingUseDither
                    ]
                }
            ]
        };
        if (this.settingUseDither) this.updateDither();
        p = Math.max(0, Math.min(1, p));
        const localOpacity = this.settingHasOpacityPressure ? this.settingOpacity * p * p : this.settingOpacity;
        const localSize = this.settingHasSizePressure ? Math.max(0.5, p * this.settingSize) : Math.max(0.5, this.settingSize);
        this.inputIsDrawing = true;
        this.drawDot(x, y, localSize, localOpacity);
        this.lineToolLastDot = localSize * this.settingSpacing;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        this.historyEntry.actions.push({
            action: "startLine",
            params: [
                x,
                y,
                p
            ]
        });
    }
    goLine(x, y, p) {
        if (!this.inputIsDrawing) return;
        this.historyEntry.actions.push({
            action: "goLine",
            params: [
                x,
                y,
                p
            ]
        });
        //debug
        //drawDot(x, y, 1, 0.5);
        const pressure = (0, _bb.BB).clamp(p, 0, 1);
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.continueLine(x, y, localSize, this.lastInput.pressure);
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = pressure;
    }
    endLine(x, y) {
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.continueLine(null, null, localSize, this.lastInput.pressure);
        //debug
        //drawDot(lastInput.x, lastInput.y, 3, 1);
        //drawDot(x, y, 10, 0.1);
        this.inputIsDrawing = false;
        this.bezierLine = null;
        if (this.historyEntry) {
            this.historyEntry.actions.push({
                action: "endLine",
                params: [
                    x,
                    y
                ]
            });
            this.history.push(this.historyEntry);
            this.historyEntry = undefined;
        }
    }
    //cheap n' ugly
    drawLineSegment(x1, y1, x2, y2) {
        this.lastInput.x = x2;
        this.lastInput.y = y2;
        this.lastInput.pressure = 1;
        if (this.inputIsDrawing || x1 === undefined) return;
        if (this.settingUseDither) this.updateDither();
        if (Math.round(this.settingSize * 2) === 1) this.plotLine(x1, y1, x2, y2, true);
        else {
            // const angle = BB.pointsToAngleDeg({x: x1, y: y1}, {x: x2, y: y2});
            const mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
            const eX = (x2 - x1) / mouseDist;
            const eY = (y2 - y1) / mouseDist;
            let loopDist;
            const bdist = this.settingSize * this.settingSpacing;
            this.lineToolLastDot = this.settingSize * this.settingSpacing;
            for(loopDist = this.lineToolLastDot; loopDist <= mouseDist; loopDist += bdist)this.drawDot(x1 + eX * loopDist, y1 + eY * loopDist, this.settingSize, this.settingOpacity);
        }
        const historyEntry = {
            tool: [
                "brush",
                "PixelBrush"
            ],
            actions: [
                {
                    action: "sizePressure",
                    params: [
                        this.settingHasSizePressure
                    ]
                },
                {
                    action: "opacityPressure",
                    params: [
                        this.settingHasOpacityPressure
                    ]
                },
                {
                    action: "setSize",
                    params: [
                        this.settingSize
                    ]
                },
                {
                    action: "setSpacing",
                    params: [
                        this.settingSpacing
                    ]
                },
                {
                    action: "setOpacity",
                    params: [
                        this.settingOpacity
                    ]
                },
                {
                    action: "setColor",
                    params: [
                        this.settingColor
                    ]
                },
                {
                    action: "setLockAlpha",
                    params: [
                        this.settingLockLayerAlpha
                    ]
                },
                {
                    action: "setIsEraser",
                    params: [
                        this.settingIsEraser
                    ]
                },
                {
                    action: "setUseDither",
                    params: [
                        this.settingUseDither
                    ]
                },
                {
                    action: "drawLineSegment",
                    params: [
                        x1,
                        y1,
                        x2,
                        y2
                    ]
                }
            ]
        };
        this.history.push(historyEntry);
    }
    //IS
    isDrawing() {
        return this.inputIsDrawing;
    }
    //SET
    setColor(c) {
        if (this.settingColor === c) return;
        this.settingColor = c;
        this.settingColorStr = "rgb(" + this.settingColor.r + "," + this.settingColor.g + "," + this.settingColor.b + ")";
    }
    setContext(c) {
        this.context = c;
    }
    setHistory(l) {
        this.history = l;
    }
    setSize(s) {
        this.settingSize = Math.round(s * 2) / 2;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setSpacing(s) {
        this.settingSpacing = s;
    }
    sizePressure(b) {
        this.settingHasSizePressure = b;
    }
    opacityPressure(b) {
        this.settingHasOpacityPressure = b;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = b;
    }
    setIsEraser(b) {
        this.settingIsEraser = b;
    }
    setUseDither(b) {
        this.settingUseDither = b;
    }
    //GET
    getSpacing() {
        return this.settingSpacing;
    }
    getSize() {
        return this.settingSize;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
    getIsEraser() {
        return this.settingIsEraser;
    }
    getUseDither() {
        return this.settingUseDither;
    }
}

},{"../../bb/bb":"dcQKo","../kl":"8nmWp","./erase-color":"lUgDd","../../bb/base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9XyVo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "EraserBrush", ()=>EraserBrush);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
var _eraseColor = require("./erase-color");
class EraserBrush {
    drawDot(x, y, size, opacity) {
        this.context.save();
        if (this.isBaseLayer) {
            if (this.isTransparentBG) this.context.globalCompositeOperation = "destination-out";
            else this.context.globalCompositeOperation = "source-atop";
        } else this.context.globalCompositeOperation = "destination-out";
        const radgrad = this.context.createRadialGradient(size, size, 0, size, size, size);
        let sharpness = Math.pow(opacity, 2);
        sharpness = Math.max(0, Math.min((size - 1) / size, sharpness));
        const oFac = Math.max(0, Math.min(1, opacity));
        const localOpacity = 2 * oFac - oFac * oFac;
        radgrad.addColorStop(sharpness, `rgba(${(0, _eraseColor.ERASE_COLOR)}, ${(0, _eraseColor.ERASE_COLOR)}, ${(0, _eraseColor.ERASE_COLOR)}, ` + localOpacity + ")");
        radgrad.addColorStop(1, `rgba(${(0, _eraseColor.ERASE_COLOR)}, ${(0, _eraseColor.ERASE_COLOR)}, ${(0, _eraseColor.ERASE_COLOR)}, 0)`);
        this.context.fillStyle = radgrad;
        this.context.translate(x - size, y - size);
        this.context.fillRect(0, 0, size * 2, size * 2);
        this.context.restore();
    }
    continueLine(x, y, p) {
        p = Math.max(0, Math.min(1, p));
        let localPressure;
        let localOpacity;
        let localSize = this.useSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size);
        const bdist = Math.max(1, Math.max(0.5, 1 - this.opacity) * localSize * this.spacing);
        const bezierCallback = (val)=>{
            const factor = val.t;
            localPressure = this.lastInput2.pressure * (1 - factor) + p * factor;
            localOpacity = this.useOpacityPressure ? this.opacity * localPressure * localPressure : this.opacity;
            localSize = this.useSizePressure ? Math.max(0.1, localPressure * this.size) : Math.max(0.1, this.size);
            this.drawDot(val.x, val.y, localSize, localOpacity);
        };
        if (x === undefined || y === undefined) this.bezierLine.addFinal(bdist, bezierCallback);
        else this.bezierLine.add(x, y, bdist, bezierCallback);
    }
    // ---- public -----
    constructor(){
        this.size = 30;
        this.spacing = 0.4;
        this.opacity = 1;
        this.useSizePressure = true;
        this.useOpacityPressure = false;
        this.isTransparentBG = false;
        this.history = new (0, _kl.KL).DecoyKlHistory();
        this.isBaseLayer = false;
        this.context = {};
        this.started = false;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastInput2 = {
            x: 0,
            y: 0,
            pressure: 0
        };
    }
    // ---- interface ----
    startLine(x, y, p) {
        this.historyEntry = {
            tool: [
                "brush",
                "EraserBrush"
            ],
            actions: [
                {
                    action: "opacityPressure",
                    params: [
                        this.useOpacityPressure
                    ]
                },
                {
                    action: "sizePressure",
                    params: [
                        this.useSizePressure
                    ]
                },
                {
                    action: "setSize",
                    params: [
                        this.size
                    ]
                },
                {
                    action: "setOpacity",
                    params: [
                        this.opacity
                    ]
                },
                {
                    action: "setTransparentBG",
                    params: [
                        this.isTransparentBG
                    ]
                },
                {
                    action: "startLine",
                    params: [
                        x,
                        y,
                        p
                    ]
                }
            ]
        };
        this.isBaseLayer = 0 === this.context.canvas.index;
        p = Math.max(0, Math.min(1, p));
        const localOpacity = this.useOpacityPressure ? this.opacity * p * p : this.opacity;
        const localSize = this.useSizePressure ? Math.max(0.1, p * this.size) : Math.max(0.1, this.size);
        this.started = true;
        if (localSize > 1) this.drawDot(x, y, localSize, localOpacity);
        this.lastDot = localSize * this.spacing;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        this.bezierLine = new (0, _bb.BB).BezierLine();
        this.bezierLine.add(x, y, 0, ()=>undefined);
    }
    goLine(x, y, p) {
        if (!this.started || !this.historyEntry) return;
        this.historyEntry.actions?.push({
            action: "goLine",
            params: [
                x,
                y,
                p
            ]
        });
        this.continueLine(x, y, this.lastInput.pressure);
        this.lastInput2 = (0, _bb.BB).copyObj(this.lastInput);
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
    }
    endLine() {
        if (this.bezierLine) this.continueLine(undefined, undefined, this.lastInput.pressure);
        this.started = false;
        this.bezierLine = undefined;
        if (this.historyEntry) {
            this.historyEntry.actions?.push({
                action: "endLine",
                params: []
            });
            this.history.push(this.historyEntry);
            this.historyEntry = undefined;
        }
    }
    drawLineSegment(x1, y1, x2, y2) {
        this.isBaseLayer = 0 === this.context.canvas.index;
        this.lastInput.x = x2;
        this.lastInput.y = y2;
        if (this.started || x1 === undefined) return;
        const mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        const eX = (x2 - x1) / mouseDist;
        const eY = (y2 - y1) / mouseDist;
        let loopDist;
        const bdist = Math.max(1, Math.max(0.5, 1 - this.opacity) * this.size * this.spacing);
        this.lastDot = 0;
        for(loopDist = this.lastDot; loopDist <= mouseDist; loopDist += bdist)this.drawDot(x1 + eX * loopDist, y1 + eY * loopDist, this.size, this.opacity);
        const historyEntry = {
            tool: [
                "brush",
                "EraserBrush"
            ],
            actions: [
                {
                    action: "opacityPressure",
                    params: [
                        this.useOpacityPressure
                    ]
                },
                {
                    action: "sizePressure",
                    params: [
                        this.useSizePressure
                    ]
                },
                {
                    action: "setSize",
                    params: [
                        this.size
                    ]
                },
                {
                    action: "setOpacity",
                    params: [
                        this.opacity
                    ]
                },
                {
                    action: "setTransparentBG",
                    params: [
                        this.isTransparentBG
                    ]
                },
                {
                    action: "drawLineSegment",
                    params: [
                        x1,
                        y1,
                        x2,
                        y2
                    ]
                }
            ]
        };
        this.history.push(historyEntry);
    }
    //IS
    isDrawing() {
        return this.started;
    }
    //SET
    setContext(c) {
        this.context = c;
    }
    setHistory(l) {
        this.history = l;
    }
    setSize(s) {
        this.size = s;
    }
    setOpacity(o) {
        this.opacity = o;
    }
    sizePressure(b) {
        this.useSizePressure = b;
    }
    opacityPressure(b) {
        this.useOpacityPressure = b;
    }
    setTransparentBG(b) {
        this.isTransparentBG = b;
    }
    //GET
    getSize() {
        return this.size;
    }
    getOpacity() {
        return this.opacity;
    }
}

},{"../../bb/bb":"dcQKo","../kl":"8nmWp","./erase-color":"lUgDd","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8pk70":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SmudgeBrush", ()=>SmudgeBrush);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
var _math = require("../../bb/math/math");
// let statCount = 1;
// let statAcc = 0;
// stats on win10, chrome, size 100, opacity 80, smudge()
// unoptimized: 1 ms
// minimal: 0.09 ms
// minimal + circle: 0.5ms
// minimal + circle + ix, iy: 0.23ms
// unoptimized + ix, iy: 0.64 ms
// unoptimized + ix, iy + sans rounding: 0.61 ms
// ix, iy + sans rounding + sans random: 0.32ms
// ix, iy + sans rounding + fast random: 0.46 ms
// ix, iy + sans rounding + fast random + offset const: 0.48 ms
const CELL_SIZE = 256;
/**
 * determine bounds of smudge
 * @param imWidth
 * @param imHeight
 * @param aP
 * @param bP
 * @param size
 */ function prepSmudge(imWidth, imHeight, aP, bP, size) {
    if (aP.x === bP.x && aP.y === bP.y) return null;
    aP = (0, _bb.BB).copyObj(aP);
    bP = (0, _bb.BB).copyObj(bP);
    size = (0, _bb.BB).copyObj(size);
    // corner behavior
    // cut down rectangles, if a or b go outside
    // i.e. if user drags partially or fully outside the canvas
    {
        let top = 0;
        let right = 0;
        let bottom = 0;
        let left = 0;
        if (aP.x < 0) left = -aP.x;
        if (aP.y < 0) top = -aP.y;
        if (bP.x < 0) left = Math.max(left, -bP.x);
        if (bP.y < 0) top = Math.max(top, -bP.y);
        if (aP.x + size.w > imWidth) right = aP.x + size.w - imWidth;
        if (aP.y + size.h > imHeight) bottom = aP.y + size.h - imHeight;
        if (bP.x + size.w > imWidth) right = Math.max(right, bP.x + size.w - imWidth);
        if (bP.y + size.h > imHeight) bottom = Math.max(bottom, bP.y + size.h - imHeight);
        aP.x += left;
        bP.x += left;
        aP.y += top;
        bP.y += top;
        size.w = size.w - left - right;
        size.h = size.h - top - bottom;
        if (size.w <= 0 || size.h <= 0) return null;
    }
    return {
        aP: {
            x: aP.x,
            y: aP.y
        },
        bP: {
            x: bP.x,
            y: bP.y
        },
        size: {
            w: size.w,
            h: size.h
        }
    };
}
/**
 * Pixel operations that do the smudging via ImageData
 * @param imageData
 * @param p
 */ function smudge(imageData, p) {
    p = (0, _bb.BB).copyObj(p);
    const cSize = p.brush.size;
    const cX = p.brush.center.x;
    const cY = p.brush.center.y;
    /*if (statCount % 1000 === 0) {
        console.log(statAcc / 1000);
        statAcc = 0;
    }
    let start = performance.now();*/ // determine offset
    const aIndex = p.aP.y * imageData.width + p.aP.x;
    const bIndex = p.bP.y * imageData.width + p.bP.x;
    const offset = (bIndex - aIndex) * 4;
    // array with random numbers. faster than Math.random()
    let randI = 0;
    const randLen = cSize > 30 ? 1024 : 512; // lower lengths lead to noticeable patterns
    const randArr = [];
    for(let i = 0; i < randLen; i++)randArr[i] = (Math.random() - 0.5) / 1.001 + 0.5;
    const softnessPx = Math.max(3, Math.min(8, p.brush.size - 8));
    const pixel = (ai, bi, ix, iy)=>{
        const dist = (0, _bb.BB).dist(cX, cY, ix, iy);
        const fac = 1 - p.brush.opacity * (1 - (0, _math.clamp)((dist - (cSize - softnessPx)) / softnessPx, 0, 1));
        if (fac === 1) return;
        if (!imageData.data[ai + 3]) ;
        else if (!imageData.data[bi + 3]) {
            imageData.data[bi] = imageData.data[ai];
            imageData.data[bi + 1] = imageData.data[ai + 1];
            imageData.data[bi + 2] = imageData.data[ai + 2];
        } else {
            // consider alpha ratio. If a has lower alpha than b, then b should be stronger, and vice versa
            // not totally accurate. TODO same compositing as blend brush
            let fac2;
            if (imageData.data[ai + 3] < imageData.data[bi + 3]) fac2 = 1 - imageData.data[ai + 3] / imageData.data[bi + 3] * (1 - fac);
            else fac2 = imageData.data[bi + 3] / imageData.data[ai + 3] * fac;
            // ImageData's Uint8ClampedArray rounds -> 0.5 becomes 1. But not in Safari, so needs to be done manually
            // Offset mixed color by random number noise (-0.5, 0.5), so it doesn't get stuck while mixing.
            // No +0.5, because it cancels out with rand.
            imageData.data[bi] = Math.floor((0, _bb.BB).mix(imageData.data[ai], imageData.data[bi + 0], fac2) + randArr[randI]);
            imageData.data[bi + 1] = Math.floor((0, _bb.BB).mix(imageData.data[ai + 1], imageData.data[bi + 1], fac2) + randArr[randI]);
            imageData.data[bi + 2] = Math.floor((0, _bb.BB).mix(imageData.data[ai + 2], imageData.data[bi + 2], fac2) + randArr[randI]);
            randI = (randI + 1) % randLen;
        }
        // Always mix alpha. unless alpha lock
        if (!p.brush.alphaLock) imageData.data[bi + 3] = Math.floor((0, _bb.BB).mix(imageData.data[ai + 3], imageData.data[bi + 3], fac) + 0.5);
    };
    const bx1 = p.bP.x * 4;
    const bx2 = bx1 + (p.size.w - 1) * 4;
    // transfer of pixels depends on direction of smudging if there is overlap
    if (p.aP.y < p.bP.y) for(let y = p.size.h - 1, iy = p.bP.y + p.size.h - 1; y >= 0; y--, iy--){
        const yStart = (y + p.bP.y) * imageData.width * 4;
        for(let x = bx2 + yStart, x2 = bx2 + yStart - offset, ix = p.bP.x + p.size.w - 1; x >= bx1 + yStart; x -= 4, x2 -= 4, ix--)pixel(x2, x, ix, iy);
    }
    else if (p.aP.y > p.bP.y) for(let y = 0, iy = p.bP.y; y < p.size.h; y++, iy++){
        const yStart = (y + p.bP.y) * imageData.width * 4;
        for(let x = bx2 + yStart, x2 = bx2 + yStart - offset, ix = p.bP.x + p.size.w - 1; x >= bx1 + yStart; x -= 4, x2 -= 4, ix--)pixel(x2, x, ix, iy);
    }
    else {
        if (p.aP.x < p.bP.x) for(let y = p.size.h - 1, iy = p.bP.y + p.size.h - 1; y >= 0; y--, iy--){
            const yStart = (y + p.bP.y) * imageData.width * 4;
            for(let x = bx2 + yStart, x2 = bx2 + yStart - offset, ix = p.bP.x + p.size.w - 1; x >= bx1 + yStart; x -= 4, x2 -= 4, ix--)pixel(x2, x, ix, iy);
        }
        else for(let y = 0, iy = p.bP.y; y < p.size.h; y++, iy++){
            const yStart = (y + p.bP.y) * imageData.width * 4;
            for(let x = bx1 + yStart, x2 = bx1 + yStart - offset, ix = p.bP.x; x < bx2 + yStart; x += 4, x2 += 4, ix++)pixel(x2, x, ix, iy);
        }
    }
//statCount++;
//statAcc += performance.now() - start;
}
class SmudgeBrush {
    // workaround for https://github.com/microsoft/TypeScript/issues/41654
    resetRedrawBounds() {
        this.redrawBounds = undefined;
    }
    updateRedrawBounds(bounds) {
        this.redrawBounds = (0, _bb.BB).updateBounds(this.redrawBounds, bounds);
    }
    updateCompleteRedrawBounds(x1, y1, x2, y2) {
        this.completeRedrawBounds = (0, _bb.BB).updateBounds(this.completeRedrawBounds, {
            x1,
            y1,
            x2,
            y2
        });
    }
    /**
     * update copyImageData. copy over new regions if needed
     */ copyFromCanvas() {
        const touchedCells = this.copiedCells.map(()=>false);
        const bounds = [];
        const cellsW = Math.ceil(this.copyImageData.width / CELL_SIZE);
        if (!this.redrawBounds) return;
        bounds.push({
            x1: Math.floor(this.redrawBounds.x1 / CELL_SIZE),
            y1: Math.floor(this.redrawBounds.y1 / CELL_SIZE),
            x2: Math.floor(this.redrawBounds.x2 / CELL_SIZE),
            y2: Math.floor(this.redrawBounds.y2 / CELL_SIZE)
        });
        bounds.forEach((item)=>{
            for(let i = item.x1; i <= item.x2; i++)for(let e = item.y1; e <= item.y2; e++)touchedCells[e * cellsW + i] = true;
        });
        touchedCells.forEach((item, i)=>{
            if (!item || this.copiedCells[i]) // not touched, or already copied
            return;
            this.copiedCells[i] = true;
            const x = i % cellsW;
            const y = Math.floor(i / cellsW);
            const w = (Math.min(x * CELL_SIZE + CELL_SIZE, this.copyImageData.width) - 1) % CELL_SIZE + 1;
            const h = (Math.min(y * CELL_SIZE + CELL_SIZE, this.copyImageData.height) - 1) % CELL_SIZE + 1;
            // temp canvas to prevent main canvas from getting slowed down in chrome
            const tmpCanvas = (0, _bb.BB).canvas(w, h);
            const tmpCtx = (0, _bb.BB).ctx(tmpCanvas);
            tmpCtx.drawImage(this.context.canvas, -x * CELL_SIZE, -y * CELL_SIZE);
            const data = tmpCtx.getImageData(0, 0, w, h);
            for(let i = 0; i < h; i++)for(let e = 0, e2 = i * w * 4, e3 = ((y * CELL_SIZE + i) * this.copyImageData.width + x * CELL_SIZE) * 4; e < w; e++, e2 += 4, e3 += 4){
                this.copyImageData.data[e3] = data.data[e2];
                this.copyImageData.data[e3 + 1] = data.data[e2 + 1];
                this.copyImageData.data[e3 + 2] = data.data[e2 + 2];
                this.copyImageData.data[e3 + 3] = data.data[e2 + 3];
            }
        });
    }
    /**
     * fill drawBuffer with params about to be drawn
     * @param x
     * @param y
     * @param size
     * @param opacity
     */ prepDot(x, y, size, opacity) {
        if (!this.lastDot) {
            this.lastDot = {
                x: x,
                y: y
            };
            return;
        }
        size = Math.round(size);
        const w = Math.round(size * 2);
        const h = Math.round(size * 2);
        const bounds = prepSmudge(this.copyImageData.width, this.copyImageData.height, {
            x: Math.round(this.lastDot.x - size),
            y: Math.round(this.lastDot.y - size)
        }, {
            x: Math.round(x - size),
            y: Math.round(y - size)
        }, {
            w,
            h
        });
        if (bounds) {
            const params = {
                aP: bounds.aP,
                bP: bounds.bP,
                size: bounds.size,
                brush: {
                    center: {
                        x,
                        y
                    },
                    size,
                    opacity,
                    alphaLock: this.settingLockLayerAlpha
                }
            };
            this.updateRedrawBounds({
                x1: params.bP.x,
                y1: params.bP.y,
                x2: params.bP.x + params.brush.size * 2,
                y2: params.bP.y + params.brush.size * 2
            });
            this.drawBuffer.push(params);
        }
        this.lastDot = {
            x: x,
            y: y
        };
    }
    continueLine(x, y, size, pressure) {
        this.drawBuffer = [];
        if (!this.bezierLine) {
            this.bezierLine = new (0, _bb.BB).BezierLine();
            this.bezierLine.add(this.lastInput.x, this.lastInput.y, 0, function() {});
        }
        const drawArr = []; //draw instructions. will be all drawn at once
        const dotCallback = (val)=>{
            const localPressure = (0, _bb.BB).mix(this.lastInput2.pressure, pressure, val.t);
            const localOpacity = this.settingOpacity * (this.settingHasOpacityPressure ? localPressure * localPressure : 1);
            const localSize = Math.max(0.1, this.settingSize * (this.settingHasSizePressure ? localPressure : 1));
            drawArr.push([
                val.x,
                val.y,
                localSize,
                localOpacity
            ]); //, val.angle]);
        };
        const localSpacing = size * this.settingSpacing / 3;
        if (x === undefined || y === undefined) this.bezierLine.addFinal(localSpacing, dotCallback);
        else this.bezierLine.add(x, y, localSpacing, dotCallback);
        // execute draw instructions
        for(let i = 0; i < drawArr.length; i++){
            const item = drawArr[i];
            this.prepDot(item[0], item[1], item[2], item[3]);
        }
        this.copyFromCanvas();
        for(let i = 0; i < this.drawBuffer.length; i++)smudge(this.copyImageData, this.drawBuffer[i]);
    }
    // ---- public ----
    constructor(){
        this.context = {};
        this.history = new (0, _kl.KL).DecoyKlHistory();
        this.settingColor = {
            r: 0,
            g: 0,
            b: 0
        };
        this.settingSize = 35;
        this.settingSpacing = 0.20446882736951905;
        this.settingOpacity = 0.8;
        this.settingHasSizePressure = false;
        this.settingHasOpacityPressure = false;
        this.settingLockLayerAlpha = false;
        this.lineToolLastDot = 0;
        this.lastInput = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.lastInput2 = {
            x: 0,
            y: 0,
            pressure: 0
        };
        this.isDrawing = false;
        this.copyImageData = {};
        this.drawBuffer = [];
        this.copiedCells = [];
    }
    startLine(x, y, p) {
        this.historyEntry = {
            tool: [
                "brush",
                "SmudgeBrush"
            ],
            actions: []
        };
        p = (0, _bb.BB).clamp(p, 0, 1);
        const localOpacity = this.settingHasOpacityPressure ? this.settingOpacity * p * p : this.settingOpacity;
        const localSize = this.settingHasSizePressure ? Math.max(0.1, p * this.settingSize) : Math.max(0.1, this.settingSize);
        this.lastDot = undefined;
        this.isDrawing = true;
        this.copyImageData = new ImageData(this.context.canvas.width, this.context.canvas.height);
        const totalCells = Math.ceil(this.context.canvas.width / CELL_SIZE) * Math.ceil(this.context.canvas.height / CELL_SIZE);
        this.copiedCells = "0".repeat(totalCells).split("").map(()=>false);
        this.prepDot(x, y, localSize, localOpacity);
        this.lineToolLastDot = localSize * this.settingSpacing;
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput.pressure = p;
        this.lastInput2.pressure = p;
        this.completeRedrawBounds = undefined;
    }
    goLine(x, y, p) {
        if (!this.isDrawing) return;
        this.resetRedrawBounds();
        const pressure = (0, _bb.BB).clamp(p, 0, 1);
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.continueLine(x, y, localSize, this.lastInput.pressure);
        if (this.redrawBounds) {
            this.context.putImageData(this.copyImageData, 0, 0, this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2 - this.redrawBounds.x1 - 1, this.redrawBounds.y2 - this.redrawBounds.y1 - 1);
            this.updateCompleteRedrawBounds(this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2, this.redrawBounds.y2);
        }
        this.lastInput.x = x;
        this.lastInput.y = y;
        this.lastInput2.pressure = this.lastInput.pressure;
        this.lastInput.pressure = pressure;
    }
    endLine() {
        this.resetRedrawBounds();
        const localSize = this.settingHasSizePressure ? Math.max(0.1, this.lastInput.pressure * this.settingSize) : Math.max(0.1, this.settingSize);
        this.context.save();
        this.continueLine(undefined, undefined, localSize, this.lastInput.pressure);
        this.context.restore();
        this.isDrawing = false;
        this.bezierLine = undefined;
        if (this.redrawBounds) {
            this.context.putImageData(this.copyImageData, 0, 0, this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2 - this.redrawBounds.x1 - 1, this.redrawBounds.y2 - this.redrawBounds.y1 - 1);
            this.updateCompleteRedrawBounds(this.redrawBounds.x1, this.redrawBounds.y1, this.redrawBounds.x2, this.redrawBounds.y2);
        }
        if (this.historyEntry && this.completeRedrawBounds) {
            let historyIm = this.copyImageData;
            if (!(this.completeRedrawBounds.x1 === 0 && this.completeRedrawBounds.y1 === 0 && this.completeRedrawBounds.x2 >= this.context.canvas.width - 1 && this.completeRedrawBounds.y2 >= this.context.canvas.height - 1)) {
                // temp canvas to prevent main canvas from getting slowed down in chrome
                const tmpCanvas = (0, _bb.BB).canvas(this.completeRedrawBounds.x2 - this.completeRedrawBounds.x1 + 1, this.completeRedrawBounds.y2 - this.completeRedrawBounds.y1 + 1);
                const tmpCtx = (0, _bb.BB).ctx(tmpCanvas);
                tmpCtx.drawImage(this.context.canvas, -this.completeRedrawBounds.x1, -this.completeRedrawBounds.y1);
                historyIm = tmpCanvas; // faster than getting image data (measured on 2018 lenovo chromebook)
            }
            this.historyEntry.actions.push({
                action: "drawImage",
                params: [
                    historyIm,
                    this.completeRedrawBounds.x1,
                    this.completeRedrawBounds.y1
                ]
            });
            this.history.push(this.historyEntry);
            this.historyEntry = undefined;
        }
        this.copyImageData = {};
    }
    drawImage(im, x, y) {
        if (im instanceof ImageData) this.context.putImageData(im, x, y);
        else {
            this.context.clearRect(x, y, im.width, im.height);
            this.context.drawImage(im, x, y);
        }
    }
    drawLineSegment(x1, y1, x2, y2) {
        return;
    /*
        // todo
        lastInput.x = x2;
        lastInput.y = y2;
        lastInput.pressure = 1;

        if (isDrawing || x1 === undefined) {
            return;
        }

        let angle = BB.pointsToAngleDeg({x:x1, y:y1}, {x:x2, y:y2});
        let mouseDist = Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0));
        let eX = (x2 - x1) / mouseDist;
        let eY = (y2 - y1) / mouseDist;
        let loopDist;
        let bdist = settingSize * settingSpacing;
        lineToolLastDot = settingSize * settingSpacing;
        for (loopDist = lineToolLastDot; loopDist <= mouseDist; loopDist += bdist) {
            drawDot(x1 + eX * loopDist, y1 + eY * loopDist, settingSize, settingOpacity);
        }


        let historyEntry = {
            tool: ["brush", "SmudgeBrush"],
            actions: []
        };
        // todo
        history.add(historyEntry);*/ }
    getIsDrawing() {
        return this.isDrawing;
    }
    setColor(c) {
        if (this.settingColor.r === c.r && this.settingColor.g === c.g && this.settingColor.b === c.b) return;
        this.settingColor = {
            r: c.r,
            g: c.g,
            b: c.b
        };
    }
    setContext(c) {
        this.context = c;
    }
    setHistory(h) {
        this.history = h;
    }
    setSize(s) {
        this.settingSize = s;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setSpacing(s) {
        this.settingSpacing = s;
    }
    sizePressure(b) {
        this.settingHasSizePressure = b;
    }
    opacityPressure(b) {
        this.settingHasOpacityPressure = b;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = b;
    }
    getSpacing() {
        return this.settingSpacing;
    }
    getSize() {
        return this.settingSize;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
}

},{"../../bb/bb":"dcQKo","../kl":"8nmWp","../../bb/math/math":"7w6MZ","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3wxkc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "ChemyBrush", ()=>ChemyBrush);
var _bb = require("../../bb/bb");
var _eraseColor = require("./erase-color");
var _kl = require("../kl");
class ChemyBrush {
    updateCompleteRedrawBounds(x, y) {
        let bounds = {
            x1: x,
            y1: y,
            x2: x,
            y2: y
        };
        if (this.settingXSymmetry) bounds = (0, _bb.BB).updateBounds(bounds, {
            x1: -x + this.copyCanvas.width,
            y1: y,
            x2: -x + this.copyCanvas.width,
            y2: y
        });
        if (this.settingYSymmetry) bounds = (0, _bb.BB).updateBounds(bounds, {
            x1: x,
            y1: -y + this.copyCanvas.height,
            x2: x,
            y2: -y + this.copyCanvas.height
        });
        const buffer = this.settingMode === "stroke" ? this.settingSize + 1 : 1;
        bounds.x1 = Math.floor(bounds.x1 - buffer);
        bounds.y1 = Math.floor(bounds.y1 - buffer);
        bounds.x2 = Math.ceil(bounds.x2 + buffer);
        bounds.y2 = Math.ceil(bounds.y2 + buffer);
        this.completeRedrawBounds = (0, _bb.BB).updateBounds(this.completeRedrawBounds, bounds);
    }
    drawShape() {
        this.context.save();
        this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height);
        this.context.drawImage(this.copyCanvas, 0, 0);
        const color = {
            ...this.settingColor
        };
        if (this.settingIsEraser) {
            color.r = (0, _eraseColor.ERASE_COLOR);
            color.g = (0, _eraseColor.ERASE_COLOR);
            color.b = (0, _eraseColor.ERASE_COLOR);
            if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = "source-atop";
            else this.context.globalCompositeOperation = "destination-out";
        } else if (this.settingLockLayerAlpha) this.context.globalCompositeOperation = "source-atop";
        if (this.path.length > 1) {
            // path
            const path = new Path2D();
            this.path.forEach((item, index)=>{
                if (index === 0) path.moveTo(item.x, item.y);
                else path.lineTo(item.x, item.y);
            });
            let style = (0, _bb.BB).ColorConverter.toRgbaStr({
                r: color.r,
                g: color.g,
                b: color.b,
                a: this.settingOpacity
            });
            if (this.settingGradient) {
                const startAtTop = this.path[0].x > this.path[this.path.length - 1].x;
                const gradient = this.context.createLinearGradient(0, startAtTop ? this.minY : this.maxY, 0, startAtTop ? this.maxY : this.minY);
                gradient.addColorStop(0, (0, _bb.BB).ColorConverter.toRgbaStr({
                    r: color.r,
                    g: color.g,
                    b: color.b,
                    a: this.settingOpacity
                }));
                gradient.addColorStop(1, (0, _bb.BB).ColorConverter.toRgbaStr({
                    r: color.r,
                    g: color.g,
                    b: color.b,
                    a: 0
                }));
                style = gradient;
            }
            // setup params
            if (this.settingMode === "fill") this.context.fillStyle = style;
            else {
                this.context.lineWidth = this.settingSize * 2;
                this.context.lineJoin = "bevel";
                this.context.strokeStyle = style;
            }
            // draw
            const draw = ()=>{
                if (this.settingMode === "fill") this.context.fill(path);
                else this.context.stroke(path);
            };
            draw();
            if (this.settingXSymmetry) {
                this.context.save();
                this.context.translate(this.context.canvas.width / 2, 0);
                this.context.scale(-1, 1);
                this.context.translate(-this.context.canvas.width / 2, 0);
                draw();
                this.context.restore();
            }
            if (this.settingYSymmetry) {
                this.context.save();
                this.context.translate(0, this.context.canvas.height / 2);
                this.context.scale(1, -1);
                this.context.translate(0, -this.context.canvas.height / 2);
                draw();
                this.context.restore();
                if (this.settingXSymmetry) {
                    this.context.save();
                    this.context.translate(this.context.canvas.width / 2, this.context.canvas.height / 2);
                    this.context.scale(-1, -1);
                    this.context.translate(-this.context.canvas.width / 2, -this.context.canvas.height / 2);
                    draw();
                    this.context.restore();
                }
            }
        }
        this.context.restore();
    }
    // --- public ----
    constructor(){
        this.context = {};
        this.settingColor = {};
        this.settingSize = 0.25 // radius - 0.5 - 99999
        ;
        this.settingOpacity = 1 // 0-1
        ;
        this.settingLockLayerAlpha = false;
        this.settingIsEraser = false;
        this.settingMode = "fill";
        this.settingDistort = 0 // 0 - 1
        ;
        this.settingXSymmetry = false;
        this.settingYSymmetry = false;
        this.settingGradient = false;
        this.isDrawing = false;
        this.history = new (0, _kl.KL).DecoyKlHistory();
        this.copyCanvas = {};
        this.path = [];
        this.minY = 0;
        this.maxY = 0;
    }
    setHistory(h) {
        this.history = h;
    }
    getSize() {
        return this.settingMode === "stroke" ? this.settingSize : 0;
    }
    setSize(s) {
        this.settingSize = s;
    }
    getOpacity() {
        return this.settingOpacity;
    }
    setOpacity(o) {
        this.settingOpacity = o;
    }
    setColor(c) {
        this.settingColor = (0, _bb.BB).copyObj(c);
    }
    setContext(c) {
        this.context = c;
    }
    setMode(mode) {
        this.settingMode = mode;
    }
    getMode() {
        return this.settingMode;
    }
    setDistort(distort) {
        this.settingDistort = (0, _bb.BB).clamp(distort, 0, 1);
    }
    getDistort() {
        return this.settingDistort;
    }
    setXSymmetry(b) {
        this.settingXSymmetry = b;
    }
    getXSymmetry() {
        return this.settingXSymmetry;
    }
    setYSymmetry(b) {
        this.settingYSymmetry = b;
    }
    getYSymmetry() {
        return this.settingYSymmetry;
    }
    setGradient(b) {
        this.settingGradient = b;
    }
    getGradient() {
        return this.settingGradient;
    }
    getLockAlpha() {
        return this.settingLockLayerAlpha;
    }
    setLockAlpha(b) {
        this.settingLockLayerAlpha = b;
    }
    getIsEraser() {
        return this.settingIsEraser;
    }
    setIsEraser(b) {
        this.settingIsEraser = b;
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    startLine(x, y) {
        this.isDrawing = true;
        this.path = [
            {
                x,
                y
            }
        ];
        this.minY = y;
        this.maxY = y;
        this.copyCanvas = (0, _bb.BB).canvas(this.context.canvas.width, this.context.canvas.height);
        (0, _bb.BB).ctx(this.copyCanvas).drawImage(this.context.canvas, 0, 0);
        this.completeRedrawBounds = undefined;
        this.updateCompleteRedrawBounds(x, y);
    }
    goLine(x, y) {
        if (!this.isDrawing) return;
        const pos = {
            x,
            y
        };
        if (this.settingDistort > 0) {
            pos.x += (Math.random() - 0.5) * this.settingDistort * 80;
            pos.y += (Math.random() - 0.5) * this.settingDistort * 80;
        }
        this.minY = Math.min(this.minY, pos.y);
        this.maxY = Math.max(this.maxY, pos.y);
        this.path.push(pos);
        this.updateCompleteRedrawBounds(x, y);
        this.drawShape();
    }
    endLine() {
        this.isDrawing = false;
        this.completeRedrawBounds = (0, _bb.BB).boundsInArea(this.completeRedrawBounds, this.copyCanvas.width, this.copyCanvas.height);
        if (this.path.length > 1 && this.completeRedrawBounds) {
            const historyCanvas = (0, _bb.BB).canvas(this.completeRedrawBounds.x2 - this.completeRedrawBounds.x1 + 1, this.completeRedrawBounds.y2 - this.completeRedrawBounds.y1 + 1);
            const historyCtx = (0, _bb.BB).ctx(historyCanvas);
            historyCtx.drawImage(this.context.canvas, -this.completeRedrawBounds.x1, -this.completeRedrawBounds.y1);
            this.history.push({
                tool: [
                    "brush",
                    "ChemyBrush"
                ],
                actions: [
                    {
                        action: "drawImage",
                        params: [
                            historyCanvas,
                            this.completeRedrawBounds.x1,
                            this.completeRedrawBounds.y1
                        ]
                    }
                ]
            });
        }
        this.path = [];
        this.copyCanvas = {};
    }
    drawImage(im, x, y) {
        this.context.save();
        this.context.clearRect(x, y, im.width, im.height);
        this.context.drawImage(im, x, y);
        this.context.restore();
    }
    drawLineSegment(x1, y1, x2, y2) {
    // might make sense for stroke
    }
}

},{"../../bb/bb":"dcQKo","./erase-color":"lUgDd","../kl":"8nmWp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"io8zk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "brushesUI", ()=>brushesUI);
var _penBrushUi = require("./pen-brush-ui");
var _blendBrushUi = require("./blend-brush-ui");
var _sketchyBrushUi = require("./sketchy-brush-ui");
var _pixelBrushUi = require("./pixel-brush-ui");
var _eraserBrushUi = require("./eraser-brush-ui");
var _smudgeBrushUi = require("./smudge-brush-ui");
var _chemyBrushUi = require("./chemy-brush-ui");
const brushesUI = {
    penBrush: (0, _penBrushUi.penBrushUi),
    blendBrush: (0, _blendBrushUi.blendBrushUi),
    sketchyBrush: (0, _sketchyBrushUi.sketchyBrushUi),
    pixelBrush: (0, _pixelBrushUi.pixelBrushUi),
    chemyBrush: (0, _chemyBrushUi.chemyBrushUi),
    smudgeBrush: (0, _smudgeBrushUi.smudgeBrushUi),
    eraserBrush: (0, _eraserBrushUi.eraserBrushUi)
};

},{"./pen-brush-ui":"jEGZw","./blend-brush-ui":"3VdlJ","./sketchy-brush-ui":"cBnfe","./pixel-brush-ui":"h6rIQ","./eraser-brush-ui":"fVvBI","./smudge-brush-ui":"7smKi","./chemy-brush-ui":"cklS9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jEGZw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "penBrushUi", ()=>penBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _checkbox = require("../ui/components/checkbox");
var _klSlider = require("../ui/components/kl-slider");
var _createPenPressureToggle = require("../ui/components/create-pen-pressure-toggle");
var _brushPenSvg = require("/src/app/img/ui/brush-pen.svg");
var _brushPenSvgDefault = parcelHelpers.interopDefault(_brushPenSvg);
var _brushAlphas = require("../brushes/alphas/brush-alphas");
var _language = require("../../language/language");
var _options = require("../ui/components/options");
const penBrushUi = function() {
    const brushInterface = {
        image: (0, _brushPenSvgDefault.default),
        tooltip: (0, _language.LANG)("brush-pen"),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        }
    };
    let alphaNames = [
        (0, _language.LANG)("brush-pen-circle"),
        (0, _language.LANG)("brush-pen-chalk"),
        (0, _language.LANG)("brush-pen-calligraphy"),
        (0, _language.LANG)("brush-pen-square")
    ];
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-pen");
        alphaNames = [
            (0, _language.LANG)("brush-pen-circle"),
            (0, _language.LANG)("brush-pen-chalk"),
            (0, _language.LANG)("brush-pen-calligraphy"),
            (0, _language.LANG)("brush-pen-square")
        ];
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement("div"); // the gui
        const brush = new (0, _brushes.brushes).PenBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        const alphaOptions = new (0, _options.Options)({
            optionArr: [
                0,
                1,
                2,
                3
            ].map((id)=>{
                const alpha = (0, _bb.BB).el({
                    className: "dark-invert",
                    css: {
                        width: "31px",
                        height: "31px",
                        backgroundSize: "contain",
                        margin: "2px"
                    }
                });
                const canvas = (0, _bb.BB).canvas(70, 70);
                const ctx = (0, _bb.BB).ctx(canvas);
                if (id === 0 || id === 3) {
                    if (id === 0) {
                        ctx.beginPath();
                        ctx.arc(35, 35, 30, 0, 2 * Math.PI);
                        ctx.closePath();
                        ctx.fill();
                    } else ctx.fillRect(5, 5, 60, 60);
                } else if (id === 1) ctx.drawImage((0, _brushAlphas.genBrushAlpha01)(60), 5, 5);
                else if (id === 2) ctx.drawImage((0, _brushAlphas.genBrushAlpha02)(60), 5, 5);
                alpha.style.backgroundImage = "url(" + canvas.toDataURL("image/png") + ")";
                return {
                    id: id,
                    label: alpha,
                    title: alphaNames[id]
                };
            }),
            initId: 0,
            onChange: (id)=>{
                brush.setAlpha(id);
            }
        });
        const lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: brush.getLockAlpha(),
            label: (0, _language.LANG)("lock-alpha"),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: (0, _language.LANG)("lock-alpha-title"),
            css: {
                display: "inline-block"
            }
        });
        const spacingSpline = new (0, _bb.BB).SplineInterpolator([
            [
                0,
                15
            ],
            [
                8,
                7
            ],
            [
                14,
                4
            ],
            [
                30,
                3
            ],
            [
                50,
                2.7
            ],
            [
                100,
                2
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(Math.max(2, spacingSpline.interpolate(size)) / 15);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brushInterface.opacitySlider.max,
                curve: brushInterface.opacitySlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            const pressureSizeToggle = (0, _createPenPressureToggle.createPenPressureToggle)(true, function(b) {
                brush.sizePressure(b);
            });
            const pressureOpacityToggle = (0, _createPenPressureToggle.createPenPressureToggle)(false, function(b) {
                brush.opacityPressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginBottom: "10px"
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center"
                }
            }), (0, _bb.BB).el({
                content: alphaOptions.getElement(),
                css: {
                    marginTop: "10px"
                }
            }), (0, _bb.BB).el({
                content: lockAlphaToggle.getElement(),
                css: {
                    marginTop: "10px"
                }
            }));
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function(x, y) {
            brush.endLine(x, y);
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","../brushes/brushes":"8eOZC","./brushes-consts":"dlABn","../history/kl-history":"klzEn","../ui/components/checkbox":"8fYiz","../ui/components/kl-slider":"4hcvv","../ui/components/create-pen-pressure-toggle":"4cmBB","/src/app/img/ui/brush-pen.svg":"c9T4c","../brushes/alphas/brush-alphas":"6o2bW","../../language/language":"iiYGN","../ui/components/options":"hNLP6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dlABn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eventResMs", ()=>eventResMs);
const eventResMs = 20;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"c9T4c":[function(require,module,exports) {
module.exports = require("2ec0e76eaee7bec2").getBundleURL("d3gnI") + "brush-pen.bb14ef6e.svg" + "?" + Date.now();

},{"2ec0e76eaee7bec2":"lgJ39"}],"3VdlJ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "blendBrushUi", ()=>blendBrushUi);
var _bb = require("../../bb/bb");
var _createPenPressureToggle = require("../ui/components/create-pen-pressure-toggle");
var _brushesConsts = require("./brushes-consts");
var _checkbox = require("../ui/components/checkbox");
var _brushes = require("../brushes/brushes");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/components/kl-slider");
var _brushBlendSvg = require("/src/app/img/ui/brush-blend.svg");
var _brushBlendSvgDefault = parcelHelpers.interopDefault(_brushBlendSvg);
var _language = require("../../language/language");
const blendBrushUi = function() {
    const brushInterface = {
        image: (0, _brushBlendSvgDefault.default),
        tooltip: (0, _language.LANG)("brush-blend"),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        }
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-blend");
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement("div"); // the gui
        const brush = new (0, _brushes.brushes).BlendBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: 58,
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                }
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                curve: brushInterface.opacitySlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            const blendingSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-blending"),
                width: 225,
                height: 30,
                min: 0,
                max: 1,
                value: brush.getBlending(),
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: function(val) {
                    brush.setBlending(val);
                }
            });
            blendingSlider.getElement().style.marginTop = "10px";
            const pressureSizeToggle = (0, _createPenPressureToggle.createPenPressureToggle)(true, function(b) {
                brush.setSizePressure(b);
            });
            const pressureOpacityToggle = (0, _createPenPressureToggle.createPenPressureToggle)(false, function(b) {
                brush.setOpacityPressure(b);
            });
            const lockAlphaToggle = new (0, _checkbox.Checkbox)({
                init: brush.getLockAlpha(),
                label: (0, _language.LANG)("lock-alpha"),
                callback: function(b) {
                    brush.setLockAlpha(b);
                },
                doHighlight: true,
                title: (0, _language.LANG)("lock-alpha-title"),
                css: {
                    marginTop: "10px",
                    display: "inline-block"
                }
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginBottom: "10px"
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center"
                }
            }), blendingSlider.getElement(), lockAlphaToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p, isCoalesced) {
            brush.goLine(x, y, p, isCoalesced);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","../ui/components/create-pen-pressure-toggle":"4cmBB","./brushes-consts":"dlABn","../ui/components/checkbox":"8fYiz","../brushes/brushes":"8eOZC","../history/kl-history":"klzEn","../ui/components/kl-slider":"4hcvv","/src/app/img/ui/brush-blend.svg":"beaRX","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"beaRX":[function(require,module,exports) {
module.exports = require("a604f8e577a5fc4d").getBundleURL("d3gnI") + "brush-blend.bc748f1f.svg" + "?" + Date.now();

},{"a604f8e577a5fc4d":"lgJ39"}],"cBnfe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "sketchyBrushUi", ()=>sketchyBrushUi);
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/components/kl-slider");
var _brushSketchyPng = require("/src/app/img/ui/brush-sketchy.png");
var _brushSketchyPngDefault = parcelHelpers.interopDefault(_brushSketchyPng);
var _language = require("../../language/language");
var _bb = require("../../bb/bb");
const sketchyBrushUi = function() {
    const brushInterface = {
        image: (0, _brushSketchyPngDefault.default),
        tooltip: (0, _language.LANG)("brush-sketchy"),
        sizeSlider: {
            min: 0.5,
            max: 10
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        }
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-sketchy");
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement("div"); // the gui
        const brush = new (0, _brushes.brushes).SketchyBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 250,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize() * 2,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: function(val) {
                    brush.setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 250,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            const blendSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-blending"),
                width: 250,
                height: 30,
                min: 0,
                max: 1,
                value: brush.getBlending(),
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: function(val) {
                    brush.setBlending(val);
                }
            });
            const scaleSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-sketchy-scale"),
                width: 250,
                height: 30,
                min: 1,
                max: 20,
                value: brush.getScale(),
                eventResMs: (0, _brushesConsts.eventResMs),
                onChange: function(val) {
                    brush.setScale(val);
                }
            });
            opacitySlider.getElement().style.marginTop = "10px";
            blendSlider.getElement().style.marginTop = "10px";
            scaleSlider.getElement().style.marginTop = "10px";
            div.append(sizeSlider.getElement(), opacitySlider.getElement(), blendSlider.getElement(), scaleSlider.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, pressure) {
            brush.startLine(x, y, pressure);
        };
        this.goLine = function(x, y, pressure) {
            brush.goLine(x, y, pressure, undefined);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getSeed = function() {
            return parseInt("" + brush.getSeed());
        };
        this.setSeed = function(s) {
            brush.setSeed(parseInt("" + s));
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../brushes/brushes":"8eOZC","./brushes-consts":"dlABn","../history/kl-history":"klzEn","../ui/components/kl-slider":"4hcvv","/src/app/img/ui/brush-sketchy.png":"4EIzQ","../../language/language":"iiYGN","../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4EIzQ":[function(require,module,exports) {
module.exports = require("4e5182c7689273b9").getBundleURL("d3gnI") + "brush-sketchy.609fadbe.png" + "?" + Date.now();

},{"4e5182c7689273b9":"lgJ39"}],"h6rIQ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "pixelBrushUi", ()=>pixelBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _checkbox = require("../ui/components/checkbox");
var _klSlider = require("../ui/components/kl-slider");
var _createPenPressureToggle = require("../ui/components/create-pen-pressure-toggle");
var _brushPixelSvg = require("/src/app/img/ui/brush-pixel.svg");
var _brushPixelSvgDefault = parcelHelpers.interopDefault(_brushPixelSvg);
var _language = require("../../language/language");
const pixelBrushUi = function() {
    const brushInterface = {
        image: (0, _brushPixelSvgDefault.default),
        tooltip: (0, _language.LANG)("brush-pixel"),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        }
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-pixel");
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement("div"); // the gui
        const brush = new (0, _brushes.brushes).PixelBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        const lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: brush.getLockAlpha(),
            label: (0, _language.LANG)("lock-alpha"),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: (0, _language.LANG)("lock-alpha-title"),
            css: {
                marginRight: "10px"
            }
        });
        const eraserToggle = new (0, _checkbox.Checkbox)({
            init: brush.getIsEraser(),
            label: (0, _language.LANG)("eraser"),
            callback: function(b) {
                brush.setIsEraser(b);
            },
            css: {
                marginRight: "10px"
            }
        });
        const ditherToggle = new (0, _checkbox.Checkbox)({
            init: brush.getUseDither(),
            label: (0, _language.LANG)("brush-pixel-dither"),
            callback: function(b) {
                brush.setUseDither(b);
            }
        });
        const spacingSpline = new (0, _bb.BB).SplineInterpolator([
            [
                0.5,
                0.45
            ],
            [
                100,
                4
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(spacingSpline.interpolate(size) / size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                }
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brushInterface.opacitySlider.max,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            const pressureSizeToggle = (0, _createPenPressureToggle.createPenPressureToggle)(true, function(b) {
                brush.sizePressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginBottom: "10px"
                }
            }), opacitySlider.getElement());
            const toggleRow = (0, _bb.BB).el({
                parent: div,
                css: {
                    display: "flex",
                    marginTop: "10px"
                }
            });
            toggleRow.append(lockAlphaToggle.getElement(), eraserToggle.getElement(), ditherToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size * 2);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity * 100);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function(x, y) {
            brush.endLine(x, y);
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.toggleEraser = ()=>{
            eraserToggle.setValue(!eraserToggle.getValue());
            brush.setIsEraser(eraserToggle.getValue());
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","../brushes/brushes":"8eOZC","./brushes-consts":"dlABn","../history/kl-history":"klzEn","../ui/components/checkbox":"8fYiz","../ui/components/kl-slider":"4hcvv","../ui/components/create-pen-pressure-toggle":"4cmBB","/src/app/img/ui/brush-pixel.svg":"5VAaY","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5VAaY":[function(require,module,exports) {
module.exports = require("4b22a02b2c0a765a").getBundleURL("d3gnI") + "brush-pixel.cebba447.svg" + "?" + Date.now();

},{"4b22a02b2c0a765a":"lgJ39"}],"fVvBI":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eraserBrushUi", ()=>eraserBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/components/kl-slider");
var _createPenPressureToggle = require("../ui/components/create-pen-pressure-toggle");
var _checkbox = require("../ui/components/checkbox");
var _brushEraserSvg = require("/src/app/img/ui/brush-eraser.svg");
var _brushEraserSvgDefault = parcelHelpers.interopDefault(_brushEraserSvg);
var _language = require("../../language/language");
const eraserBrushUi = function() {
    const brushInterface = {
        image: (0, _brushEraserSvgDefault.default),
        tooltip: (0, _language.LANG)("eraser") + " [E]",
        sizeSlider: {
            min: 0.5,
            max: 200,
            curve: (0, _bb.BB).quadraticSplineInput(0.5, 200, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        }
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("eraser") + " [E]";
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement("div"); // the gui
        const brush = new (0, _brushes.brushes).EraserBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        let isTransparentBg = false;
        function setSize(size) {
            brush.setSize(size);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: 30,
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brushInterface.opacitySlider.max,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            const pressureSizeToggle = (0, _createPenPressureToggle.createPenPressureToggle)(true, function(b) {
                brush.sizePressure(b);
            });
            const pressureOpacityToggle = (0, _createPenPressureToggle.createPenPressureToggle)(false, function(b) {
                brush.opacityPressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginBottom: "10px"
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center"
                }
            }));
            const transparencyToggle = new (0, _checkbox.Checkbox)({
                init: false,
                label: (0, _language.LANG)("brush-eraser-transparent-bg"),
                callback: function(b) {
                    isTransparentBg = b;
                    brush.setTransparentBG(b);
                },
                css: {
                    marginTop: "10px"
                }
            });
            div.append(transparencyToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.isDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function() {};
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.getIsTransparentBg = function() {
            return isTransparentBg;
        };
        this.isDrawing = function() {
            return brush.isDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","../brushes/brushes":"8eOZC","./brushes-consts":"dlABn","../history/kl-history":"klzEn","../ui/components/kl-slider":"4hcvv","../ui/components/create-pen-pressure-toggle":"4cmBB","../ui/components/checkbox":"8fYiz","/src/app/img/ui/brush-eraser.svg":"1azNu","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1azNu":[function(require,module,exports) {
module.exports = require("e07a7d50cc48001e").getBundleURL("d3gnI") + "brush-eraser.a779dd09.svg" + "?" + Date.now();

},{"e07a7d50cc48001e":"lgJ39"}],"7smKi":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "smudgeBrushUi", ()=>smudgeBrushUi);
var _bb = require("../../bb/bb");
var _brushes = require("../brushes/brushes");
var _brushesConsts = require("./brushes-consts");
var _klHistory = require("../history/kl-history");
var _checkbox = require("../ui/components/checkbox");
var _klSlider = require("../ui/components/kl-slider");
var _createPenPressureToggle = require("../ui/components/create-pen-pressure-toggle");
var _brushSmudgeSvg = require("/src/app/img/ui/brush-smudge.svg");
var _brushSmudgeSvgDefault = parcelHelpers.interopDefault(_brushSmudgeSvg);
var _language = require("../../language/language");
const smudgeBrushUi = function() {
    const brushInterface = {
        image: (0, _brushSmudgeSvgDefault.default),
        tooltip: (0, _language.LANG)("brush-smudge"),
        sizeSlider: {
            min: 0.5,
            max: 100,
            curve: (0, _bb.BB).quadraticSplineInput(0.5, 100, 0.1)
        },
        opacitySlider: {
            min: 0.01,
            max: 1,
            curve: [
                [
                    0,
                    0.01
                ],
                [
                    0.5,
                    0.3
                ],
                [
                    1,
                    1
                ]
            ]
        }
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-smudge");
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement("div"); // the gui
        const brush = new (0, _brushes.brushes).SmudgeBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        const lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: brush.getLockAlpha(),
            label: (0, _language.LANG)("lock-alpha"),
            callback: function(b) {
                brush.setLockAlpha(b);
            },
            doHighlight: true,
            title: (0, _language.LANG)("lock-alpha-title")
        });
        const spacingSpline = new (0, _bb.BB).SplineInterpolator([
            [
                0,
                15
            ],
            [
                8,
                7
            ],
            [
                14,
                4
            ],
            [
                30,
                3
            ],
            [
                50,
                2.7
            ],
            [
                100,
                2
            ]
        ]);
        function setSize(size) {
            brush.setSize(size);
            brush.setSpacing(Math.max(2, spacingSpline.interpolate(size)) / 15);
        }
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 225,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 10) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 225,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                curve: brushInterface.opacitySlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            const pressureSizeToggle = (0, _createPenPressureToggle.createPenPressureToggle)(false, function(b) {
                brush.sizePressure(b);
            });
            const pressureOpacityToggle = (0, _createPenPressureToggle.createPenPressureToggle)(false, function(b) {
                brush.opacityPressure(b);
            });
            div.append((0, _bb.BB).el({
                content: [
                    sizeSlider.getElement(),
                    pressureSizeToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center",
                    marginBottom: "10px"
                }
            }), (0, _bb.BB).el({
                content: [
                    opacitySlider.getElement(),
                    pressureOpacityToggle
                ],
                css: {
                    display: "flex",
                    justifyContent: "space-between",
                    alignItems: "center"
                }
            }));
            const bottomRow = (0, _bb.BB).el({
                parent: div,
                css: {
                    marginTop: "10px"
                }
            });
            bottomRow.append(lockAlphaToggle.getElement());
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing()) sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y, p);
        };
        this.goLine = function(x, y, p) {
            brush.goLine(x, y, p);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","../brushes/brushes":"8eOZC","./brushes-consts":"dlABn","../history/kl-history":"klzEn","../ui/components/checkbox":"8fYiz","../ui/components/kl-slider":"4hcvv","../ui/components/create-pen-pressure-toggle":"4cmBB","/src/app/img/ui/brush-smudge.svg":"7adRs","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7adRs":[function(require,module,exports) {
module.exports = require("e184a5bfc696828").getBundleURL("d3gnI") + "brush-smudge.0d4a0e17.svg" + "?" + Date.now();

},{"e184a5bfc696828":"lgJ39"}],"cklS9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "chemyBrushUi", ()=>chemyBrushUi);
var _bb = require("../../bb/bb");
var _brushesConsts = require("./brushes-consts");
var _checkbox = require("../ui/components/checkbox");
var _brushes = require("../brushes/brushes");
var _klHistory = require("../history/kl-history");
var _klSlider = require("../ui/components/kl-slider");
var _brushChemySvg = require("/src/app/img/ui/brush-chemy.svg");
var _brushChemySvgDefault = parcelHelpers.interopDefault(_brushChemySvg);
var _options = require("../ui/components/options");
var _boxToggle = require("../ui/components/box-toggle");
var _language = require("../../language/language");
const chemyBrushUi = function() {
    const brushInterface = {
        image: (0, _brushChemySvgDefault.default),
        tooltip: (0, _language.LANG)("brush-chemy"),
        sizeSlider: {
            min: 0.25,
            max: 25,
            curve: (0, _bb.BB).quadraticSplineInput(0.25, 25, 0.1),
            isDisabled: true
        },
        opacitySlider: {
            min: 0.01,
            max: 1
        }
    };
    (0, _language.languageStrings).subscribe(()=>{
        brushInterface.tooltip = (0, _language.LANG)("brush-chemy");
    });
    brushInterface.Ui = function(p) {
        const div = document.createElement("div"); // the gui
        const brush = new (0, _brushes.brushes).ChemyBrush();
        brush.setHistory((0, _klHistory.klHistory));
        p.onSizeChange(brush.getSize());
        let sizeSlider;
        let opacitySlider;
        function setSize(size) {
            brush.setSize(size);
        }
        let eraserToggle;
        function init() {
            sizeSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("brush-size"),
                width: 250,
                height: 30,
                min: brushInterface.sizeSlider.min,
                max: brushInterface.sizeSlider.max,
                value: brush.getSize(),
                curve: brushInterface.sizeSlider.curve,
                eventResMs: (0, _brushesConsts.eventResMs),
                isEnabled: brush.getMode() === "stroke",
                toDisplayValue: (val)=>val * 2,
                toValue: (displayValue)=>displayValue / 2,
                onChange: (val)=>{
                    setSize(val);
                    p.onSizeChange(val);
                },
                formatFunc: (displayValue)=>{
                    if (displayValue < 5) return (0, _bb.BB).round(displayValue, 1);
                    else return Math.round(displayValue);
                },
                manualInputRoundDigits: 1
            });
            opacitySlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("opacity"),
                width: 250,
                height: 30,
                min: brushInterface.opacitySlider.min,
                max: brushInterface.opacitySlider.max,
                value: brush.getOpacity(),
                eventResMs: (0, _brushesConsts.eventResMs),
                toDisplayValue: (val)=>val * 100,
                toValue: (displayValue)=>displayValue / 100,
                onChange: (val)=>{
                    brush.setOpacity(val);
                    p.onOpacityChange(val);
                }
            });
            (0, _bb.BB).css(opacitySlider.getElement(), {
                marginTop: "10px"
            });
            eraserToggle = new (0, _checkbox.Checkbox)({
                init: brush.getIsEraser(),
                label: (0, _language.LANG)("eraser"),
                callback: function(b) {
                    brush.setIsEraser(b);
                },
                css: {
                    marginTop: "10px",
                    marginLeft: "10px"
                }
            });
            const lockAlphaToggle = new (0, _checkbox.Checkbox)({
                init: brush.getLockAlpha(),
                label: (0, _language.LANG)("lock-alpha"),
                callback: function(b) {
                    brush.setLockAlpha(b);
                },
                doHighlight: true,
                title: (0, _language.LANG)("lock-alpha-title"),
                css: {
                    marginTop: "10px"
                }
            });
            const toggleRow = (0, _bb.BB).el({
                css: {
                    display: "flex",
                    marginTop: "10px"
                }
            });
            const iconSize = 35;
            const padding = 8;
            const actualIconSize = iconSize - padding * 2;
            const halfSize = actualIconSize / 2;
            const modeOptions = new (0, _options.Options)({
                optionArr: [
                    {
                        id: "fill",
                        label: (0, _bb.BB).createSvg({
                            class: "dark-invert",
                            elementType: "svg",
                            width: iconSize + "",
                            height: iconSize + "",
                            childrenArr: [
                                {
                                    elementType: "path",
                                    fill: "#000",
                                    style: `transform-origin: 0 0; transform: translate(-0.5px, -0.5px) scale(${actualIconSize}, ${actualIconSize}) translate(0.5px, 0.5px)`,
                                    d: "M 0,0 C 1.5,0 -0.5,1 1,1"
                                }
                            ]
                        }),
                        title: (0, _language.LANG)("brush-chemy-fill")
                    },
                    {
                        id: "stroke",
                        label: (0, _bb.BB).createSvg({
                            class: "dark-invert",
                            elementType: "svg",
                            width: iconSize + "",
                            height: iconSize + "",
                            childrenArr: [
                                {
                                    elementType: "path",
                                    fill: "none",
                                    stroke: "#000",
                                    style: `stroke-width: 0.12px; transform-origin: 0 0; transform: translate(-0.5px, -0.5px) scale(${actualIconSize}, ${actualIconSize}) translate(0.5px, 0.5px)`,
                                    d: "M 0,0 C 1.5,0 -0.5,1 1,1"
                                }
                            ]
                        }),
                        title: (0, _language.LANG)("brush-chemy-stroke")
                    }
                ],
                initId: brush.getMode(),
                onChange: (id)=>{
                    brush.setMode(id);
                    brushInterface.sizeSlider.isDisabled = brush.getMode() === "fill";
                    sizeSlider.setIsEnabled(!brushInterface.sizeSlider.isDisabled);
                    const brushSize = brush.getSize();
                    sizeSlider.setValue(brushSize);
                    p.onSizeChange(brushSize);
                    p.onConfigChange();
                }
            });
            const mirrorXToggle = new (0, _boxToggle.BoxToggle)({
                label: (0, _bb.BB).createSvg({
                    class: "dark-invert",
                    elementType: "svg",
                    width: iconSize + "",
                    height: iconSize + "",
                    childrenArr: [
                        {
                            elementType: "path",
                            fill: "none",
                            stroke: "#000",
                            style: "stroke-width: 1px",
                            d: `M ${halfSize + padding},${padding} ${halfSize + padding},${actualIconSize + padding}`
                        }
                    ]
                }),
                title: (0, _language.LANG)("brush-chemy-mirror-x"),
                init: brush.getXSymmetry(),
                onChange: (b)=>{
                    brush.setXSymmetry(b);
                }
            });
            const mirrorYToggle = new (0, _boxToggle.BoxToggle)({
                label: (0, _bb.BB).createSvg({
                    class: "dark-invert",
                    elementType: "svg",
                    width: iconSize + "",
                    height: iconSize + "",
                    childrenArr: [
                        {
                            elementType: "path",
                            fill: "none",
                            stroke: "#000",
                            style: "stroke-width: 1px",
                            d: `M ${padding},${halfSize + padding} ${actualIconSize + padding},${halfSize + padding}`
                        }
                    ]
                }),
                title: (0, _language.LANG)("brush-chemy-mirror-y"),
                init: brush.getYSymmetry(),
                onChange: (b)=>{
                    brush.setYSymmetry(b);
                }
            });
            const gradientToggle = new (0, _boxToggle.BoxToggle)({
                label: (0, _bb.BB).createSvg({
                    class: "dark-invert",
                    elementType: "svg",
                    width: iconSize + "",
                    height: iconSize + "",
                    childrenArr: [
                        {
                            elementType: "defs",
                            childrenArr: [
                                {
                                    elementType: "linearGradient",
                                    id: "gradient",
                                    x1: "0",
                                    y1: "0",
                                    x2: "0",
                                    y2: "1",
                                    childrenArr: [
                                        {
                                            elementType: "stop",
                                            offset: "0%",
                                            "stop-color": "rgba(0,0,0,0)"
                                        },
                                        {
                                            elementType: "stop",
                                            offset: "100%",
                                            "stop-color": "rgba(0,0,0,1)"
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            elementType: "rect",
                            fill: "url('#gradient')",
                            x: "" + padding,
                            y: "" + padding,
                            width: "" + actualIconSize,
                            height: "" + actualIconSize
                        }
                    ]
                }),
                title: (0, _language.LANG)("brush-chemy-gradient"),
                init: brush.getGradient(),
                onChange: (b)=>{
                    brush.setGradient(b);
                }
            });
            (0, _bb.BB).css(mirrorXToggle.getElement(), {
                marginLeft: "10px"
            });
            {
                const margin = {
                    marginLeft: "4px"
                };
                (0, _bb.BB).css(mirrorYToggle.getElement(), margin);
                (0, _bb.BB).css(gradientToggle.getElement(), margin);
            }
            toggleRow.append(modeOptions.getElement(), mirrorXToggle.getElement(), mirrorYToggle.getElement(), gradientToggle.getElement());
            div.append(sizeSlider.getElement(), opacitySlider.getElement(), toggleRow, (0, _bb.BB).el({
                content: [
                    lockAlphaToggle.getElement(),
                    eraserToggle.getElement()
                ],
                css: {
                    display: "flex"
                }
            }));
        }
        init();
        this.increaseSize = function(f) {
            if (!brush.getIsDrawing() && brush.getMode() === "stroke") sizeSlider.changeSliderValue(f);
        };
        this.decreaseSize = function(f) {
            if (!brush.getIsDrawing() && brush.getMode() === "stroke") sizeSlider.changeSliderValue(-f);
        };
        this.getSize = function() {
            return brush.getSize();
        };
        this.setSize = function(size) {
            setSize(size);
            sizeSlider.setValue(size);
        };
        this.getOpacity = function() {
            return brush.getOpacity();
        };
        this.setOpacity = function(opacity) {
            brush.setOpacity(opacity);
            opacitySlider.setValue(opacity);
        };
        this.setColor = function(c) {
            brush.setColor(c);
        };
        this.setContext = function(c) {
            brush.setContext(c);
        };
        this.startLine = function(x, y, p) {
            brush.startLine(x, y);
        };
        this.goLine = function(x, y, p, isCoalesced) {
            brush.goLine(x, y);
        };
        this.endLine = function() {
            brush.endLine();
        };
        this.getBrush = function() {
            return brush;
        };
        this.isDrawing = function() {
            return brush.getIsDrawing();
        };
        this.toggleEraser = ()=>{
            eraserToggle.setValue(!eraserToggle.getValue());
            brush.setIsEraser(eraserToggle.getValue());
        };
        this.getElement = function() {
            return div;
        };
    };
    return brushInterface;
}();

},{"../../bb/bb":"dcQKo","./brushes-consts":"dlABn","../ui/components/checkbox":"8fYiz","../brushes/brushes":"8eOZC","../history/kl-history":"klzEn","../ui/components/kl-slider":"4hcvv","/src/app/img/ui/brush-chemy.svg":"5qbZG","../ui/components/options":"hNLP6","../ui/components/box-toggle":"aQOIq","../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5qbZG":[function(require,module,exports) {
module.exports = require("fbf0499c98eff602").getBundleURL("d3gnI") + "brush-chemy.2ccbdc42.svg" + "?" + Date.now();

},{"fbf0499c98eff602":"lgJ39"}],"2luNL":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showIframeModal", ()=>showIframeModal);
var _bb = require("../../../bb/bb");
var _dynamicModal = require("./base/dynamic-modal");
var _language = require("../../../language/language");
function showIframeModal(url, isEmbed) {
    // window very small, modal might look bad
    if (!isEmbed && (window.innerHeight < 500 || window.innerWidth < 700)) {
        window.open(url);
        return;
    }
    const iframe = (0, _bb.BB).el({
        tagName: "iframe",
        custom: {
            src: url
        },
        css: {
            width: "100%",
            height: "100%",
            opacity: "0"
        }
    });
    setTimeout(()=>{
        iframe.style.opacity = ""; // fallback
    }, 500);
    const titleEl = (0, _bb.BB).el();
    let linkEl;
    if (!isEmbed) {
        linkEl = (0, _bb.BB).el({
            tagName: "a",
            parent: titleEl,
            content: (0, _language.LANG)("modal-new-tab"),
            custom: {
                href: "help",
                target: "_blank"
            },
            onClick: function() {
                popup.close();
            }
        });
        iframe.onload = ()=>{
            if (linkEl && iframe.contentWindow) (0, _bb.BB).setAttributes(linkEl, {
                href: "" + iframe.contentWindow.location
            });
            iframe.style.opacity = "";
        };
    }
    const popup = new (0, _dynamicModal.DynamicModal)({
        title: titleEl,
        content: iframe,
        width: 880,
        isMaxHeight: true,
        onClose: ()=>{
            if (linkEl) {
                iframe.src = "about:blank";
                (0, _bb.BB).destroyEl(linkEl);
                linkEl = undefined;
            }
        }
    });
}

},{"../../../bb/bb":"dcQKo","./base/dynamic-modal":"52d4a","../../../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7SCtU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "RadioList", ()=>RadioList);
var _bb = require("../../../bb/bb");
class RadioList {
    constructor({ name, init, items, ignoreFocus }){
        this.inputs = [];
        this.el = (0, _bb.BB).el({
            className: "kl-radio"
        });
        items.forEach((item)=>{
            const label = (0, _bb.BB).el({
                tagName: "label"
            });
            const input = (0, _bb.BB).el({
                tagName: "input",
                parent: label,
                custom: {
                    name: name,
                    value: item.value,
                    type: "radio"
                }
            });
            if (ignoreFocus) input.setAttribute("data-ignore-focus", "true");
            if (init === item.value) input.checked = true;
            label.append(item.label);
            this.el.append(label);
            this.inputs.push(input);
        });
    }
    getValue() {
        for(let i = 0; i < this.inputs.length; i++){
            if (this.inputs[i].checked) return this.inputs[i].value;
        }
        return null;
    }
    getElement() {
        return this.el;
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"9u5bD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "BrowserStorageUi", ()=>BrowserStorageUi);
var _bb = require("../../../bb/bb");
var _removeLayerSvg = require("/src/app/img/ui/remove-layer.svg");
var _removeLayerSvgDefault = parcelHelpers.interopDefault(_removeLayerSvg);
var _showIframeModal = require("../modals/show-iframe-modal");
var _kl = require("../../kl");
var _language = require("../../../language/language");
var _theme = require("../../../theme/theme");
class BrowserStorageUi {
    updateAge() {
        if (!this.timestamp) return;
        let age = new Date().getTime() - this.timestamp;
        let ageStr;
        age = Math.floor(age / 1000 / 60);
        ageStr = (0, _language.LANG)("file-storage-min-ago").replace("{x}", "" + age);
        if (age > 60) {
            age = Math.floor(age / 60);
            ageStr = (0, _language.LANG)("file-storage-hours-ago").replace("{x}", "" + age);
            if (age > 24) {
                age = Math.floor(age / 24);
                ageStr = (0, _language.LANG)("file-storage-days-ago").replace("{x}", "" + age);
                if (age > 31) ageStr = (0, _language.LANG)("file-storage-month-ago");
            }
        }
        this.ageEl.textContent = ageStr;
    }
    resetButtons() {
        if (this.timestamp) {
            this.storeButtonEl.textContent = (0, _language.LANG)("file-storage-overwrite");
            this.storeButtonEl.disabled = false;
            this.clearButtonEl.disabled = false;
        } else {
            this.storeButtonEl.textContent = (0, _language.LANG)("file-storage-store");
            this.storeButtonEl.disabled = false;
            this.clearButtonEl.disabled = true;
        }
    }
    updateThumb(timestamp, thumbnail) {
        this.timestamp = timestamp;
        this.thumbnail = thumbnail;
        if (this.timestamp && thumbnail) {
            thumbnail.classList.add("kl-storage-preview__im");
            this.previewEl.innerHTML = "";
            this.updateAge();
            this.previewEl.append(thumbnail, this.ageEl);
        } else this.previewEl.innerHTML = (0, _language.LANG)("file-storage-empty");
        this.resetButtons();
    }
    async store() {
        this.storeButtonEl.textContent = (0, _language.LANG)("file-storage-storing");
        this.storeButtonEl.disabled = true;
        this.clearButtonEl.disabled = true;
        await new Promise((resolve)=>{
            setTimeout(()=>resolve(null), 20);
        });
        try {
            await this.projectStore.store(this.getProject());
            this.saveReminder.reset();
        } catch (e) {
            this.resetButtons();
            (0, _kl.KL).popup({
                target: this.klRootEl,
                type: "error",
                message: [
                    `${(0, _language.LANG)("file-storage-failed-1")}<ul>`,
                    `<li>${(0, _language.LANG)("file-storage-failed-2")}</li>`,
                    `<li>${(0, _language.LANG)("file-storage-failed-3")}</li>`,
                    `<li>${(0, _language.LANG)("file-storage-failed-4")}</li>`,
                    "</ul>"
                ].join(""),
                buttons: [
                    "Ok"
                ]
            });
            setTimeout(()=>{
                throw new Error("storage-ui: failed to store browser storage, " + e);
            }, 0);
        }
    }
    async clear() {
        this.storeButtonEl.disabled = true;
        this.clearButtonEl.disabled = true;
        try {
            await this.projectStore.clear();
        } catch (e) {
            this.resetButtons();
            (0, _kl.KL).popup({
                target: this.klRootEl,
                type: "error",
                message: (0, _language.LANG)("file-storage-failed-clear"),
                buttons: [
                    "Ok"
                ]
            });
            setTimeout(()=>{
                throw new Error("storage-ui: failed to clear browser storage, " + e);
            }, 0);
        }
    }
    constructor(projectStore, getProject, saveReminder, klRootEl, options){
        this.projectStore = projectStore;
        this.getProject = getProject;
        this.saveReminder = saveReminder;
        this.klRootEl = klRootEl;
        this.options = options;
        this.previewEl = {};
        this.infoEl = {};
        this.ageEl = {};
        this.storeButtonEl = {};
        this.clearButtonEl = {};
        this.storeListener = {};
        this.updateCheckerboard = ()=>{};
        this.element = (0, _bb.BB).el({
            css: {
                display: "grid",
                gridTemplateColumns: "1fr 0fr",
                gridTemplateRows: "0fr 0fr 0fr",
                gap: "0 0",
                gridTemplateAreas: '"title title" "preview store" "preview clear"'
            }
        });
        const title = (0, _bb.BB).el({
            parent: this.element,
            content: (0, _language.LANG)("file-storage"),
            css: {
                gridArea: "title",
                display: "flex",
                margin: "-5px 0",
                gap: "5px"
            }
        });
        this.infoEl = (0, _bb.BB).el({
            parent: title,
            content: "?",
            className: "kl-info-btn",
            title: (0, _language.LANG)("file-storage-about"),
            onClick: ()=>{
                (0, _showIframeModal.showIframeModal)("./help/#help-browser-storage", false);
            }
        });
        if (this.projectStore.isBroken()) {
            (0, _bb.BB).el({
                parent: this.element,
                content: "\uD83D\uDD34 " + (0, _language.LANG)("file-storage-cant-access"),
                css: {
                    marginTop: "10px"
                }
            });
            return;
        }
        this.previewEl = (0, _bb.BB).el({
            parent: this.element,
            title: (0, _language.LANG)("file-storage-thumb-title"),
            className: "kl-storage-preview"
        });
        this.ageEl = (0, _bb.BB).el({
            css: {
                position: "absolute",
                right: "1px",
                bottom: "1px",
                width: "calc(100% - 2px)",
                textAlign: "center",
                background: "rgba(0,0,0,0.7)",
                color: "#fff",
                textSize: "13px"
            }
        });
        const btnCustom = options?.isFocusable ? {} : {
            tabIndex: "-1"
        };
        this.storeButtonEl = (0, _bb.BB).el({
            parent: this.element,
            tagName: "button",
            className: "grid-button",
            content: (0, _language.LANG)("file-storage-store"),
            css: {
                gridArea: "store"
            },
            custom: btnCustom,
            onClick: ()=>this.store()
        });
        this.clearButtonEl = (0, _bb.BB).el({
            parent: this.element,
            tagName: "button",
            className: "grid-button",
            content: '<img src="' + (0, _removeLayerSvgDefault.default) + '" height="20"/> ' + (0, _language.LANG)("file-storage-clear"),
            css: {
                gridArea: "clear"
            },
            custom: btnCustom,
            onClick: ()=>this.clear()
        });
        if (this.options?.hideClearButton) this.clearButtonEl.style.visibility = "hidden";
        this.storeListener = {
            onUpdate: (timestamp, thumbnail)=>{
                this.updateThumb(timestamp, thumbnail);
            }
        };
        this.projectStore.subscribe(this.storeListener);
        this.updateCheckerboard = ()=>{
            if (!this.thumbnail) return;
            (0, _bb.BB).css(this.thumbnail, {
                background: "url('" + (0, _bb.BB).createCheckerCanvas(4, (0, _theme.theme).isDark()).toDataURL("image/png") + "')"
            });
        };
        (0, _theme.theme).addIsDarkListener(this.updateCheckerboard);
        setInterval(()=>this.updateAge(), 60000);
        (async ()=>{
            try {
                const readResult = await this.projectStore.read();
                if (readResult) this.updateThumb(readResult.timestamp, readResult.thumbnail);
                else this.updateThumb();
            } catch (e) {
                setTimeout(()=>{
                    throw new Error("storage-ui: failed initial read browser storage, " + e);
                }, 0);
            }
        })();
    }
    getElement() {
        return this.element;
    }
    show() {
    // todo
    }
    hide() {
    // todo
    }
    destroy() {
        (0, _bb.BB).destroyEl(this.infoEl);
        (0, _bb.BB).destroyEl(this.storeButtonEl);
        (0, _bb.BB).destroyEl(this.clearButtonEl);
        (0, _theme.theme).removeIsDarkListener(this.updateCheckerboard);
        this.projectStore.unsubscribe(this.storeListener);
    }
}

},{"../../../bb/bb":"dcQKo","/src/app/img/ui/remove-layer.svg":"bxKFW","../modals/show-iframe-modal":"2luNL","../../kl":"8nmWp","../../../language/language":"iiYGN","../../../theme/theme":"4G3JB","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gZHsZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * simplified interface for storing projects into browser storage
 */ parcelHelpers.export(exports, "ProjectStore", ()=>ProjectStore);
var _projectConverter = require("./project-converter");
var _indexedDb = require("./indexed-db");
var _localStorage = require("../../bb/base/local-storage");
function makeAsync(nonAsyncFunc) {
    return new Promise((resolve, reject)=>{
        nonAsyncFunc(resolve, reject);
    });
}
class ProjectStore {
    async lowLevelStore(project) {
        await new Promise((resolve, reject)=>{
            (0, _indexedDb.storeKlProjectObj)(project, resolve, reject);
        });
    }
    async lowLevelRead() {
        return await makeAsync((0, _indexedDb.getKlProjectObj));
    }
    async lowLevelClear() {
        await makeAsync((0, _indexedDb.clear));
    }
    emit(timestamp, thumbnail) {
        this.listeners.forEach((item)=>{
            item.onUpdate(timestamp, thumbnail);
        });
    }
    updateTimestamp() {
        (0, _localStorage.LocalStorage).setItem("indexedDbUpdatedAt", "" + new Date().getTime());
    }
    // --- public ---
    constructor(){
        this.listeners = [];
        this.accessHasFailed = false;
        window.addEventListener("storage", (e)=>{
            if (e.key !== "indexedDbUpdatedAt" || this.listeners.length === 0) return;
            try {
                (async ()=>{
                    const readResult = await this.read();
                    if (readResult) this.emit(readResult.timestamp, readResult.thumbnail);
                    else this.emit();
                })();
            } catch (e) {
                if (e instanceof Error && e.message.indexOf("db-error") === 0) this.accessHasFailed = true;
            }
        });
    }
    async read() {
        let storageProject;
        try {
            storageProject = await this.lowLevelRead();
        } catch (e) {
            this.accessHasFailed = true;
            throw new Error("db-error: " + e);
        }
        if (!storageProject) return undefined;
        let result;
        try {
            result = await (0, _projectConverter.ProjectConverter).readStorageProject(storageProject);
        } catch (e) {
            throw new Error("format-error: " + e);
        }
        return result;
    }
    async store(project) {
        try {
            const storageProject = (0, _projectConverter.ProjectConverter).createStorageProject(project);
            await this.lowLevelStore(storageProject);
        } catch (e) {
            this.accessHasFailed = true;
            throw new Error("db-error: " + e);
        }
        {
            // immediately test if it can be read
            const storageProject = await this.lowLevelRead();
            let readResult;
            try {
                readResult = await (0, _projectConverter.ProjectConverter).readStorageProject(storageProject);
            } catch (e) {
                await this.lowLevelClear();
                this.updateTimestamp();
                setTimeout(()=>this.emit(), 0);
                throw new Error("format-error: " + e);
            }
            this.updateTimestamp();
            setTimeout(()=>this.emit(readResult.timestamp, readResult.thumbnail), 0);
        }
    }
    async clear() {
        await this.lowLevelClear();
        this.updateTimestamp();
        setTimeout(()=>this.emit(), 0);
    }
    subscribe(listener) {
        if (this.listeners.includes(listener)) return;
        this.listeners.push(listener);
    }
    unsubscribe(listener) {
        for(let i = 0; i < this.listeners.length; i++)if (listener === this.listeners[i]) {
            this.listeners.splice(i, 1);
            return;
        }
    }
    isBroken() {
        return this.accessHasFailed;
    }
}

},{"./project-converter":"jp97c","./indexed-db":"eCGtt","../../bb/base/local-storage":"04p5O","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jp97c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * for:
 * - preparing project to be stored in ProjectStore
 * - reading a project that came out of the ProjectStore
 */ parcelHelpers.export(exports, "ProjectConverter", ()=>ProjectConverter);
var _bb = require("../../bb/bb");
var _drawProject = require("../canvas/draw-project");
var _base64ToBlob = require("./base-64-to-blob");
const thumbSize = 240;
function loadImage(blob) {
    return new Promise((resolve, reject)=>{
        const im = new Image();
        try {
            im.src = (0, _bb.BB).imageBlobToUrl(blob);
        } catch (e) {
            reject("imageBlobToUrl, " + (e instanceof Error ? e.message : ""));
            return;
        }
        im.onload = ()=>{
            URL.revokeObjectURL(im.src);
            resolve(im);
        };
        im.onabort = ()=>{
            reject("layer image failed loading");
        };
        im.onerror = ()=>{
            reject("layer image failed loading");
        };
    });
}
class ProjectConverter {
    static createThumbnail(project) {
        const size = (0, _bb.BB).fitInto(project.width, project.height, thumbSize, thumbSize);
        const factor = size.width / project.width;
        return (0, _drawProject.drawProject)(project, factor);
    }
    static createStorageProject(project) {
        return {
            id: 1,
            timestamp: new Date().getTime(),
            thumbnail: (0, _base64ToBlob.base64ToBlob)(ProjectConverter.createThumbnail(project).toDataURL("image/png")),
            width: project.width,
            height: project.height,
            layers: project.layers.map((item)=>{
                let blob;
                if (item.image instanceof HTMLCanvasElement) blob = (0, _base64ToBlob.base64ToBlob)(item.image.toDataURL("image/png"));
                else // todo image
                throw new Error("Not implemented");
                return {
                    name: item.name,
                    isVisible: item.isVisible,
                    opacity: item.opacity,
                    mixModeStr: item.mixModeStr,
                    blob
                };
            })
        };
    }
    static async readStorageProject(storageProject) {
        if (!storageProject.width || !storageProject.height || isNaN(storageProject.width) || isNaN(storageProject.height) || storageProject.width < 1 || storageProject.height < 1) throw new Error("readStorageProject invalid canvas size: " + storageProject.width + ", " + storageProject.height);
        const project = {
            width: storageProject.width,
            height: storageProject.height,
            layers: (await Promise.all(storageProject.layers.map((layer)=>loadImage(layer.blob)))).map((image, i)=>{
                const storageLayer = storageProject.layers[i];
                return {
                    name: storageLayer.name,
                    isVisible: "isVisible" in storageLayer ? storageLayer.isVisible : true,
                    opacity: storageLayer.opacity,
                    mixModeStr: storageLayer.mixModeStr,
                    image
                };
            })
        };
        let thumbnail;
        if (storageProject.thumbnail) thumbnail = await loadImage(storageProject.thumbnail);
        else thumbnail = ProjectConverter.createThumbnail(project);
        return {
            project: project,
            timestamp: storageProject.timestamp,
            thumbnail: thumbnail
        };
    }
}

},{"../../bb/bb":"dcQKo","../canvas/draw-project":"6Yf6D","./base-64-to-blob":"4JT2T","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4JT2T":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "base64ToBlob", ()=>base64ToBlob);
function base64ToBlob(base64Str) {
    const parts = base64Str.match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
    const binStr = atob(parts[3]);
    const buf = new ArrayBuffer(binStr.length);
    const view = new Uint8Array(buf);
    for(let i = 0; i < view.length; i++)view[i] = binStr.charCodeAt(i);
    return new Blob([
        view
    ], {
        "type": parts[1]
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3rIr5":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FileTab", ()=>FileTab);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
var _browserStorageUi = require("../components/browser-storage-ui");
var _language = require("../../../language/language");
var _newImageSvg = require("/src/app/img/ui/new-image.svg");
var _newImageSvgDefault = parcelHelpers.interopDefault(_newImageSvg);
var _exportSvg = require("/src/app/img/ui/export.svg");
var _exportSvgDefault = parcelHelpers.interopDefault(_exportSvg);
var _shareSvg = require("/src/app/img/ui/share.svg");
var _shareSvgDefault = parcelHelpers.interopDefault(_shareSvg);
var _uploadSvg = require("/src/app/img/ui/upload.svg");
var _uploadSvgDefault = parcelHelpers.interopDefault(_uploadSvg);
var _importSvg = require("/src/app/img/ui/import.svg");
var _importSvgDefault = parcelHelpers.interopDefault(_importSvg);
var _copySvg = require("/src/app/img/ui/copy.svg");
var _copySvgDefault = parcelHelpers.interopDefault(_copySvg);
class FileTab {
    constructor(klRootEl, projectStore, getProject, exportType, onExportTypeChange, onFileSelect, onSaveImageToComputer, onNewImage, onShareImage, onUpload, onCopyToClipboard, saveReminder){
        this.exportType = exportType;
        this.rootEl = document.createElement("div");
        const asyncCreation = ()=>{
            const fileMenu = document.createElement("div");
            const newButton = document.createElement("button");
            const saveButton = document.createElement("button");
            const shareButton = document.createElement("button");
            const uploadImgurButton = document.createElement("button");
            const clipboardButton = document.createElement("button");
            newButton.style.cssFloat = "left";
            (0, _bb.BB).css(saveButton, {
                cssFloat: "left",
                clear: "both",
                flexGrow: "1"
            });
            (0, _bb.BB).css(clipboardButton, {
                cssFloat: "left",
                clear: "both"
            });
            newButton.tabIndex = -1;
            saveButton.tabIndex = -1;
            shareButton.tabIndex = -1;
            uploadImgurButton.tabIndex = -1;
            clipboardButton.tabIndex = -1;
            newButton.innerHTML = `<img class="dark-no-invert" src='${0, _newImageSvgDefault.default}' alt='icon' height='20'/>${(0, _language.LANG)("file-new")}`;
            saveButton.innerHTML = `<img src='${0, _exportSvgDefault.default}' alt='icon' height='20'/>${(0, _language.LANG)("file-save")}`;
            shareButton.innerHTML = `<img src='${0, _shareSvgDefault.default}' alt='icon' height='20'/>${(0, _language.LANG)("file-share")}`;
            uploadImgurButton.innerHTML = `<img style='float:left' src='${0, _uploadSvgDefault.default}' height='20' alt='icon'/>${(0, _language.LANG)("file-upload")}`;
            clipboardButton.innerHTML = `<img src='${0, _copySvgDefault.default}' alt='icon' height='20'/>${(0, _language.LANG)("file-copy")}`;
            clipboardButton.title = (0, _language.LANG)("file-copy-title");
            newButton.className = "grid-button";
            saveButton.className = "grid-button";
            shareButton.className = "grid-button";
            uploadImgurButton.className = "grid-button";
            clipboardButton.className = "grid-button";
            const importWrapper = (0, _bb.BB).el({
                className: "grid-button",
                css: {
                    position: "relative",
                    cursor: "pointer",
                    cssFloat: "left"
                }
            });
            const innerMask = (0, _bb.BB).el({
                parent: importWrapper,
                css: {
                    width: "120px",
                    height: "28px",
                    overflow: "hidden",
                    cursor: "pointer",
                    position: "relative"
                }
            });
            this.importButton = (0, _bb.BB).el({
                tagName: "input",
                parent: innerMask,
                css: {
                    display: "none"
                }
            });
            this.importButton.tabIndex = -1;
            this.importButton.type = "file";
            this.importButton.multiple = true;
            this.importButton.accept = "image";
            this.importButton.size = 71;
            this.importButton.onchange = ()=>{
                if (!this.importButton) return;
                this.importButton.files && onFileSelect(this.importButton.files, "default");
                this.importButton.value = "";
            };
            const importFakeButton = (0, _bb.BB).el({
                tagName: "button",
                parent: importWrapper,
                content: "<img class=\"dark-no-invert\" style='float:left' height='20' src='" + (0, _importSvgDefault.default) + "' alt='icon'/>" + (0, _language.LANG)("file-import"),
                css: {
                    width: "120px",
                    display: "box",
                    position: "absolute",
                    left: "0",
                    top: "0",
                    cursor: "pointer"
                }
            });
            importFakeButton.tabIndex = -1;
            importFakeButton.onclick = ()=>this.importButton && this.importButton.click();
            // --- export filetype dropdown ---
            const exportTypeSelect = new (0, _kl.KL).Select({
                optionArr: [
                    [
                        "png",
                        "PNG"
                    ],
                    [
                        "psd",
                        "PSD"
                    ],
                    [
                        "layers",
                        (0, _language.LANG)("layers") + " (PNG)"
                    ]
                ],
                initValue: this.exportType,
                onChange: (val)=>{
                    this.exportType = val;
                    onExportTypeChange(this.exportType);
                    onSaveImageToComputer();
                },
                title: (0, _language.LANG)("file-format")
            });
            (0, _bb.BB).css(exportTypeSelect.getElement(), {
                width: "50%",
                height: "30px",
                marginTop: "10px",
                marginLeft: "10px"
            });
            newButton.onclick = onNewImage;
            saveButton.onclick = ()=>{
                onSaveImageToComputer();
            };
            shareButton.onclick = ()=>{
                shareButton.disabled = true;
                onShareImage(()=>{
                    shareButton.disabled = false;
                });
            };
            uploadImgurButton.onclick = ()=>onUpload();
            clipboardButton.onclick = ()=>{
                clipboardButton.blur();
                onCopyToClipboard();
            };
            const saveNote = (0, _bb.BB).el({
                className: "kl-toolspace-note",
                textContent: (0, _language.LANG)("file-no-autosave"),
                css: {
                    margin: "10px 10px 0 10px"
                }
            });
            const createSpacer = ()=>{
                const el = document.createElement("div");
                const clearer = document.createElement("div");
                const line = (0, _bb.BB).el({
                    className: "grid-hr"
                });
                el.append(clearer, line);
                (0, _bb.BB).css(clearer, {
                    clear: "both"
                });
                return el;
            };
            this.fileBrowserStorage = new (0, _browserStorageUi.BrowserStorageUi)(projectStore, getProject, saveReminder, klRootEl);
            (0, _bb.BB).css(this.fileBrowserStorage.getElement(), {
                //background: 'red',
                margin: "10px"
            });
            const saveRow = (0, _bb.BB).el({
                content: [
                    saveButton,
                    exportTypeSelect.getElement()
                ],
                className: "kl-file-save-row"
            });
            //actual structure
            (0, _bb.BB).append(fileMenu, [
                saveNote,
                newButton,
                importWrapper,
                (0, _bb.BB).el({
                    css: {
                        clear: "both"
                    }
                }),
                saveRow,
                clipboardButton,
                (0, _bb.BB).canShareFiles() ? shareButton : undefined,
                (0, _bb.BB).el({
                    css: {
                        clear: "both"
                    }
                }),
                createSpacer(),
                this.fileBrowserStorage.getElement(),
                createSpacer(),
                uploadImgurButton
            ]);
            this.rootEl.append(fileMenu);
        };
        setTimeout(asyncCreation, 1);
    }
    refresh() {}
    getElement() {
        return this.rootEl;
    }
    setIsVisible(isVisible) {
        if (isVisible) this.refresh();
    }
    triggerImport() {
        this.importButton && this.importButton.click();
    }
}

},{"../../../bb/bb":"dcQKo","../../kl":"8nmWp","../components/browser-storage-ui":"9u5bD","../../../language/language":"iiYGN","/src/app/img/ui/new-image.svg":"fjjGc","/src/app/img/ui/export.svg":"kaStO","/src/app/img/ui/share.svg":"eS7Vq","/src/app/img/ui/upload.svg":"7FGpE","/src/app/img/ui/import.svg":"aqqZd","/src/app/img/ui/copy.svg":"i6121","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7FGpE":[function(require,module,exports) {
module.exports = require("4013b1d45d79e2e").getBundleURL("d3gnI") + "upload.dde0fc68.svg" + "?" + Date.now();

},{"4013b1d45d79e2e":"lgJ39"}],"ftyCZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FilterTab", ()=>FilterTab);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
var _klHistory = require("../../history/kl-history");
var _language = require("../../../language/language");
var _sharedFx = require("../../../fx-canvas/shared-fx");
var _c = require("../../../bb/base/c");
class FilterTab {
    testHasWebGL() {
        return !!(0, _sharedFx.getSharedFx)();
    }
    constructor(klRootEl, klColorSlider, layerManager, klCanvasWorkspace, handUi, getCurrentColor, getKlMaxCanvasSize, getKlCanvas, getCurrentLayerCtx, isEmbed, statusOverlay){
        this.klRootEl = klRootEl;
        this.klColorSlider = klColorSlider;
        this.layerManager = layerManager;
        this.klCanvasWorkspace = klCanvasWorkspace;
        this.handUi = handUi;
        this.getCurrentColor = getCurrentColor;
        this.getKlMaxCanvasSize = getKlMaxCanvasSize;
        this.getKlCanvas = getKlCanvas;
        this.getCurrentLayerCtx = getCurrentLayerCtx;
        this.isEmbed = isEmbed;
        this.statusOverlay = statusOverlay;
        this.isInit = false;
        this.rootEl = document.createElement("div");
    }
    init() {
        const filters = (0, _kl.KL).filterLib;
        const buttons = [];
        if (!(0, _kl.KL).filterLibStatus.isLoaded) throw new Error("filters not loaded");
        const hasWebGL = this.testHasWebGL();
        if (!hasWebGL) {
            const note = (0, _bb.BB).el({
                parent: this.rootEl,
                className: "kl-toolspace-note",
                content: "Features disabled because WebGL is failing.",
                css: {
                    margin: "10px",
                    marginBottom: "0"
                }
            });
            const noteButton = (0, _bb.BB).el({
                parent: note,
                tagName: "button",
                textContent: "Learn More",
                css: {
                    marginLeft: "5px"
                }
            });
            noteButton.onclick = ()=>{
                (0, _kl.KL).popup({
                    target: this.klRootEl,
                    message: "<b>WebGL is not working</b>",
                    div: (0, _bb.BB).el({
                        content: `
See if your browser supports WebGL and has it enabled: <a href="https://get.webgl.org" target="_blank" rel="noopener noreferrer">get.webgl.org</a><br>
<br>
Recently (2023-05) a number of Chrome users on Chrome OS reported that WebGL fails, although it is enabled & supported.
This has been reported to Google.
`
                    }),
                    buttons: [
                        "Ok"
                    ],
                    clickOnEnter: "Ok"
                });
            };
        }
        const createButton = (filterKey)=>{
            const filter = filters[filterKey];
            const button = document.createElement("button");
            const buttonLabel = (0, _language.LANG)(filter.lang.button);
            const imClass = filter.darkNoInvert ? 'class="dark-no-invert"' : "";
            const im = "<img " + imClass + ' height="20" width="18" src="' + filter.icon + '" style="margin-right: 3px" alt="icon" />';
            button.innerHTML = im + buttonLabel;
            button.className = "grid-button grid-button--filter";
            (0, _bb.BB).css(button, {
                lineHeight: "20px",
                fontSize: "12px"
            });
            button.tabIndex = -1;
            const filterName = (0, _language.LANG)(filter.lang.name);
            let isEnabled = true;
            if (filter.webGL && !hasWebGL) isEnabled = false;
            if (isEnabled) button.onclick = ()=>{
                const dialogButtons = [
                    "Ok",
                    "Cancel"
                ];
                const finishedDialog = (result, filterDialog)=>{
                    if ("error" in filterDialog) return;
                    if (result == "Cancel") {
                        if (filterDialog.destroy) filterDialog.destroy();
                        return;
                    }
                    let input;
                    try {
                        input = filterDialog.getInput(); // also destroys
                    } catch (e) {
                        if (e.message.indexOf(".getInput is not a function") !== -1) throw "filterDialog.getInput is not a function, filter: " + filterName;
                        else throw e;
                    }
                    applyFilter(input);
                };
                if (!("apply" in filters[filterKey])) {
                    (0, _kl.KL).popup({
                        target: this.klRootEl,
                        message: "Application not fully loaded",
                        type: "error"
                    });
                    return;
                }
                const applyFilter = (input)=>{
                    const filterResult = filters[filterKey].apply({
                        context: this.getCurrentLayerCtx(),
                        klCanvas: this.getKlCanvas(),
                        history: (0, _klHistory.klHistory),
                        input: input
                    });
                    if (filterResult === false) (0, _kl.KL).popup({
                        target: this.klRootEl,
                        message: "Couldn't apply the edit action",
                        type: "error"
                    });
                    if (filters[filterKey].updatePos === true) {
                        this.klCanvasWorkspace.resetOrFitView();
                        this.handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
                    }
                    this.layerManager.update();
                };
                if (filters[filterKey].isInstant) {
                    button.blur();
                    applyFilter(null);
                    this.statusOverlay.out('"' + filterName + '" ' + (0, _language.LANG)("filter-applied"), true);
                } else {
                    const secondaryColorRGB = this.klColorSlider.getSecondaryRGB();
                    let filterDialog = undefined;
                    try {
                        filterDialog = filters[filterKey].getDialog({
                            context: this.getCurrentLayerCtx(),
                            klCanvas: this.getKlCanvas(),
                            maxWidth: this.getKlMaxCanvasSize(),
                            maxHeight: this.getKlMaxCanvasSize(),
                            currentColorRgb: {
                                r: this.getCurrentColor().r,
                                g: this.getCurrentColor().g,
                                b: this.getCurrentColor().b
                            },
                            secondaryColorRgb: {
                                r: secondaryColorRGB.r,
                                g: secondaryColorRGB.g,
                                b: secondaryColorRGB.b
                            }
                        });
                    } catch (e) {
                        setTimeout(()=>{
                            throw e;
                        });
                    }
                    if (!filterDialog || "error" in filterDialog) {
                        (0, _kl.KL).popup({
                            target: this.klRootEl,
                            message: filterDialog ? filterDialog.error : "Error: Could not perform action.",
                            type: "error"
                        });
                        return;
                    }
                    let closeFunc;
                    // Todo should move into getDialogParams
                    filterDialog.errorCallback = (e)=>{
                        (0, _kl.KL).popup({
                            target: this.klRootEl,
                            message: "Error: Could not perform action.",
                            type: "error"
                        });
                        setTimeout(()=>{
                            throw e;
                        }, 0);
                        closeFunc();
                    };
                    const style = {};
                    if ("width" in filterDialog) style.width = filterDialog.width + "px";
                    let title;
                    {
                        const els = [
                            (0, _c.c)("b", filterName)
                        ];
                        if (filter.lang.description !== undefined) els.push((0, _c.c)({
                            className: "kl-info-btn",
                            onClick: ()=>{
                                (0, _kl.KL).popup({
                                    target: this.klRootEl,
                                    message: (0, _language.LANG)(filter.lang.description)
                                });
                            },
                            title: (0, _language.LANG)(filter.lang.description),
                            noRef: true
                        }, "?"));
                        title = (0, _c.c)(",flex,gap-5", els);
                    }
                    (0, _kl.KL).popup({
                        target: this.klRootEl,
                        message: title,
                        div: filterDialog.element,
                        style: style,
                        buttons: dialogButtons,
                        clickOnEnter: "Ok",
                        callback: (result)=>{
                            finishedDialog(result, filterDialog);
                        },
                        closeFunc: (func)=>{
                            closeFunc = func;
                        }
                    });
                }
            };
            else button.disabled = true;
            buttons.push(button);
            return button;
        };
        const addGroup = (groupArr)=>{
            Object.entries(filters).forEach(([filterKey, filter])=>{
                if (!groupArr.includes(filterKey)) return;
                if (this.isEmbed && !filter.inEmbed) return;
                this.rootEl.append(createButton(filterKey));
            });
        };
        const groupA = [
            "cropExtend",
            "flip",
            "perspective",
            "resize",
            "rotate",
            "transform"
        ];
        const groupB = [
            "brightnessContrast",
            "curves",
            "distort",
            "hueSaturation",
            "invert",
            "tiltShift",
            "toAlpha",
            "blur",
            "unsharpMask"
        ];
        const groupC = [
            "grid",
            "noise",
            "pattern",
            "vanishPoint"
        ];
        addGroup(groupA);
        this.rootEl.append((0, _bb.BB).el({
            className: "grid-hr"
        }));
        addGroup(groupB);
        this.rootEl.append((0, _bb.BB).el({
            className: "grid-hr"
        }));
        addGroup(groupC);
        this.isInit = true;
    }
    getElement() {
        return this.rootEl;
    }
    show() {
        if (!this.isInit) this.init();
        this.rootEl.style.display = "block";
    }
    hide() {
        this.rootEl.style.display = "none";
    }
}

},{"../../../bb/bb":"dcQKo","../../kl":"8nmWp","../../history/kl-history":"klzEn","../../../language/language":"iiYGN","../../../fx-canvas/shared-fx":"oGCP8","../../../bb/base/c":"eg9k9","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"oGCP8":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getSharedFx", ()=>getSharedFx);
var _fxCanvas = require("./fx-canvas");
let failed = false;
let fx = null;
function getSharedFx() {
    // failed previously, don't need to try again.
    if (failed) return fx;
    if (!fx || fx._.gl.isContextLost()) try {
        fx = (0, _fxCanvas.fxCanvas)();
    } catch (e) {
        failed = true;
        fx = null;
        setTimeout(()=>{
            throw e;
        });
    }
    return fx;
}

},{"./fx-canvas":"7G2US","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7G2US":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "fxCanvas", ()=>fxCanvas);
var _brightnessContrast = require("./filters/brightness-contrast");
var _fxShader = require("./core/fx-shader");
var _gl = require("./core/gl");
var _fxTexture = require("./core/fx-texture");
var _curves = require("./filters/curves");
var _hueSaturation = require("./filters/hue-saturation");
var _noise = require("./filters/noise");
var _triangleBlur = require("./filters/triangle-blur");
var _tiltShift = require("./filters/tilt-shift");
var _matrixWarp = require("./filters/matrix-warp");
var _unsharpMask = require("./filters/unsharp-mask");
var _toAlpha = require("./filters/to-alpha");
var _invert = require("./filters/invert");
var _perspective = require("./filters/perspective");
var _unmultiplyAlpha = require("./filters/unmultiply-alpha");
var _distort = require("./filters/distort");
var _multiplyAlpha = require("./filters/multiply-alpha");
var _bb = require("../bb/bb");
const fxCanvas = function() {
    function wrapTexture(texture) {
        return {
            _: texture,
            loadContentsOf: function(element) {
                // Make sure that we're using the correct global WebGL context
                (0, _gl.setGl)(this._.gl);
                this._.loadContentsOf(element);
            },
            destroy: function() {
                // Make sure that we're using the correct global WebGL context
                (0, _gl.setGl)(this._.gl);
                this._.destroy();
            }
        };
    }
    function texture(element) {
        return wrapTexture((0, _fxTexture.FxTexture).fromElement(element));
    }
    function getTextureType() {
        let textureType = (0, _gl.gl).UNSIGNED_BYTE;
        // Go for floating point buffer textures if we can, it'll make the bokeh
        // filter look a lot better. Note that on Windows, ANGLE does not let you
        // render to a floating-point texture when linear filtering is enabled.
        // See http://crbug.com/172278 for more information.
        if ((0, _gl.gl).getExtension("WEBGL_color_buffer_float") && // firefox shows warning without this line
        (0, _gl.gl).getExtension("OES_texture_float") && (0, _gl.gl).getExtension("OES_texture_float_linear")) {
            const testTexture = new (0, _fxTexture.FxTexture)(100, 100, (0, _gl.gl).RGBA, (0, _gl.gl).FLOAT);
            try {
                // Only use gl.FLOAT if we can render to it
                testTexture.drawTo(function() {
                    textureType = (0, _gl.gl).FLOAT;
                });
            } catch (e) {
            /* empty */ }
            testTexture.destroy();
        }
        return textureType;
    }
    function initialize(width, height) {
        const textureType = getTextureType();
        if (this._.texture) this._.texture.destroy();
        if (this._.spareTexture) this._.spareTexture.destroy();
        this.width = width;
        this.height = height;
        this._.texture = new (0, _fxTexture.FxTexture)(width, height, (0, _gl.gl).RGBA, textureType);
        this._.spareTexture = new (0, _fxTexture.FxTexture)(width, height, (0, _gl.gl).RGBA, textureType);
        this._.extraTexture = this._.extraTexture || new (0, _fxTexture.FxTexture)(0, 0, (0, _gl.gl).RGBA, textureType);
        this._.flippedShader = this._.flippedShader || new (0, _fxShader.FxShader)(null, `
uniform sampler2D texture;
varying vec2 texCoord;
void main() {
    gl_FragColor = texture2D(texture, vec2(texCoord.x, 1.0 - texCoord.y));
}
        `, "flippedShader");
        this._.isInitialized = true;
    }
    function draw(texture, width, height) {
        if (!this._.isInitialized || texture._.width != this.width || texture._.height != this.height) initialize.call(this, width ? width : texture._.width, height ? height : texture._.height);
        texture._.use();
        this._.texture.drawTo(function() {
            (0, _fxShader.FxShader).getDefaultShader().drawRect();
        });
        return this;
    }
    function update() {
        this._.texture.use();
        this._.flippedShader.drawRect();
        return this;
    }
    function contents() {
        const texture = new (0, _fxTexture.FxTexture)(this._.texture.width, this._.texture.height, (0, _gl.gl).RGBA, (0, _gl.gl).UNSIGNED_BYTE);
        this._.texture.use();
        texture.drawTo(function() {
            (0, _fxShader.FxShader).getDefaultShader().drawRect();
        });
        return wrapTexture(texture);
    }
    /*
       Get a Uint8 array of pixel values: [r, g, b, a, r, g, b, a, ...]
       Length of the array will be width * height * 4.
    */ function getPixelArray() {
        const w = this._.texture.width;
        const h = this._.texture.height;
        const array = new Uint8Array(w * h * 4);
        this._.texture.drawTo(function() {
            (0, _gl.gl).readPixels(0, 0, w, h, (0, _gl.gl).RGBA, (0, _gl.gl).UNSIGNED_BYTE, array);
        });
        return array;
    }
    function wrap(fn) {
        return function(...args) {
            // Make sure that we're using the correct global WebGL context
            (0, _gl.setGl)(this._.gl);
            // Now that the context has been switched, we can call the wrapped function
            return fn.apply(this, args);
        };
    }
    function getWebGlContext(canvas, options) {
        const contextNames = [
            "webgl",
            "experimental-webgl",
            "webgl2"
        ];
        let context = null;
        contextNames.forEach((name)=>{
            if (context) return;
            // get.webgl.org does a try-catch
            try {
                context = canvas.getContext(name, options);
            } catch (e) {
            /* empty */ }
        });
        return context;
    }
    return ()=>{
        if (!window.WebGLRenderingContext) throw "WebGLRenderingContext not set. Browser does not support WebGL.";
        const canvas = (0, _bb.BB).canvas(1, 1);
        const context = getWebGlContext(canvas, {
            premultipliedAlpha: false
        });
        if (!context) throw "This browser does not support WebGL";
        (0, _gl.setGl)(context);
        canvas._ = {
            gl: (0, _gl.gl),
            isInitialized: false,
            texture: null,
            spareTexture: null,
            flippedShader: null
        };
        // Core methods
        canvas.texture = wrap(texture);
        canvas.draw = wrap(draw);
        canvas.update = wrap(update);
        canvas.contents = wrap(contents);
        canvas.getPixelArray = wrap(getPixelArray);
        // Filter methods
        canvas.brightnessContrast = wrap((0, _brightnessContrast.brightnessContrast));
        canvas.hueSaturation = wrap((0, _hueSaturation.hueSaturation));
        canvas.triangleBlur = wrap((0, _triangleBlur.triangleBlur));
        canvas.unsharpMask = wrap((0, _unsharpMask.unsharpMask));
        canvas.perspective = wrap((0, _perspective.perspective));
        canvas.matrixWarp = wrap((0, _matrixWarp.matrixWarp));
        canvas.tiltShift = wrap((0, _tiltShift.tiltShift));
        canvas.noise = wrap((0, _noise.noise));
        canvas.curves = wrap((0, _curves.curves));
        canvas.invert = wrap((0, _invert.invert));
        canvas.multiplyAlpha = wrap((0, _multiplyAlpha.multiplyAlpha));
        canvas.unmultiplyAlpha = wrap((0, _unmultiplyAlpha.unmultiplyAlpha));
        canvas.toAlpha = wrap((0, _toAlpha.toAlpha));
        canvas.distort = wrap((0, _distort.distort));
        return canvas;
    };
}();

},{"./filters/brightness-contrast":"8bUlD","./core/fx-shader":"3MCyu","./core/gl":"a6O5b","./core/fx-texture":"2jjOu","./filters/curves":"6Qd8w","./filters/hue-saturation":"bXmzM","./filters/noise":"jl5uV","./filters/triangle-blur":"g1tV6","./filters/tilt-shift":"jI0fX","./filters/matrix-warp":"bQEqW","./filters/unsharp-mask":"iJftw","./filters/to-alpha":"6l9zh","./filters/invert":"ermUE","./filters/perspective":"iCB4R","./filters/unmultiply-alpha":"5RBOZ","./filters/distort":"3eost","./filters/multiply-alpha":"8Qqjt","../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bUlD":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "brightnessContrast", ()=>brightnessContrast);
var _bb = require("../../bb/bb");
var _simpleShader = require("../core/simple-shader");
var _fxShader = require("../core/fx-shader");
var _gl = require("../core/gl");
const brightnessContrast = function(brightness, contrast) {
    (0, _gl.gl).brightnessContrast = (0, _gl.gl).brightnessContrast || new (0, _fxShader.FxShader)(null, "        uniform sampler2D texture;        uniform float brightness;        uniform float contrast;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            color.rgb += brightness;            if (contrast > 0.0) {                color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;            } else {                color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;            }            gl_FragColor = color;        }    ", "brightnessContrast");
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).brightnessContrast, {
        brightness: (0, _bb.BB).clamp(brightness, -1, 1),
        contrast: (0, _bb.BB).clamp(contrast, -1, 1)
    });
    return this;
};

},{"../../bb/bb":"dcQKo","../core/simple-shader":"bw8jp","../core/fx-shader":"3MCyu","../core/gl":"a6O5b","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bw8jp":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "simpleShader", ()=>simpleShader);
function simpleShader(shader, uniforms, textureIn, textureOut) {
    (textureIn || this._.texture).use();
    this._.spareTexture.drawTo(function() {
        shader.uniforms(uniforms).drawRect();
    });
    this._.spareTexture.swapWith(textureOut || this._.texture);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3MCyu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FxShader", ()=>FxShader);
var _gl = require("./gl");
var _bb = require("../../bb/bb");
const defaultVertexSource = "    attribute vec2 vertex;    attribute vec2 _texCoord;    varying vec2 texCoord;    void main() {        texCoord = _texCoord;        gl_Position = vec4(vertex * 2.0 - 1.0, 0.0, 1.0);    }";
const defaultFragmentSource = "    uniform sampler2D texture;    varying vec2 texCoord;    void main() {        gl_FragColor = texture2D(texture, texCoord);    }";
function isArray(obj) {
    return Object.prototype.toString.call(obj) == "[object Array]";
}
function isNumber(obj) {
    return Object.prototype.toString.call(obj) == "[object Number]";
}
let floatPrecision;
class FxShader {
    // ---- static ----
    static getDefaultShader() {
        (0, _gl.gl).defaultShader = (0, _gl.gl).defaultShader || new FxShader();
        return (0, _gl.gl).defaultShader;
    }
    // ---- private ----
    compileSource(type, source, nameStr) {
        const shader = (0, _bb.BB).throwIfNull((0, _gl.gl).createShader(type));
        (0, _gl.gl).shaderSource(shader, source.replace(/#define.*/, "")); // glslify adds a line add the beginning that breaks it
        (0, _gl.gl).compileShader(shader);
        if (!(0, _gl.gl).getShaderParameter(shader, (0, _gl.gl).COMPILE_STATUS)) throw "compile error: " + nameStr + " - " + (0, _gl.gl).getShaderInfoLog(shader);
        return shader;
    }
    /**
     * HIGH_FLOAT | MEDIUM_FLOAT
     */ testPrecisionSupport(precisionType) {
        const format = (0, _gl.gl).getShaderPrecisionFormat((0, _gl.gl).FRAGMENT_SHADER, precisionType);
        return format !== null && format.precision !== 0;
    }
    // ---- public ----
    constructor(vertexSource, fragmentSource, nameStr){
        this.vertexAttribute = null;
        this.texCoordAttribute = null;
        this.program = (0, _bb.BB).throwIfNull((0, _gl.gl).createProgram());
        vertexSource = vertexSource || defaultVertexSource;
        fragmentSource = fragmentSource || defaultFragmentSource;
        if (!floatPrecision) floatPrecision = this.testPrecisionSupport((0, _gl.gl).HIGH_FLOAT) ? "highp" : this.testPrecisionSupport((0, _gl.gl).MEDIUM_FLOAT) ? "mediump" : "lowp";
        fragmentSource = "precision " + floatPrecision + " float;" + fragmentSource; // annoying requirement is annoying
        (0, _gl.gl).attachShader(this.program, this.compileSource((0, _gl.gl).VERTEX_SHADER, vertexSource, nameStr + "(vertex)"));
        (0, _gl.gl).attachShader(this.program, this.compileSource((0, _gl.gl).FRAGMENT_SHADER, fragmentSource, nameStr + "(fragment)"));
        (0, _gl.gl).linkProgram(this.program);
        if (!(0, _gl.gl).getProgramParameter(this.program, (0, _gl.gl).LINK_STATUS)) throw "link error: " + (0, _gl.gl).getProgramInfoLog(this.program);
    }
    destroy() {
        (0, _gl.gl).deleteProgram(this.program);
        this.program = null;
    }
    uniforms(uniforms) {
        (0, _gl.gl).useProgram(this.program);
        Object.entries(uniforms).forEach(([name, value])=>{
            const location = (0, _gl.gl).getUniformLocation(this.program, name);
            if (location === null) // will be null if the uniform isn't used in the shader
            return;
            if (isArray(value)) switch(value.length){
                case 1:
                    (0, _gl.gl).uniform1fv(location, new Float32Array(value));
                    break;
                case 2:
                    (0, _gl.gl).uniform2fv(location, new Float32Array(value));
                    break;
                case 3:
                    (0, _gl.gl).uniform3fv(location, new Float32Array(value));
                    break;
                case 4:
                    (0, _gl.gl).uniform4fv(location, new Float32Array(value));
                    break;
                case 9:
                    (0, _gl.gl).uniformMatrix3fv(location, false, new Float32Array(value));
                    break;
                case 16:
                    (0, _gl.gl).uniformMatrix4fv(location, false, new Float32Array(value));
                    break;
                default:
                    throw "dont't know how to load uniform \"" + name + '" of length ' + value.length;
            }
            else if (isNumber(value)) (0, _gl.gl).uniform1f(location, value);
            else throw 'attempted to set uniform "' + name + '" to invalid value ' + (value || "undefined").toString();
        });
        // allow chaining
        return this;
    }
    //
    /**
     * textures are uniforms too but for some reason can't be specified by gl.uniform1f,
     * even though floating point numbers represent the integers 0 through 7 exactly
     */ textures(textures) {
        (0, _gl.gl).useProgram(this.program);
        Object.entries(textures).forEach(([name, value])=>{
            (0, _gl.gl).uniform1i((0, _gl.gl).getUniformLocation(this.program, name), value);
        });
        // allow chaining
        return this;
    }
    drawRect(left, top, right, bottom) {
        let undefined;
        const viewport = (0, _gl.gl).getParameter((0, _gl.gl).VIEWPORT);
        top = top !== undefined ? (top - viewport[1]) / viewport[3] : 0;
        left = left !== undefined ? (left - viewport[0]) / viewport[2] : 0;
        right = right !== undefined ? (right - viewport[0]) / viewport[2] : 1;
        bottom = bottom !== undefined ? (bottom - viewport[1]) / viewport[3] : 1;
        if ((0, _gl.gl).vertexBuffer === undefined || (0, _gl.gl).vertexBuffer === null) (0, _gl.gl).vertexBuffer = (0, _bb.BB).throwIfNull((0, _gl.gl).createBuffer());
        (0, _gl.gl).bindBuffer((0, _gl.gl).ARRAY_BUFFER, (0, _gl.gl).vertexBuffer);
        (0, _gl.gl).bufferData((0, _gl.gl).ARRAY_BUFFER, new Float32Array([
            left,
            top,
            left,
            bottom,
            right,
            top,
            right,
            bottom
        ]), (0, _gl.gl).STATIC_DRAW);
        if ((0, _gl.gl).texCoordBuffer == null) {
            (0, _gl.gl).texCoordBuffer = (0, _bb.BB).throwIfNull((0, _gl.gl).createBuffer());
            (0, _gl.gl).bindBuffer((0, _gl.gl).ARRAY_BUFFER, (0, _gl.gl).texCoordBuffer);
            (0, _gl.gl).bufferData((0, _gl.gl).ARRAY_BUFFER, new Float32Array([
                0,
                0,
                0,
                1,
                1,
                0,
                1,
                1
            ]), (0, _gl.gl).STATIC_DRAW);
        }
        if (this.vertexAttribute == null) {
            this.vertexAttribute = (0, _gl.gl).getAttribLocation(this.program, "vertex");
            (0, _gl.gl).enableVertexAttribArray(this.vertexAttribute);
        }
        if (this.texCoordAttribute == null) {
            this.texCoordAttribute = (0, _gl.gl).getAttribLocation(this.program, "_texCoord");
            (0, _gl.gl).enableVertexAttribArray(this.texCoordAttribute);
        }
        (0, _gl.gl).useProgram(this.program);
        (0, _gl.gl).bindBuffer((0, _gl.gl).ARRAY_BUFFER, (0, _gl.gl).vertexBuffer);
        (0, _gl.gl).vertexAttribPointer(this.vertexAttribute, 2, (0, _gl.gl).FLOAT, false, 0, 0);
        (0, _gl.gl).bindBuffer((0, _gl.gl).ARRAY_BUFFER, (0, _gl.gl).texCoordBuffer);
        (0, _gl.gl).vertexAttribPointer(this.texCoordAttribute, 2, (0, _gl.gl).FLOAT, false, 0, 0);
        (0, _gl.gl).drawArrays((0, _gl.gl).TRIANGLE_STRIP, 0, 4);
    }
}

},{"./gl":"a6O5b","../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"a6O5b":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "gl", ()=>gl);
parcelHelpers.export(exports, "setGl", ()=>setGl);
let gl;
function setGl(newGl) {
    // more problems setting type to null
    gl = newGl;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"2jjOu":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FxTexture", ()=>FxTexture);
var _gl = require("./gl");
var _bb = require("../../bb/bb");
class FxTexture {
    // ---- static ----
    static fromElement(element) {
        const texture = new FxTexture(0, 0, (0, _gl.gl).RGBA, (0, _gl.gl).UNSIGNED_BYTE);
        texture.loadContentsOf(element);
        return texture;
    }
    /*
    // never seen this being used
    private getCanvas(texture: Texture): CanvasRenderingContext2D {
        if (this.canvas == null) {
            this.canvas = BB.canvas(texture.width, texture.height);
        }
        this.canvas.width = texture.width;
        this.canvas.height = texture.height;
        const c = BB.ctx(this.canvas);
        c.clearRect(0, 0, this.canvas.width, this.canvas.height);
        return c;
    }*/ // ---- public ----
    constructor(width, height, format, type){
        this.gl = (0, _gl.gl);
        this.id = (0, _bb.BB).throwIfNull((0, _gl.gl).createTexture());
        this.width = width;
        this.height = height;
        this.format = format;
        this.type = type;
        this.canvas = null;
        (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, this.id);
        (0, _gl.gl).texParameteri((0, _gl.gl).TEXTURE_2D, (0, _gl.gl).TEXTURE_MAG_FILTER, (0, _gl.gl).LINEAR);
        (0, _gl.gl).texParameteri((0, _gl.gl).TEXTURE_2D, (0, _gl.gl).TEXTURE_MIN_FILTER, (0, _gl.gl).LINEAR);
        (0, _gl.gl).texParameteri((0, _gl.gl).TEXTURE_2D, (0, _gl.gl).TEXTURE_WRAP_S, (0, _gl.gl).CLAMP_TO_EDGE);
        (0, _gl.gl).texParameteri((0, _gl.gl).TEXTURE_2D, (0, _gl.gl).TEXTURE_WRAP_T, (0, _gl.gl).CLAMP_TO_EDGE);
        if (width && height) (0, _gl.gl).texImage2D((0, _gl.gl).TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
    }
    loadContentsOf(element) {
        this.width = element.width || element.videoWidth;
        this.height = element.height || element.videoHeight;
        (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, this.id);
        (0, _gl.gl).texImage2D((0, _gl.gl).TEXTURE_2D, 0, this.format, this.format, this.type, element);
    }
    initFromBytes(width, height, data) {
        this.width = width;
        this.height = height;
        this.format = (0, _gl.gl).RGBA;
        this.type = (0, _gl.gl).UNSIGNED_BYTE;
        (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, this.id);
        (0, _gl.gl).texImage2D((0, _gl.gl).TEXTURE_2D, 0, (0, _gl.gl).RGBA, width, height, 0, (0, _gl.gl).RGBA, this.type, new Uint8Array(data));
    }
    destroy() {
        (0, _gl.gl).deleteTexture(this.id);
        this.id = null;
    }
    use(unit) {
        (0, _gl.gl).activeTexture((0, _gl.gl).TEXTURE0 + (unit || 0));
        (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, this.id);
    }
    unuse(unit) {
        (0, _gl.gl).activeTexture((0, _gl.gl).TEXTURE0 + (unit || 0));
        (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, null);
    }
    ensureFormat(width, height, format, type) {
        // change the format only if required
        if (width != this.width || height != this.height || format != this.format || type != this.type) {
            this.width = width;
            this.height = height;
            this.format = format;
            this.type = type;
            (0, _gl.gl).bindTexture((0, _gl.gl).TEXTURE_2D, this.id);
            (0, _gl.gl).texImage2D((0, _gl.gl).TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
        }
    }
    ensureFormatViaTexture(texture) {
        this.ensureFormat(texture.width, texture.height, texture.format, texture.type);
    }
    drawTo(callback) {
        // start rendering to this texture
        (0, _gl.gl).framebuffer = (0, _gl.gl).framebuffer || (0, _gl.gl).createFramebuffer();
        (0, _gl.gl).bindFramebuffer((0, _gl.gl).FRAMEBUFFER, (0, _gl.gl).framebuffer);
        (0, _gl.gl).framebufferTexture2D((0, _gl.gl).FRAMEBUFFER, (0, _gl.gl).COLOR_ATTACHMENT0, (0, _gl.gl).TEXTURE_2D, this.id, 0);
        if ((0, _gl.gl).checkFramebufferStatus((0, _gl.gl).FRAMEBUFFER) !== (0, _gl.gl).FRAMEBUFFER_COMPLETE) throw new Error("incomplete framebuffer");
        (0, _gl.gl).viewport(0, 0, this.width, this.height);
        // do the drawing
        callback();
        // stop rendering to this texture
        (0, _gl.gl).bindFramebuffer((0, _gl.gl).FRAMEBUFFER, null);
    }
    /*
    // never seen this being used
    fillUsingCanvas (callback: (canvas: CanvasRenderingContext2D) => void): Texture {
        callback(this.getCanvas(this));
        this.format = gl.RGBA;
        this.type = gl.UNSIGNED_BYTE;
        gl.bindTexture(gl.TEXTURE_2D, this.id);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas);
        return this;
    }

    // never seen this being used
    toImage (image: HTMLImageElement): void {
        this.use();
        Shader.getDefaultShader().drawRect();
        const size = this.width * this.height * 4;
        const pixels = new Uint8Array(size);
        const c = this.getCanvas(this);
        const data = c.createImageData(this.width, this.height);
        gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        for (let i = 0; i < size; i++) {
            data.data[i] = pixels[i];
        }
        c.putImageData(data, 0, 0);
        image.src = this.canvas.toDataURL();
    }
     */ swapWith(other) {
        let temp;
        temp = other.id;
        other.id = this.id;
        this.id = temp;
        temp = other.width;
        other.width = this.width;
        this.width = temp;
        temp = other.height;
        other.height = this.height;
        this.height = temp;
        temp = other.format;
        other.format = this.format;
        this.format = temp;
    // type?
    }
}

},{"./gl":"a6O5b","../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6Qd8w":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "curves", ()=>curves);
var _splineInterpolate = require("../math/spline-interpolate");
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const curves = function(red, green, blue) {
    // Create the ramp texture
    const redRamp = (0, _splineInterpolate.splineInterpolate)(red);
    const greenRamp = (0, _splineInterpolate.splineInterpolate)(green);
    const blueRamp = (0, _splineInterpolate.splineInterpolate)(blue);
    const array = [];
    for(let i = 0; i < 256; i++)array.splice(array.length, 0, redRamp[i], greenRamp[i], blueRamp[i], 255);
    this._.extraTexture.initFromBytes(256, 1, array);
    this._.extraTexture.use(1);
    (0, _gl.gl).curves = (0, _gl.gl).curves || new (0, _fxShader.FxShader)(null, "        uniform sampler2D texture;        uniform sampler2D map;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);            color.r = texture2D(map, vec2(color.r)).r;            color.g = texture2D(map, vec2(color.g)).g;            color.b = texture2D(map, vec2(color.b)).b;            gl_FragColor = color;        }    ", "curves");
    (0, _gl.gl).curves.textures({
        map: 1
    });
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).curves, {});
    return this;
};

},{"../math/spline-interpolate":"cFfOe","../core/gl":"a6O5b","../core/fx-shader":"3MCyu","../core/simple-shader":"bw8jp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cFfOe":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "splineInterpolate", ()=>splineInterpolate);
var _bb = require("../../bb/bb");
function splineInterpolate(points) {
    const interpolator = new (0, _bb.BB).SplineInterpolator(points);
    const array = [];
    for(let i = 0; i < 256; i++)array.push((0, _bb.BB).clamp(Math.floor(interpolator.interpolate(i / 255) * 256), 0, 255));
    return array;
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bXmzM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "hueSaturation", ()=>hueSaturation);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
var _bb = require("../../bb/bb");
const hueSaturation = function(hue, saturation) {
    (0, _gl.gl).hueSaturation = (0, _gl.gl).hueSaturation || new (0, _fxShader.FxShader)(null, "        uniform sampler2D texture;        uniform float hue;        uniform float saturation;        varying vec2 texCoord;        void main() {            vec4 color = texture2D(texture, texCoord);                        /* hue adjustment, wolfram alpha: RotationTransform[angle, {1, 1, 1}][{x, y, z}] */            float angle = hue * 3.14159265;            float s = sin(angle), c = cos(angle);            vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;            float len = length(color.rgb);            color.rgb = vec3(                dot(color.rgb, weights.xyz),                dot(color.rgb, weights.zxy),                dot(color.rgb, weights.yzx)            );                        /* saturation adjustment */            float average = (color.r + color.g + color.b) / 3.0;            if (saturation > 0.0) {                color.rgb += (average - color.rgb) * (1.0 - 1.0 / (1.001 - saturation));            } else {                color.rgb += (average - color.rgb) * (-saturation);            }                        gl_FragColor = color;        }    ", "hueSaturation");
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).hueSaturation, {
        hue: (0, _bb.BB).clamp(hue, -1, 1),
        saturation: (0, _bb.BB).clamp(saturation, -1, 1)
    });
    return this;
};

},{"../core/gl":"a6O5b","../core/fx-shader":"3MCyu","../core/simple-shader":"bw8jp","../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jl5uV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "noise", ()=>noise);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
var _shaderNoiseGlsl = require("../shaders/shader-noise.glsl");
var _shaderNoiseGlslDefault = parcelHelpers.interopDefault(_shaderNoiseGlsl);
const noise = function(seed, type, scale, offset, octaves, samples, peaks, brightness, contrast, isReversed, colA, colB, channels) {
    (0, _gl.gl).noise = (0, _gl.gl).noise || new (0, _fxShader.FxShader)(null, (0, _shaderNoiseGlslDefault.default).replace(/#define.*/, ""), "noise");
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).noise, {
        seed: seed || 0,
        type,
        scale: [
            scale[0],
            scale[1]
        ],
        offset,
        octaves,
        samples,
        texSize: [
            this.width,
            this.height
        ],
        peaks,
        brightness,
        contrast,
        isReversed: isReversed ? 1.0 : 0.0,
        colA: colA ? [
            colA.r / 255,
            colA.g / 255,
            colA.b / 255
        ] : [
            0,
            0,
            0
        ],
        colB: colB ? [
            colB.r / 255,
            colB.g / 255,
            colB.b / 255
        ] : [
            1,
            1,
            1
        ],
        channels: channels === "rgb" ? 0 : 1
    });
    return this;
};

},{"../core/gl":"a6O5b","../core/fx-shader":"3MCyu","../core/simple-shader":"bw8jp","../shaders/shader-noise.glsl":"fpzkC","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"fpzkC":[function(require,module,exports) {
module.exports = "#define GLSLIFY 1\nuniform sampler2D texture;\nvarying vec2 texCoord;\nuniform vec2 texSize;\n\nuniform float seed;\nuniform float type;\nuniform vec2 scale;\nuniform vec2 offset;\nuniform float octaves;\nuniform float samples;\n\nuniform float peaks;\nuniform float contrast;\nuniform float brightness;\nuniform float isReversed;\n\nuniform vec3 colA;\nuniform vec3 colB;\n\nuniform float channels; // 0 - rgb, 1 - alpha\n\n// fbm, cellular_noise based on\n// https://github.com/Gonkee/Gonkees-Shaders\n// MIT, Copyright \xa9 Gonkee\n\n// hash & simplex based on\n// https://www.shadertoy.com/view/Msf3WH\n// MIT, Copyright \xa9 2013 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat value_noise(vec2 coord){\n    return rand(floor(coord) / 100.0);\n}\n\nfloat cellular_noise(vec2 coord) {\n    vec2 i = floor(coord);\n    vec2 f = fract(coord);\n\n    float min_dist = 99999.0;\n    for (float x = -1.0; x <= 1.0; x++) {\n        for (float y = -1.0; y <= 1.0; y++) {\n            vec2 node = rand(i + vec2(x, y)) + vec2(x, y);\n            float dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y);\n            min_dist = min(min_dist, dist);\n        }\n    }\n    return min_dist;\n}\n\n// ---------- Simplex Alternative ---------------------\n\nvec3 hash(vec3 p)\n{ p=vec3(dot(p, vec3(127.1, 311.7, 74.7))\n, dot(p, vec3(269.5, 183.3, 246.1))\n, dot(p, vec3(113.5, 271.9, 124.6)))\n;return fract(sin(p)*43758.5453123)*2.-1.; }\n\nmat3 hash(mat3 p)\n{ return mat3(hash(p[0]), hash(p[1]), hash(p[2])); }\n\nvec3 dots(mat3 a, vec3 w, mat3 b){ return vec3\n(dot(a[0], w-b[0]), dot(a[1], w-b[1]), dot(a[2], w-b[2])); }\n\n//return noiseGra13dx as .x, and its derivatives as .yzw\n// https://www.shadertoy.com/view/llByD1\nvec3 noiseGra13dx(in vec3 x) {\n    vec3 p=floor(x), w=fract(x)\n    #if 1\n    , u=w*w*w*(w*(w*6.-15.)+10.), v=30.*w*w*(w*(w-2.)+1.)//quintic hermite\n    #else\n    , u=w*w*(3.-2.*w), v=6.*w*(1.-w)//cubic hermite\n    #endif\n    //gradients\n    , G=hash(p+vec3(0)), F=hash(p+vec3(1))\n    ;mat3 D=hash(mat3(p, p, p)+mat3(1)), E=hash(mat3(p, p, p)+1.-mat3(1));\n    //projections\n    vec3 d=dots(D, w, mat3(1)), e=dots(E, w, 1.-mat3(1));\n    //interpolations\n    float g=dot(G, w), f=dot(F, w-vec3(1));\n    vec3 h=u.yzx*(g-d.xyx-d.yzz+e.zxy)+d-g, U=u*h, a=d-e;\n    mat3 S=D-mat3(G, G, G), W=D-E;\n    a.x=(a.x+a.y+a.z)+f-g;\n    ;float b=u.x*u.y*u.z;\n\n    vec4 result = vec4(g+U.x+U.y+U.z+a.x*b// value\n    , G*(1.-b)+b*(W[0]+W[1]+W[2]+F)//https://www.shadertoy.com/view/llByD1\n    +u.x*(S[0]+u.y*(G-D[0]-D[1]+E[2]))// derivatives\n    +u.y*(S[1]+u.z*(G-D[1]-D[2]+E[0]))\n    +u.z*(S[2]+u.x*(G-D[0]-D[2]+E[1]))\n    +v*(u.zxy*(g-d.xxy-d.zyz+e.yzx)+h+u.yzx*u.zxy*a.x));\n    return 0.5 + 0.5 * result.xxx;\n}\n\nfloat fbm(vec2 coord) {\n    float normalize_factor = 0.0;\n    float value = 0.0;\n    float scale = 0.5;\n\n    for (float i = 0.0; i < 7.0; i++){\n        if (i < octaves) {\n            if (type == 0.0) {\n                value += value_noise(coord) * scale;\n            } else if (type == 1.0) {\n                value += noiseGra13dx(vec3(coord.x, coord.y, 0.0)).r * scale;\n            } else if (type == 2.0) {\n                value += cellular_noise(coord) * scale;\n            }\n            normalize_factor += scale;\n            coord *= 2.0;\n            scale *= 0.5;\n        }\n    }\n    return value / normalize_factor;\n}\n\nfloat render (vec2 pos) {\n    float result = fbm(pos);\n    //\n\n    if (peaks > 0.0) {\n        result = abs(mod(result * peaks - 0.5, 1.0) - 0.5) * 2.0;// triangle\n        //result = mod(result * (peaks + 1.0), 1.0); // sawtooth\n    }\n\n    result += brightness;\n    if (contrast > 0.0) {\n        result = clamp((result - 0.5) / (1.0 - contrast) + 0.5, 0.0, 1.0);\n    } else if (contrast < 0.0) {\n        result = clamp((result - 0.5) * (1.0 + contrast) + 0.5, 0.0, 1.0);\n    }\n\n    if (isReversed == 1.0) {\n        result = 1.0 - result;\n    }\n    return result;\n}\n\nvoid main() {\n    vec4 color;\n\n    vec2 seedOffset;\n    seedOffset.x = (rand(vec2(seed, 0.0)) * 100.0 - 50.0);\n    seedOffset.y = (rand(vec2(0.0, seed)) * 100.0 - 50.0);\n\n    float val = 0.0;\n    vec2 basePos = texCoord * texSize / scale - offset / scale + seedOffset;\n\n    if (samples == 1.0) {\n        val = render(basePos);\n\n    }/* else if (samples == 4.0) {\n        for (float i = 0.0; i < 2.0; i++) {\n            for (float e = 0.0; e < 2.0; e++) {\n                val += render(basePos + (vec2(i, e) - 0.5) * 0.5 / scale);\n            }\n        }\n        val /= 4.0;\n\n    }*/ else if (samples == 16.0) {\n        for (float i = 0.0; i < 4.0; i++) {\n            for (float e = 0.0; e < 4.0; e++) {\n                val += render(basePos + (vec2(i, e) - 0.25) * 0.25 / scale);\n            }\n        }\n        val /= 16.0;\n    }\n\n    if (channels == 0.0) {\n        gl_FragColor = vec4(vec3(mix(colA, colB, val)), 1.0);\n    } else {\n        gl_FragColor = vec4(vec3(1.0), val);\n    }\n}";

},{}],"g1tV6":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "triangleBlur", ()=>triangleBlur);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _randomShaderFunc = require("../shaders/random-shader-func");
var _simpleShader = require("../core/simple-shader");
const triangleBlur = function(radius) {
    (0, _gl.gl).triangleBlur = (0, _gl.gl).triangleBlur || new (0, _fxShader.FxShader)(null, "        uniform sampler2D texture;        uniform vec2 delta;        varying vec2 texCoord;        " + (0, _randomShaderFunc.randomShaderFunc) + "        void main() {            vec4 color = vec4(0.0);            float total = 0.0;                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec4 sample = texture2D(texture, texCoord + delta * percent);                                color += sample * weight;                total += weight;            }                        gl_FragColor = color / total;        }    ", "triangleBlur");
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).triangleBlur, {
        delta: [
            radius / this.width,
            0
        ]
    });
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).triangleBlur, {
        delta: [
            0,
            radius / this.height
        ]
    });
    return this;
};

},{"../core/gl":"a6O5b","../core/fx-shader":"3MCyu","../shaders/random-shader-func":"7EmIo","../core/simple-shader":"bw8jp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7EmIo":[function(require,module,exports) {
// returns a random number between 0 and 1
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "randomShaderFunc", ()=>randomShaderFunc);
const randomShaderFunc = "    float random(vec3 scale, float seed) {        /* use the fragment position for a different seed per-pixel */        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);    }";

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jI0fX":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "tiltShift", ()=>tiltShift);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _randomShaderFunc = require("../shaders/random-shader-func");
var _simpleShader = require("../core/simple-shader");
const tiltShift = function(startX, startY, endX, endY, blurRadius, gradientRadius) {
    (0, _gl.gl).tiltShift = (0, _gl.gl).tiltShift || new (0, _fxShader.FxShader)(null, "        uniform sampler2D texture;        uniform float blurRadius;        uniform float gradientRadius;        uniform vec2 start;        uniform vec2 end;        uniform vec2 delta;        uniform vec2 texSize;        varying vec2 texCoord;        " + (0, _randomShaderFunc.randomShaderFunc) + "        void main() {            vec4 color = vec4(0.0);            float total = 0.0;                        /* randomize the lookup values to hide the fixed number of samples */            float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);                        vec2 normal = normalize(vec2(start.y - end.y, end.x - start.x));            float radius = smoothstep(0.0, 1.0, abs(dot(texCoord * texSize - start, normal)) / gradientRadius) * blurRadius;            for (float t = -30.0; t <= 30.0; t++) {                float percent = (t + offset - 0.5) / 30.0;                float weight = 1.0 - abs(percent);                vec4 sample = texture2D(texture, texCoord + delta / texSize * percent * radius);                                color += sample * weight;                total += weight;            }                        gl_FragColor = color / total;        }    ", "tiltShift");
    const dx = endX - startX;
    const dy = endY - startY;
    const d = Math.sqrt(dx * dx + dy * dy);
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).tiltShift, {
        blurRadius: blurRadius,
        gradientRadius: gradientRadius,
        start: [
            startX,
            startY
        ],
        end: [
            endX,
            endY
        ],
        delta: [
            dx / d,
            dy / d
        ],
        texSize: [
            this.width,
            this.height
        ]
    });
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).tiltShift, {
        blurRadius: blurRadius,
        gradientRadius: gradientRadius,
        start: [
            startX,
            startY
        ],
        end: [
            endX,
            endY
        ],
        delta: [
            -dy / d,
            dx / d
        ],
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"a6O5b","../core/fx-shader":"3MCyu","../shaders/random-shader-func":"7EmIo","../core/simple-shader":"bw8jp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bQEqW":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "matrixWarp", ()=>matrixWarp);
var _gl = require("../core/gl");
var _warpShader = require("../shaders/warp-shader");
var _simpleShader = require("../core/simple-shader");
var _matrix = require("../math/matrix");
const matrixWarp = function(matrix, inverse, useTextureSpace) {
    (0, _gl.gl).matrixWarp = (0, _gl.gl).matrixWarp || (0, _warpShader.warpShader)("        uniform mat3 matrix;        uniform bool useTextureSpace;    ", "        if (useTextureSpace) coord = coord / texSize * 2.0 - 1.0;        vec3 warp = matrix * vec3(coord, 1.0);        coord = warp.xy / warp.z;        if (useTextureSpace) coord = (coord * 0.5 + 0.5) * texSize;    ");
    // Flatten all members of matrix into one big list
    matrix = matrix.flat();
    // Extract a 3x3 matrix out of the arguments
    if (matrix.length == 4) matrix = [
        matrix[0],
        matrix[1],
        0,
        matrix[2],
        matrix[3],
        0,
        0,
        0,
        1
    ];
    else if (matrix.length != 9) throw "can only warp with 2x2 or 3x3 matrix";
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).matrixWarp, {
        matrix: inverse ? (0, _matrix.getInverse)(matrix) : matrix,
        texSize: [
            this.width,
            this.height
        ],
        useTextureSpace: useTextureSpace ? 1 : 0
    });
    return this;
};

},{"../core/gl":"a6O5b","../shaders/warp-shader":"4nmol","../core/simple-shader":"bw8jp","../math/matrix":"3WseU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4nmol":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "warpShader", ()=>warpShader);
var _fxShader = require("../core/fx-shader");
function warpShader(uniformsStr, warpStr) {
    return new (0, _fxShader.FxShader)(null, uniformsStr + "    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;    void main() {        vec2 coord = texCoord * texSize;        " + warpStr + "        gl_FragColor = texture2D(texture, coord / texSize);        vec2 clampedCoord = clamp(coord, vec2(0.0), texSize);        if (coord != clampedCoord) {            /* fade to transparent if we are outside the image */            gl_FragColor.a *= max(0.0, 1.0 - length(coord - clampedCoord));        }    }", "warp");
}

},{"../core/fx-shader":"3MCyu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3WseU":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// from javax.media.jai.PerspectiveTransform
/**
 * Creates a PerspectiveTransform that maps the unit square onto an arbitrary quadrilateral.
 */ parcelHelpers.export(exports, "getSquareToQuad", ()=>getSquareToQuad);
parcelHelpers.export(exports, "getInverse", ()=>getInverse);
parcelHelpers.export(exports, "multiply", ()=>multiply);
function getSquareToQuad(x0, y0, x1, y1, x2, y2, x3, y3) {
    const dx1 = x1 - x2;
    const dy1 = y1 - y2;
    const dx2 = x3 - x2;
    const dy2 = y3 - y2;
    const dx3 = x0 - x1 + x2 - x3;
    const dy3 = y0 - y1 + y2 - y3;
    const det = dx1 * dy2 - dx2 * dy1;
    const a = (dx3 * dy2 - dx2 * dy3) / det;
    const b = (dx1 * dy3 - dx3 * dy1) / det;
    return [
        x1 - x0 + a * x1,
        y1 - y0 + a * y1,
        a,
        x3 - x0 + b * x3,
        y3 - y0 + b * y3,
        b,
        x0,
        y0,
        1
    ];
}
function getInverse(m) {
    const a = m[0], b = m[1], c = m[2];
    const d = m[3], e = m[4], f = m[5];
    const g = m[6], h = m[7], i = m[8];
    const det = a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
    return [
        (e * i - f * h) / det,
        (c * h - b * i) / det,
        (b * f - c * e) / det,
        (f * g - d * i) / det,
        (a * i - c * g) / det,
        (c * d - a * f) / det,
        (d * h - e * g) / det,
        (b * g - a * h) / det,
        (a * e - b * d) / det
    ];
}
function multiply(a, b) {
    return [
        a[0] * b[0] + a[1] * b[3] + a[2] * b[6],
        a[0] * b[1] + a[1] * b[4] + a[2] * b[7],
        a[0] * b[2] + a[1] * b[5] + a[2] * b[8],
        a[3] * b[0] + a[4] * b[3] + a[5] * b[6],
        a[3] * b[1] + a[4] * b[4] + a[5] * b[7],
        a[3] * b[2] + a[4] * b[5] + a[5] * b[8],
        a[6] * b[0] + a[7] * b[3] + a[8] * b[6],
        a[6] * b[1] + a[7] * b[4] + a[8] * b[7],
        a[6] * b[2] + a[7] * b[5] + a[8] * b[8]
    ];
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iJftw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unsharpMask", ()=>unsharpMask);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const unsharpMask = function(radius, strength) {
    (0, _gl.gl).unsharpMask = (0, _gl.gl).unsharpMask || new (0, _fxShader.FxShader)(null, "        uniform sampler2D blurredTexture;        uniform sampler2D originalTexture;        uniform float strength;        uniform float threshold;        varying vec2 texCoord;        void main() {            vec4 blurred = texture2D(blurredTexture, texCoord);            vec4 original = texture2D(originalTexture, texCoord);            gl_FragColor = mix(blurred, original, 1.0 + strength);        }    ", "unsharpMask");
    // Store a copy of the current texture in the second texture unit
    this._.extraTexture.ensureFormatViaTexture(this._.texture);
    this._.texture.use();
    this._.extraTexture.drawTo(function() {
        (0, _fxShader.FxShader).getDefaultShader().drawRect();
    });
    // Blur the current texture, then use the stored texture to detect edges
    this._.extraTexture.use(1);
    this.triangleBlur(radius);
    (0, _gl.gl).unsharpMask.textures({
        originalTexture: 1
    });
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).unsharpMask, {
        strength: strength
    });
    this._.extraTexture.unuse(1);
    return this;
};

},{"../core/gl":"a6O5b","../core/fx-shader":"3MCyu","../core/simple-shader":"bw8jp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6l9zh":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "toAlpha", ()=>toAlpha);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const toAlpha = function(isInverted, replaceRGBA) {
    (0, _gl.gl).toAlpha = (0, _gl.gl).toAlpha || new (0, _fxShader.FxShader)(null, "    uniform bool isInverted;    uniform vec4 replace;    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;        void main() {        vec4 color = texture2D(texture, texCoord);        float alpha = (color.r + color.g + color.b) / 3.0;        if (isInverted) alpha = 1.0 - alpha;        alpha = min(color.a, alpha);        if (replace.a > 0.0) color = replace;        gl_FragColor = vec4(color.r, color.g, color.b, alpha);    }", "toAlpha");
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).toAlpha, {
        isInverted: isInverted ? 1 : 0,
        replace: replaceRGBA ? [
            replaceRGBA.r / 255,
            replaceRGBA.g / 255,
            replaceRGBA.b / 255,
            replaceRGBA.a
        ] : [
            0,
            0,
            0,
            0
        ],
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"a6O5b","../core/fx-shader":"3MCyu","../core/simple-shader":"bw8jp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ermUE":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "invert", ()=>invert);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const invert = function() {
    (0, _gl.gl).invert = (0, _gl.gl).invert || new (0, _fxShader.FxShader)(null, "    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;        void main() {        vec4 color = texture2D(texture, texCoord);        color.rgb = 1.0 - color.rgb;        gl_FragColor = color;    }", "invert");
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).invert, {
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"a6O5b","../core/fx-shader":"3MCyu","../core/simple-shader":"bw8jp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iCB4R":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "perspective", ()=>perspective);
var _matrix = require("../math/matrix");
const perspective = function(before, after) {
    const a = (0, _matrix.getSquareToQuad)(...after);
    const b = (0, _matrix.getSquareToQuad)(...before);
    const c = (0, _matrix.multiply)((0, _matrix.getInverse)(a), b);
    return this.matrixWarp(c);
};

},{"../math/matrix":"3WseU","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5RBOZ":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "unmultiplyAlpha", ()=>unmultiplyAlpha);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const unmultiplyAlpha = function() {
    (0, _gl.gl).unmultiplyAlpha = (0, _gl.gl).unmultiplyAlpha || new (0, _fxShader.FxShader)(null, "    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;        void main() {        vec4 color = texture2D(texture, texCoord);        if(color.a > 0.0) {            color.rgb /= color.a;        }        gl_FragColor = color;    }", "unmultiplyAlpha");
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).unmultiplyAlpha, {
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"a6O5b","../core/fx-shader":"3MCyu","../core/simple-shader":"bw8jp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3eost":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "distort", ()=>distort);
var _gl = require("../core/gl");
var _warpShader = require("../shaders/warp-shader");
var _simpleShader = require("../core/simple-shader");
const distort = function(settings) {
    (0, _gl.gl).distort = (0, _gl.gl).distort || (0, _warpShader.warpShader)(`
    uniform float stepSize;
    uniform vec2 scale;
    uniform vec2 strength;
    uniform vec2 phase;
    uniform float type;
    uniform vec2 offset;
`, `
    const float PI = 3.14159265;
    float x = coord.x + offset.x;
    float y = coord.y + offset.y;
    if (stepSize > 1.0) {
        x = floor(x / stepSize) * stepSize;
        y = floor(y / stepSize) * stepSize;
    }
    float distortX = sin((x/scale.x + phase.x) * PI * 2.0) * strength.x;
    float distortY = sin((y/scale.y + phase.y) * PI * 2.0) * strength.y;
    if (type == 0.0) {
        coord.y += distortX;
        coord.x += distortY;
    } else if (type == 1.0) {
        coord.x += distortX;
        coord.y += distortY;
    } else if (type == 2.0) {
        x -= offset.x;
        y -= offset.y;
        gl_FragColor = texture2D(texture, vec2(x, y) / texSize);
        coord.y += sin(gl_FragColor.r/scale.x*200.0 + phase.x * PI * 2.0) * strength.x;
        coord.x += cos(gl_FragColor.g/scale.y*200.0 + phase.y * PI * 2.0) * strength.y;
    }
    coord.x = mod(coord.x, texSize.x);
    coord.y = mod(coord.y, texSize.y);
`);
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).distort, {
        stepSize: settings.stepSize,
        type: settings.distortType,
        scale: [
            settings.scale.x,
            settings.scale.y
        ],
        strength: [
            settings.strength.x,
            settings.strength.y
        ],
        phase: [
            settings.phase.x,
            settings.phase.y
        ],
        offset: [
            settings.offset.x,
            settings.offset.y
        ],
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"a6O5b","../shaders/warp-shader":"4nmol","../core/simple-shader":"bw8jp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8Qqjt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "multiplyAlpha", ()=>multiplyAlpha);
var _gl = require("../core/gl");
var _fxShader = require("../core/fx-shader");
var _simpleShader = require("../core/simple-shader");
const multiplyAlpha = function() {
    (0, _gl.gl).multiplyAlpha = (0, _gl.gl).multiplyAlpha || new (0, _fxShader.FxShader)(null, "    uniform sampler2D texture;    uniform vec2 texSize;    varying vec2 texCoord;        void main() {        vec4 color = texture2D(texture, texCoord);        color.rgb *= color.a;        gl_FragColor = color;    }", "multiplyAlpha");
    (0, _simpleShader.simpleShader).call(this, (0, _gl.gl).multiplyAlpha, {
        texSize: [
            this.width,
            this.height
        ]
    });
    return this;
};

},{"../core/gl":"a6O5b","../core/fx-shader":"3MCyu","../core/simple-shader":"bw8jp","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cZn9c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "imgurUpload", ()=>imgurUpload);
var _bb = require("../../../bb/bb");
var _kl = require("../../kl");
var _base64ToBlob = require("../../storage/base-64-to-blob");
var _language = require("../../../language/language");
var _loadingGif = require("/src/app/img/ui/loading.gif");
var _loadingGifDefault = parcelHelpers.interopDefault(_loadingGif);
/**
 * uploads canvas, opens new tab with the upload progress & then opens the image page.
 */ async function upload(canvas, title, description, type, imgurKey) {
    const img = (0, _base64ToBlob.base64ToBlob)(canvas.toDataURL("image/" + type));
    const w = window.open();
    if (!w) throw new Error("could not create new tab");
    const label = w.document.createElement("div");
    const gif = w.document.createElement("img");
    gif.src = (0, _loadingGifDefault.default);
    label.append(gif);
    (0, _bb.BB).css(gif, {
        filter: "invert(1)"
    });
    (0, _bb.BB).css(w.document.body, {
        backgroundColor: "#121211",
        backgroundImage: "linear-gradient(#2b2b2b 0%, #121211 50%)",
        backgroundRepeat: "no-repeat"
    });
    const labelText = w.document.createElement("div");
    labelText.style.marginTop = "10px";
    label.append(labelText);
    labelText.textContent = (0, _language.LANG)("upload-uploading");
    w.document.body.append(label);
    (0, _bb.BB).css(label, {
        marginLeft: "auto",
        marginRight: "auto",
        marginTop: "100px",
        fontFamily: "system-ui, sans-serif",
        fontSize: "20px",
        textAlign: "center",
        transition: "opacity 0.3s ease-in-out",
        opacity: "0",
        color: "#ccc"
    });
    setTimeout(function() {
        label.style.opacity = "1";
    }, 20);
    let response;
    try {
        const formData = new FormData();
        formData.append("title", title);
        formData.append("description", description);
        formData.append("image", img);
        response = await fetch("https://api.imgur.com/3/image", {
            method: "POST",
            headers: {
                Authorization: "Client-ID " + imgurKey
            },
            body: formData
        });
    } catch (e) {
        w.close();
        throw e;
    }
    if (!response.ok) {
        w.close();
        throw new Error();
    }
    const data = (await response.json()).data;
    w.location.href = data.link.replace(/\.(jpg|png)/, "");
    return data;
}
function imgurUpload(klCanvas, klRootEl, saveReminder, imgurKey) {
    if (!imgurKey) throw new Error("imgur key missing");
    const inputTitle = (0, _bb.BB).el({
        tagName: "input"
    });
    inputTitle.type = "text";
    inputTitle.value = (0, _language.LANG)("upload-title-untitled");
    const inputDescription = (0, _bb.BB).el({
        tagName: "textarea",
        custom: {
            rows: "2"
        },
        css: {
            width: "100%",
            maxWidth: "100%"
        }
    });
    const labelTitle = (0, _bb.BB).el({
        textContent: (0, _language.LANG)("upload-name") + ":"
    });
    const labelDescription = (0, _bb.BB).el({
        textContent: (0, _language.LANG)("upload-caption") + ":",
        css: {
            marginTop: "10px"
        }
    });
    const tos = (0, _bb.BB).el({
        content: `<br/><a href="https://imgur.com/tos" target="_blank" rel="noopener noreferrer">${(0, _language.LANG)("terms-of-service")}</a>`
    });
    const typeRadio = new (0, _kl.KL).RadioList({
        name: "filetype",
        init: "jpeg",
        items: [
            {
                label: "JPG",
                value: "jpeg"
            },
            {
                label: "PNG",
                value: "png"
            }
        ],
        ignoreFocus: true
    });
    (0, _bb.BB).css(typeRadio.getElement(), {
        marginBottom: "10px"
    });
    const outDiv = (0, _bb.BB).el();
    const infoHint = (0, _bb.BB).el({
        className: "info-hint",
        textContent: (0, _language.LANG)("upload-link-notice")
    });
    outDiv.append(infoHint, typeRadio.getElement(), labelTitle, inputTitle, labelDescription, inputDescription, tos);
    (0, _kl.KL).popup({
        target: klRootEl,
        message: `<b>${(0, _language.LANG)("upload-title")}</b>`,
        type: "upload",
        div: outDiv,
        buttons: [
            (0, _language.LANG)("upload-submit"),
            "Cancel"
        ],
        clickOnEnter: (0, _language.LANG)("upload-submit"),
        primaries: [
            (0, _language.LANG)("upload-submit")
        ],
        autoFocus: (0, _language.LANG)("upload-submit"),
        callback: async function(val) {
            if (val === (0, _language.LANG)("upload-submit") || val === "Yes" || val === "Ok") try {
                const result = await upload(klCanvas.getCompleteCanvas(1), inputTitle.value, inputDescription.value, typeRadio.getValue(), imgurKey);
                (0, _kl.KL).popup({
                    target: klRootEl,
                    type: "ok",
                    message: `<h3>${(0, _language.LANG)("upload-success")}</h3><br>${(0, _language.LANG)("upload-delete")}<br><a target='_blank' rel="noopener noreferrer" href='https://imgur.com/delete/${result.deletehash}'>imgur.com/delete/${result.deletehash}</a><br><br>`,
                    buttons: [
                        "Ok"
                    ]
                });
                saveReminder.reset();
            } catch (e) {
                (0, _kl.KL).popup({
                    target: klRootEl,
                    type: "error",
                    message: (0, _language.LANG)("upload-failed"),
                    buttons: [
                        "Ok"
                    ]
                });
            }
        }
    });
}

},{"../../../bb/bb":"dcQKo","../../kl":"8nmWp","../../storage/base-64-to-blob":"4JT2T","../../../language/language":"iiYGN","/src/app/img/ui/loading.gif":"jtanY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"jtanY":[function(require,module,exports) {
module.exports = require("8d7babdb187eb8a4").getBundleURL("d3gnI") + "loading.8250a1b1.gif" + "?" + Date.now();

},{"8d7babdb187eb8a4":"lgJ39"}],"gJgsA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "loadAgPsd", ()=>loadAgPsd);
let agPsdLazy;
async function loadAgPsd() {
    if (!agPsdLazy) agPsdLazy = await require("9bdc000954b5ac76");
    return agPsdLazy;
}

},{"9bdc000954b5ac76":"75zf2","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"75zf2":[function(require,module,exports) {
module.exports = require("588dd71ac0ae9889")(require("107d12b3bcc11cb1").getBundleURL("d3gnI") + "dist.d00432e1.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("7dPZz"));

},{"588dd71ac0ae9889":"61B45","107d12b3bcc11cb1":"lgJ39"}],"i5Pgf":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * remind user of saving, keep user aware of save state
 */ parcelHelpers.export(exports, "SaveReminder", ()=>SaveReminder);
var _kl = require("../../kl");
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _browserStorageUi = require("./browser-storage-ui");
const unsavedActionsLimit = 100; // number of actions user did since last save
const LS_REMINDER_KEY = "kl-save-reminder";
class SaveReminder {
    showPopup() {
        if (!this.projectStore || !this.getProject) throw new Error("projectStore and getProject need to be set");
        const min = Math.round((performance.now() - this.lastSavedAt) / 1000 / 60);
        const contentEl = (0, _bb.BB).el();
        contentEl.append((0, _bb.BB).el({
            content: (0, _language.LANG)("save-reminder-text", {
                a: "<strong>" + min,
                b: "</strong>"
            }),
            css: {
                marginBottom: "20px"
            }
        }));
        const psdWrapper = (0, _bb.BB).el({
            css: {
                borderTop: "1px solid #aaa",
                margin: "0 -20px",
                padding: "20px"
            }
        });
        const storageWrapper = (0, _bb.BB).el({
            css: {
                borderTop: "1px solid #aaa",
                margin: "0 -20px",
                padding: "20px",
                paddingBottom: "0"
            }
        });
        contentEl.append(psdWrapper, storageWrapper);
        const psdBtn = (0, _bb.BB).el({
            tagName: "button",
            className: "kl-button",
            content: (0, _language.LANG)("save-reminder-save-psd"),
            onClick: ()=>this.onSaveAsPsd()
        });
        psdWrapper.append(psdBtn, (0, _bb.BB).el({
            content: (0, _language.LANG)("save-reminder-psd-layers"),
            css: {
                marginTop: "10px"
            }
        }));
        const storageUi = new (0, _browserStorageUi.BrowserStorageUi)(this.projectStore, this.getProject, this, document.body, {
            hideClearButton: true,
            isFocusable: true
        });
        storageWrapper.append(storageUi.getElement());
        (0, _kl.KL).popup({
            target: document.body,
            message: `<b>${(0, _language.LANG)("save-reminder-title")}</b>`,
            div: contentEl,
            ignoreBackground: true,
            callback: ()=>{
                storageUi.destroy();
                (0, _bb.BB).destroyEl(psdBtn);
                this.closeFunc = undefined;
                this.lastReminderShownAt = performance.now();
            },
            closeFunc: (f)=>{
                this.closeFunc = f;
            }
        });
        setTimeout(()=>{
            psdBtn.focus();
        }, 40);
    }
    constructor(history, showReminder, changeTitle, onSaveAsPsd, isDrawing, projectStore, getProject, title = "Klecks"){
        this.history = history;
        this.showReminder = showReminder;
        this.changeTitle = changeTitle;
        this.onSaveAsPsd = onSaveAsPsd;
        this.isDrawing = isDrawing;
        this.projectStore = projectStore;
        this.getProject = getProject;
        this.title = title;
        this.lastSavedAt = 0;
        this.lastReminderShownAt = 0;
        this.setting = localStorage.getItem(LS_REMINDER_KEY) ?? "20min";
    }
    init() {
        if (this.lastSavedActionNumber !== undefined) return;
        this.lastSavedActionNumber = this.history.getActionNumber();
        this.lastReminderShownAt = performance.now();
        this.lastSavedAt = performance.now();
        if (this.showReminder) setInterval(()=>{
            if (document.visibilityState !== "visible") return;
            const unsavedActions = Math.abs(this.history.getActionNumber() - this.lastSavedActionNumber);
            const timeLimitMs = 60000 * ({
                "20min": 20,
                "40min": 40,
                "disabled": 0
            })[this.setting];
            if (timeLimitMs > 0 && (0, _kl.KL).dialogCounter.get() === 0 && !this.isDrawing() && this.lastReminderShownAt + timeLimitMs < performance.now() && unsavedActions >= unsavedActionsLimit) this.showPopup();
        }, 5000);
        // confirmation dialog when closing tab
        function onBeforeUnload(e) {
            e.preventDefault();
            e.returnValue = "";
        }
        this.history.addListener(()=>{
            const actionNumber = this.history.getActionNumber();
            if (this.lastSavedActionNumber !== actionNumber) window.onbeforeunload = onBeforeUnload;
            else window.onbeforeunload = null;
        });
        if (this.changeTitle) document.addEventListener("visibilitychange", ()=>{
            if (document.visibilityState === "visible") {
                document.title = this.title;
                clearInterval(this.unsavedInterval);
            } else {
                const actionNumber = this.history.getActionNumber();
                if (this.lastSavedActionNumber !== actionNumber) {
                    document.title = (0, _language.LANG)("unsaved") + " - " + this.title;
                    let state = 0;
                    this.unsavedInterval = setInterval(()=>{
                        state = (state + 1) % 2;
                        if (state === 1) document.title = (0, _language.LANG)("unsaved") + " \xb7 " + this.title;
                        else document.title = (0, _language.LANG)("unsaved") + " - " + this.title;
                    }, 180000);
                }
            }
        });
    }
    reset() {
        if (this.lastSavedActionNumber === undefined) return;
        this.lastSavedActionNumber = this.history.getActionNumber();
        this.lastReminderShownAt = performance.now();
        this.lastSavedAt = performance.now();
        window.onbeforeunload = null;
        if (this.closeFunc) this.closeFunc();
    }
    getSetting() {
        return this.setting;
    }
    setSetting(setting) {
        this.setting = setting;
        localStorage.setItem(LS_REMINDER_KEY, this.setting);
    }
}

},{"../../kl":"8nmWp","../../../bb/bb":"dcQKo","../../../language/language":"iiYGN","./browser-storage-ui":"9u5bD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"axnPV":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SaveToComputer", ()=>SaveToComputer);
var _bb = require("../../bb/bb");
var _kl = require("../kl");
var _saveAs = require("../../bb/base/save-as");
var _klConfig = require("../kl-config");
class SaveToComputer {
    /**
     * Using old code, because saving somehow doesn't work for ipad before ios 13,
     * and it doesn't even throw an exception.
     */ saveImage(canvas, filename, mimeType) {
        const parts = canvas.toDataURL(mimeType).match(/data:([^;]*)(;base64)?,([0-9A-Za-z+/]+)/);
        if (!parts) throw new Error("saveImage: empty parts");
        //assume base64 encoding
        const binStr = atob(parts[3]);
        //convert to binary in ArrayBuffer
        const buf = new ArrayBuffer(binStr.length);
        const view = new Uint8Array(buf);
        for(let i = 0; i < view.length; i++)view[i] = binStr.charCodeAt(i);
        const blob = new Blob([
            view
        ], {
            "type": parts[1]
        });
        (0, _saveAs.saveAs)(blob, filename);
    }
    constructor(saveReminder, getExportType, getKlCanvas){
        this.saveReminder = saveReminder;
        this.getExportType = getExportType;
        this.getKlCanvas = getKlCanvas;
    }
    save(format) {
        this.saveReminder.reset();
        if (!format) format = this.getExportType();
        if (format === "png") {
            const extension = "png";
            const mimeType = "image/png";
            const filename = (0, _bb.BB).getDate() + (0, _klConfig.klConfig).filenameBase + "." + extension;
            const fullCanvas = this.getKlCanvas().getCompleteCanvas(1);
            try {
                this.saveImage(fullCanvas, filename, mimeType);
            } catch (error) {
                alert("could not save");
                throw new Error("failed png export");
            }
        } else if (format === "layers") {
            const extension = "png";
            const mimeType = "image/png";
            const fileBase = (0, _bb.BB).getDate() + (0, _klConfig.klConfig).filenameBase;
            const layerArr = this.getKlCanvas().getLayersFast();
            for(let i = 0; i < layerArr.length; i++){
                const item = layerArr[i];
                const fnameArr = [
                    fileBase,
                    "_",
                    ("" + (i + 1)).padStart(2, "0"),
                    "_",
                    item.name,
                    ".",
                    extension
                ];
                this.saveImage(item.canvas, fnameArr.join(""), mimeType);
            }
        } else if (format === "psd") {
            const layerArr = this.getKlCanvas().getLayersFast();
            const psdConfig = {
                width: this.getKlCanvas().getWidth(),
                height: this.getKlCanvas().getHeight(),
                children: [],
                canvas: this.getKlCanvas().getCompleteCanvas(1)
            };
            for(let i = 0; i < layerArr.length; i++){
                const item = layerArr[i];
                psdConfig.children.push({
                    name: item.name,
                    hidden: !item.isVisible,
                    opacity: item.opacity,
                    canvas: item.canvas,
                    blendMode: (0, _kl.KL).PSD.blendKlToPsd(item.mixModeStr),
                    left: 0,
                    top: 0
                });
            }
            (0, _kl.KL).loadAgPsd().then((agPsdLazy)=>{
                const buffer = agPsdLazy.writePsdBuffer(psdConfig);
                const blob = new Blob([
                    buffer
                ], {
                    type: "application/octet-stream"
                });
                (0, _saveAs.saveAs)(blob, (0, _bb.BB).getDate() + (0, _klConfig.klConfig).filenameBase + ".psd");
            }).catch(()=>{
                alert("Error: failed to load PSD library");
            });
        }
    }
}

},{"../../bb/bb":"dcQKo","../kl":"8nmWp","../../bb/base/save-as":"gt2nZ","../kl-config":"argRu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gt2nZ":[function(require,module,exports) {
// https://github.com/eligrey/FileSaver.js/issues/774
// stripped down version of https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js#L81-L108
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "saveAs", ()=>saveAs);
function saveAs(blob, name) {
    // Namespace is used to prevent conflict w/ Chrome Poper Blocker extension (Issue https://github.com/eligrey/FileSaver.js/issues/561)
    const a = document.createElementNS("http://www.w3.org/1999/xhtml", "a");
    a.download = name;
    a.rel = "noopener";
    a.href = URL.createObjectURL(blob);
    setTimeout(()=>URL.revokeObjectURL(a.href), 40000);
    setTimeout(()=>a.click(), 0);
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"e5QXt":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "UndoRedoCatchup", ()=>UndoRedoCatchup);
var _kl = require("../kl");
var _klHistory = require("./kl-history");
var _base = require("../../bb/base/base");
function execHistoryEntry(historyEntry, layerIndex, klCanvas, brushes, setCurrentLayerCtx, getCurrentLayerCtx) {
    if (historyEntry.tool[0] === "brush") {
        const b = brushes[historyEntry.tool[1]];
        historyEntry.actions.forEach((action)=>{
            b[action.action](...action.params);
        });
    } else if (historyEntry.tool[0] === "canvas") {
        const p = historyEntry.params;
        const id = klCanvas[historyEntry.action](...p);
        if (typeof id === "number") {
            layerIndex = id;
            const ctx = (0, _base.throwIfNull)(klCanvas.getLayerContext(layerIndex));
            setCurrentLayerCtx(ctx);
            Object.entries(brushes).forEach(([, brush])=>brush.setContext(ctx));
        }
    } else if (historyEntry.tool[0] === "filter") {
        const p = [
            {
                context: getCurrentLayerCtx(),
                klCanvas,
                input: historyEntry.params[0].input,
                history: new (0, _kl.KL).DecoyKlHistory()
            }
        ];
        (0, _kl.KL).filterLib[historyEntry.tool[1]][historyEntry.action](...p);
    } else if (historyEntry.tool[0] === "misc" && historyEntry.action === "focusLayer") {
        layerIndex = historyEntry.params[0];
        const ctx = (0, _base.throwIfNull)(klCanvas.getLayerContext(layerIndex));
        setCurrentLayerCtx(ctx);
        Object.entries(brushes).forEach(([, brush])=>brush.setContext(ctx));
    } else if (historyEntry.tool[0] === "misc" && historyEntry.action === "importImage") {
        const id = klCanvas.addLayer();
        if (typeof id === "number") {
            layerIndex = id;
            if (historyEntry.params[1]) klCanvas.renameLayer(layerIndex, historyEntry.params[1]);
            const ctx = (0, _base.throwIfNull)(klCanvas.getLayerContext(layerIndex));
            setCurrentLayerCtx(ctx);
            Object.entries(brushes).forEach(([, brush])=>brush.setContext(ctx));
        }
        getCurrentLayerCtx().drawImage(historyEntry.params[0], 0, 0);
    }
    return layerIndex;
}
class UndoRedoCatchup {
    /**
     * Prevent multiple undo / redo getting triggered at once if UI is frozen.
     * true -> ignore, don't undo / redo
     */ shouldIgnoreTest() {
        if (this.doIgnore) return true;
        this.doIgnore = true;
        setTimeout(()=>{
            this.doIgnore = false;
        }, 0);
        return false;
    }
    // ---- public ----
    constructor(brushUiMap, layerPreview, layerManager, handUi, klCanvasWorkspace, getInitState, getKlCanvas, getCurrentLayerCtx, setCurrentLayerCtx, getCurrentBrush){
        this.brushUiMap = brushUiMap;
        this.layerPreview = layerPreview;
        this.layerManager = layerManager;
        this.handUi = handUi;
        this.klCanvasWorkspace = klCanvasWorkspace;
        this.getInitState = getInitState;
        this.getKlCanvas = getKlCanvas;
        this.getCurrentLayerCtx = getCurrentLayerCtx;
        this.setCurrentLayerCtx = setCurrentLayerCtx;
        this.getCurrentBrush = getCurrentBrush;
        this.doIgnore = false;
    }
    undo() {
        if (this.shouldIgnoreTest() || !(0, _klHistory.klHistory).canUndo()) return false;
        const entries = (0, _klHistory.klHistory).undo();
        const klCanvas = this.getKlCanvas();
        (0, _klHistory.klHistory).pause(true);
        const initState = this.getInitState();
        const oldSize = {
            w: klCanvas.getWidth(),
            h: klCanvas.getHeight()
        };
        klCanvas.copy(initState.canvas);
        let layerIndex = initState.focus;
        this.setCurrentLayerCtx((0, _base.throwIfNull)(klCanvas.getLayerContext(layerIndex)));
        const brushes = {};
        Object.entries((0, _kl.KL).brushes).forEach(([b, brush])=>{
            brushes[b] = new brush();
            brushes[b].setContext(this.getCurrentLayerCtx());
        });
        brushes.SketchyBrush.setSeed(initState.brushes.SketchyBrush.getSeed());
        entries.forEach((entry)=>{
            layerIndex = execHistoryEntry(entry, layerIndex, klCanvas, brushes, (ctx)=>this.setCurrentLayerCtx(ctx), ()=>(0, _base.throwIfNull)(this.getCurrentLayerCtx()));
        });
        if (oldSize.w !== klCanvas.getWidth() || oldSize.h !== klCanvas.getHeight()) {
            this.klCanvasWorkspace.resetOrFitView();
            this.handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
        }
        this.layerManager.update(layerIndex);
        this.layerPreview.setLayer((0, _base.throwIfNull)(klCanvas.getLayer(layerIndex)));
        this.brushUiMap.sketchyBrush.setSeed(brushes.SketchyBrush.getSeed());
        this.getCurrentBrush().setContext(this.getCurrentLayerCtx());
        this.klCanvasWorkspace.setLastDrawEvent();
        (0, _klHistory.klHistory).pause(false);
        return true;
    }
    redo() {
        if (this.shouldIgnoreTest() || !(0, _klHistory.klHistory).canRedo()) return false;
        const entry = (0, _klHistory.klHistory).redo();
        if (!entry) {
            setTimeout(()=>{
                throw new Error("redo failed. redo entry undefined");
            });
            return false;
        }
        const klCanvas = this.getKlCanvas();
        (0, _klHistory.klHistory).pause(true);
        const oldSize = {
            w: klCanvas.getWidth(),
            h: klCanvas.getHeight()
        };
        const brushes = {};
        Object.entries((0, _kl.KL).brushes).forEach(([b, brush])=>{
            brushes[b] = new brush();
            brushes[b].setContext(this.getCurrentLayerCtx());
        });
        brushes.SketchyBrush.setSeed(this.brushUiMap.sketchyBrush.getSeed());
        execHistoryEntry(entry, 0, klCanvas, brushes, (ctx)=>this.setCurrentLayerCtx(ctx), ()=>(0, _base.throwIfNull)(this.getCurrentLayerCtx()));
        if (oldSize.w !== klCanvas.getWidth() || oldSize.h !== klCanvas.getHeight()) {
            this.klCanvasWorkspace.resetOrFitView();
            this.handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
        }
        const currentLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(this.getCurrentLayerCtx().canvas));
        this.layerManager.update(currentLayerIndex);
        this.layerPreview.setLayer(klCanvas.getLayer(currentLayerIndex));
        this.brushUiMap.sketchyBrush.setSeed(brushes.SketchyBrush.getSeed());
        this.getCurrentBrush().setContext(this.getCurrentLayerCtx());
        this.klCanvasWorkspace.setLastDrawEvent();
        (0, _klHistory.klHistory).pause(false);
        return true;
    }
    catchup(logParam) {
        // const start = performance.now();
        //play catch up (the version that is a few steps behind)
        if (!logParam || !logParam.bufferUpdate) return;
        const initState = this.getInitState();
        let localCurrentLayerCtx = initState.canvas.getLayerContext(initState.focus);
        initState.focus = execHistoryEntry(logParam.bufferUpdate, initState.focus, initState.canvas, initState.brushes, (ctx)=>{
            localCurrentLayerCtx = ctx;
        }, ()=>(0, _base.throwIfNull)(localCurrentLayerCtx));
    // console.log('catchup', performance.now() - start);
    }
}

},{"../kl":"8nmWp","./kl-history":"klzEn","../../bb/base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dTdDM":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Central place to update brush settings, and to subscribe to changes.
 */ parcelHelpers.export(exports, "BrushSettingService", ()=>BrushSettingService);
class BrushSettingService {
    emit(obj, skipSubscriber) {
        for(let i = 0; i < this.subscriberArr.length; i++){
            if (this.subscriberArr[i] === skipSubscriber) continue;
            this.subscriberArr[i](obj);
        }
    }
    // --- public ---
    constructor(onSetColor, onSetSize, onSetOpacity, onGetColor, onGetSize, onGetOpacity, onGetSliderConfig){
        this.onSetColor = onSetColor;
        this.onSetSize = onSetSize;
        this.onSetOpacity = onSetOpacity;
        this.onGetColor = onGetColor;
        this.onGetSize = onGetSize;
        this.onGetOpacity = onGetOpacity;
        this.onGetSliderConfig = onGetSliderConfig;
        this.subscriberArr = [];
        if (BrushSettingService.instance) throw new Error("BrushSettingService already instantiated");
        BrushSettingService.instance = this;
    }
    emitColor(color, skipSubscriber) {
        this.emit({
            type: "color",
            value: color
        }, skipSubscriber);
    }
    emitSize(size, skipSubscriber) {
        this.emit({
            type: "size",
            value: size
        }, skipSubscriber);
    }
    emitOpacity(opacity, skipSubscriber) {
        this.emit({
            type: "opacity",
            value: opacity
        }, skipSubscriber);
    }
    emitSliderConfig(sliderConfig, skipSubscriber) {
        this.emit({
            type: "sliderConfig",
            value: sliderConfig
        }, skipSubscriber);
    }
    /**
     * set current brush color
     * @param color
     * @param skipSubscriber
     */ setColor(color, skipSubscriber) {
        this.onSetColor(color);
        this.emitColor(color, skipSubscriber);
    }
    /**
     * set current brush size
     * @param size
     * @param skipSubscriber
     */ setSize(size, skipSubscriber) {
        this.onSetSize(size);
    // why not emitting?
    }
    /**
     * set current opacity
     * @param opacity
     * @param skipSubscriber
     */ setOpacity(opacity, skipSubscriber) {
        this.onSetOpacity(opacity);
    // why not emitting?
    }
    /**
     * get current brush color
     */ getColor() {
        return this.onGetColor();
    }
    getSize() {
        return this.onGetSize();
    }
    getOpacity() {
        return this.onGetOpacity();
    }
    getSliderConfig() {
        return this.onGetSliderConfig();
    }
    /**
     * subscribe to changes
     * @param func
     */ subscribe(func) {
        if (this.subscriberArr.includes(func)) return;
        this.subscriberArr.push(func);
    }
    unsubscribe(func) {
        for(let i = 0; i < this.subscriberArr.length; i++)if (func === this.subscriberArr[i]) {
            this.subscriberArr.splice(i, 1);
            i--;
        }
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4JW40":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "SettingsTab", ()=>SettingsTab);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _kl = require("../../kl");
var _languages = require("../../../../languages/languages");
var _bitbofLogoSvg = require("/src/app/img/bitbof-logo.svg");
var _bitbofLogoSvgDefault = parcelHelpers.interopDefault(_bitbofLogoSvg);
var _klecksLogoPng = require("/src/app/img/klecks-logo.png");
var _klecksLogoPngDefault = parcelHelpers.interopDefault(_klecksLogoPng);
var _uiSwapLrSvg = require("/src/app/img/ui/ui-swap-lr.svg");
var _uiSwapLrSvgDefault = parcelHelpers.interopDefault(_uiSwapLrSvg);
var _localStorage = require("../../../bb/base/local-storage");
var _theme = require("../../../theme/theme");
var _base = require("../../../bb/base/base");
var _showLicensesDialog = require("../modals/licenses-dialog/show-licenses-dialog");
var _c = require("../../../bb/base/c");
var _showModal = require("../modals/base/showModal");
class SettingsTab {
    // --- public ---
    constructor(onLeftRight, saveReminder, customAbout){
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: "10px"
            }
        });
        // ---- language ----
        const autoLanguage = (0, _language.languageStrings).getAutoLanguage();
        const langWrapper = (0, _bb.BB).el({
            parent: this.rootEl,
            content: (0, _bb.BB).el({
                content: (0, _language.LANG)("settings-language") + ":",
                css: {
                    marginRight: "5px",
                    marginBottom: "2px"
                }
            }),
            css: {
                display: "flex",
                alignItems: "center",
                flexWrap: "wrap"
            }
        });
        const options = [
            [
                "auto",
                (0, _language.LANG)("auto") + ` → ${autoLanguage.name} (${autoLanguage.code})`
            ],
            ...(0, _languages.languages).map((item)=>{
                return [
                    item.code,
                    item.name + ` (${item.code})`
                ];
            })
        ];
        const languageSelect = new (0, _kl.KL).Select({
            initValue: (0, _base.nullToUndefined)((0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) ? (0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) : "auto"),
            optionArr: options,
            onChange: (val)=>{
                if (val === "auto") (0, _localStorage.LocalStorage).removeItem((0, _language.LS_LANGUAGE_KEY));
                else (0, _localStorage.LocalStorage).setItem((0, _language.LS_LANGUAGE_KEY), val);
                languageHint.style.display = "block";
            }
        });
        (0, _bb.BB).css(languageSelect.getElement(), {
            flexGrow: "1"
        });
        const languageHint = (0, _bb.BB).el({
            className: "kl-toolspace-note",
            content: (0, _language.LANG)("settings-language-reload"),
            css: {
                display: "none",
                marginTop: "5px",
                flexGrow: "1"
            }
        });
        langWrapper.append(languageSelect.getElement(), languageHint);
        // ---- theme ----
        function themeToLabel(theme) {
            return theme === "dark" ? "⬛ " + (0, _language.LANG)("theme-dark") : "⬜ " + (0, _language.LANG)("theme-light");
        }
        const themeSelect = new (0, _kl.KL).Select({
            optionArr: [
                [
                    "auto",
                    (0, _language.LANG)("auto") + " → " + themeToLabel((0, _theme.theme).getMediaQueryTheme())
                ],
                [
                    "light",
                    themeToLabel("light")
                ],
                [
                    "dark",
                    themeToLabel("dark")
                ]
            ],
            initValue: (0, _theme.theme).getStoredTheme() || "auto",
            onChange: (val)=>{
                (0, _theme.theme).setStoredTheme(val === "auto" ? undefined : val);
            }
        });
        (0, _bb.BB).css(themeSelect.getElement(), {
            flexGrow: "1"
        });
        (0, _base.addIsDarkListener)(()=>{
            themeSelect.updateLabel("auto", (0, _language.LANG)("auto") + " → " + themeToLabel((0, _theme.theme).getMediaQueryTheme()));
        });
        (0, _bb.BB).el({
            parent: this.rootEl,
            content: [
                (0, _bb.BB).el({
                    content: (0, _language.LANG)("settings-theme") + ":",
                    css: {
                        marginRight: "5px",
                        marginBottom: "2px"
                    }
                }),
                themeSelect.getElement()
            ],
            css: {
                marginTop: "15px",
                display: "flex",
                alignItems: "center",
                flexWrap: "wrap"
            }
        });
        // ---- save reminder ----
        if (saveReminder) {
            const reminderSelect = new (0, _kl.KL).Select({
                optionArr: [
                    [
                        "20min",
                        (0, _language.LANG)("x-minutes", {
                            x: "20"
                        })
                    ],
                    [
                        "40min",
                        (0, _language.LANG)("x-minutes", {
                            x: "40"
                        })
                    ],
                    [
                        "disabled",
                        "⚠️ " + (0, _language.LANG)("settings-save-reminder-disabled")
                    ]
                ],
                initValue: saveReminder.getSetting(),
                onChange: (val)=>{
                    if (val !== "disabled") {
                        saveReminder.setSetting(val);
                        return;
                    }
                    const disableStr = (0, _language.LANG)("settings-save-reminder-confirm-disable");
                    (0, _showModal.showModal)({
                        target: document.body,
                        message: "⚠️" + (0, _language.LANG)("settings-save-reminder-confirm-title"),
                        div: (0, _c.c)("", [
                            (0, _c.c)(".info-hint", (0, _language.LANG)("settings-save-reminder-confirm-a")),
                            (0, _language.LANG)("settings-save-reminder-confirm-b")
                        ]),
                        buttons: [
                            disableStr,
                            "Cancel"
                        ],
                        callback: (result)=>{
                            if (result === disableStr) saveReminder.setSetting(val);
                            else reminderSelect.setValue(saveReminder.getSetting());
                        }
                    });
                }
            });
            reminderSelect.getElement().style.flexGrow = "1";
            this.rootEl.append((0, _c.c)(",flex,items-center,gap-5,mt-15,flexWrap", [
                (0, _language.LANG)("settings-save-reminder-label") + ":",
                reminderSelect.getElement()
            ]));
        }
        // ---- flip ui ----
        (0, _bb.BB).el({
            tagName: "button",
            parent: this.rootEl,
            content: '<img height="20" width="18" src="' + (0, _uiSwapLrSvgDefault.default) + '" alt="icon" style="margin-right: 5px"/>' + (0, _language.LANG)("switch-ui-left-right"),
            onClick: ()=>onLeftRight(),
            css: {
                marginTop: "15px"
            },
            custom: {
                tabIndex: "-1"
            }
        });
        // ---- about ----
        this.rootEl.append((0, _bb.BB).el({
            className: "grid-hr",
            css: {
                margin: "10px 0"
            }
        }));
        function makeLicenses() {
            return (0, _bb.BB).el({
                tagName: "a",
                content: (0, _language.LANG)("licenses"),
                onClick: ()=>(0, _showLicensesDialog.showLicensesDialog)()
            });
        }
        if (customAbout) {
            this.rootEl.append(customAbout);
            if (!customAbout.innerHTML) {
                const minimalAbout = (0, _bb.BB).el({
                    parent: customAbout,
                    css: {
                        textAlign: "center"
                    }
                });
                minimalAbout.append((0, _bb.BB).el({
                    content: `<img alt="icon" height="20" style="vertical-align:middle" src="${(0, _bitbofLogoSvgDefault.default)}"> <a href="https://bitbof.com" target="_blank" tabIndex="-1">bitbof</a> © 2023<br>`
                }), makeLicenses());
            }
        } else {
            const versionEl = (0, _bb.BB).el({
                parent: this.rootEl,
                css: {
                    textAlign: "center"
                },
                content: `
<img alt="Klecks" class="dark-invert" height="25" src="${(0, _klecksLogoPngDefault.default)}"><br>
<img alt="icon" height="20" style="vertical-align:middle" src="${(0, _bitbofLogoSvgDefault.default)}"> <a href="https://bitbof.com" target="_blank" tabIndex="-1">bitbof</a> © 2023<br>`
            });
            versionEl.append(makeLicenses(), document.createTextNode(" | "), (0, _bb.BB).el({
                tagName: "a",
                content: (0, _language.LANG)("donate"),
                custom: {
                    href: "https://kleki.com/donate/",
                    target: "_blank"
                }
            }), document.createTextNode(" | "), (0, _bb.BB).el({
                tagName: "a",
                content: (0, _language.LANG)("source-code"),
                custom: {
                    href: "https://klecks.org",
                    target: "_blank"
                }
            }));
        }
        window.addEventListener("storage", (e)=>{
            if (e.key !== (0, _language.LS_LANGUAGE_KEY)) return;
            languageSelect.setValue((0, _base.nullToUndefined)((0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) ? (0, _localStorage.LocalStorage).getItem((0, _language.LS_LANGUAGE_KEY)) : "auto"));
        });
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"dcQKo","../../../language/language":"iiYGN","../../kl":"8nmWp","/src/app/img/bitbof-logo.svg":"fFGFL","/src/app/img/klecks-logo.png":"l2ndI","/src/app/img/ui/ui-swap-lr.svg":"29m0f","../../../bb/base/local-storage":"04p5O","../../../theme/theme":"4G3JB","../../../bb/base/base":"k6nNY","../modals/licenses-dialog/show-licenses-dialog":"Khvyr","../../../bb/base/c":"eg9k9","../modals/base/showModal":"hr9Po","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3","../../../../languages/languages":"5K1G7"}],"fFGFL":[function(require,module,exports) {
module.exports = require("5ce6e338fa7124af").getBundleURL("d3gnI") + "bitbof-logo.780497d6.svg" + "?" + Date.now();

},{"5ce6e338fa7124af":"lgJ39"}],"29m0f":[function(require,module,exports) {
module.exports = require("ddc0f3904e68740d").getBundleURL("d3gnI") + "ui-swap-lr.32bed0c0.svg" + "?" + Date.now();

},{"ddc0f3904e68740d":"lgJ39"}],"Khvyr":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "showLicensesDialog", ()=>showLicensesDialog);
var _c = require("../../../../bb/base/c");
var _css = require("@emotion/css");
var _dynamicModal = require("../base/dynamic-modal");
var _bb = require("../../../../bb/bb");
var _language = require("../../../../language/language");
function showLicensesDialog() {
    const licensesCss = (0, _css.css)({
        display: "flex",
        flexDirection: "column",
        gap: "10px",
        "details > div": {
            padding: "10px",
            boxShadow: "0 0 0 1px",
            marginTop: "5px",
            fontFamily: "monospace",
            background: "#aaa2",
            overflow: "hidden"
        },
        "summary": {
            cursor: "pointer",
            userSelect: "none"
        }
    });
    const libraries = (0, _c.c)("." + licensesCss, (0, _language.LANG)("loading"));
    const fonts = (0, _c.c)("." + licensesCss, (0, _language.LANG)("loading"));
    const content = (0, _c.c)(",flex,flexCol,gap-10", [
        libraries,
        fonts
    ]);
    new (0, _dynamicModal.DynamicModal)({
        title: (0, _bb.BB).el({
            content: (0, _language.LANG)("licenses")
        }),
        content: (0, _bb.BB).el({
            content,
            css: {
                height: "100%",
                overflowY: "auto",
                padding: "10px",
                boxSizing: "border-box"
            }
        }),
        width: 800,
        isMaxHeight: true,
        onClose: ()=>{
            if (window.location.hash === "#licenses") history.replaceState("", document.title, window.location.pathname + window.location.search);
        }
    });
    require("1724060f7208bfc0").then((result)=>{
        libraries.innerHTML = "";
        result.licenses.forEach((item)=>{
            libraries.append((0, _c.c)("details", [
                (0, _c.c)("summary", item.title),
                (0, _c.c)("", item.full.replace(/\n/g, "<br>"))
            ]));
        });
    });
    require("45a71af7bfe324b2").then((result)=>{
        fonts.innerHTML = "";
        result.fontLicenses.forEach((item)=>{
            fonts.append((0, _c.c)("details", [
                (0, _c.c)("summary", "Font: " + item.title),
                (0, _c.c)("", item.full.replace(/\n/g, "<br>"))
            ]));
        });
    });
}

},{"../../../../bb/base/c":"eg9k9","@emotion/css":"gyRZs","../base/dynamic-modal":"52d4a","../../../../bb/bb":"dcQKo","../../../../language/language":"iiYGN","1724060f7208bfc0":"7LjN9","45a71af7bfe324b2":"bdWUh","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7LjN9":[function(require,module,exports) {
module.exports = require("b81f63414eab7e8b")(require("c56cea7b4b7e2881").getBundleURL("d3gnI") + "licenses.ae51f5b4.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("9T8Bv"));

},{"b81f63414eab7e8b":"61B45","c56cea7b4b7e2881":"lgJ39"}],"bdWUh":[function(require,module,exports) {
module.exports = require("3dd4c821d54c3fa4")(require("b2c3d816aff25b66").getBundleURL("d3gnI") + "font-licenses.8c6dc81e.js" + "?" + Date.now()).catch((err)=>{
    delete module.bundle.cache[module.id];
    throw err;
}).then(()=>module.bundle.root("2SIAq"));

},{"3dd4c821d54c3fa4":"61B45","b2c3d816aff25b66":"lgJ39"}],"gytag":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Scroll buttons at the top and bottom of toolspace
 * Show up when window is very small.
 * Allow user to scroll up and down toolspace.
 */ parcelHelpers.export(exports, "ToolspaceScroller", ()=>ToolspaceScroller);
var _bb = require("../../../bb/bb");
var _language = require("../../../language/language");
var _modalCount = require("../modals/modal-count");
class ToolspaceScroller {
    update() {
        let newUpDisplay = this.upBtn.style.display;
        let newDownDisplay = this.downBtn.style.display;
        if (this.toolspace.scrollHeight > this.toolspace.offsetHeight + 3) {
            if (!this.upInterval) newUpDisplay = this.toolspace.scrollTop === 0 ? "none" : "block";
            if (!this.downInterval) newDownDisplay = this.toolspace.scrollTop + this.toolspace.offsetHeight + 1 >= this.toolspace.scrollHeight ? "none" : "block";
        } else {
            newUpDisplay = "none";
            newDownDisplay = "none";
        }
        // check to prevent infinite MutationObserver loop in Pale Moon
        if (newUpDisplay !== this.upBtn.style.display) this.upBtn.style.display = newUpDisplay;
        if (newDownDisplay !== this.downBtn.style.display) this.downBtn.style.display = newDownDisplay;
    }
    // --- public ---
    constructor(p){
        this.toolspace = p.toolspace;
        this.upBtn = (0, _bb.BB).el({
            parent: this.toolspace,
            title: (0, _language.LANG)("scroll"),
            className: "kl-scroller",
            css: {
                top: "0",
                transform: "rotate(180deg)"
            }
        });
        this.downBtn = (0, _bb.BB).el({
            parent: this.toolspace,
            title: (0, _language.LANG)("scroll"),
            className: "kl-scroller",
            css: {
                bottom: "0"
            }
        });
        this.updateUiState(p.uiState);
        const upListener = new (0, _bb.BB).PointerListener({
            target: this.upBtn,
            onPointer: (e)=>{
                if (e.type === "pointerdown") this.upInterval = setInterval(()=>{
                    this.toolspace.scrollBy(0, -13);
                    this.update();
                }, 20);
                if (e.type === "pointerup") {
                    clearInterval(this.upInterval);
                    setTimeout(()=>{
                        this.upInterval = null;
                        this.update();
                    }, 50);
                }
            }
        });
        const downListener = new (0, _bb.BB).PointerListener({
            target: this.downBtn,
            onPointer: (e)=>{
                if (e.type === "pointerdown") this.downInterval = setInterval(()=>{
                    this.toolspace.scrollBy(0, 13);
                    this.update();
                }, 20);
                if (e.type === "pointerup") {
                    clearInterval(this.downInterval);
                    setTimeout(()=>{
                        this.downInterval = null;
                        this.update();
                    }, 50);
                }
            }
        });
        const wheelListener = (e)=>{
            this.toolspace.scrollBy(0, Math.round(0.7 * e.deltaY));
            this.update();
        };
        this.upBtn.addEventListener("wheel", wheelListener);
        this.downBtn.addEventListener("wheel", wheelListener);
        this.update();
        const observer = new MutationObserver(()=>this.update());
        observer.observe(this.toolspace, {
            attributes: true,
            childList: true,
            subtree: true
        });
        window.addEventListener("resize", ()=>this.update());
        // hide if in dialog because that can have its own scrollbar
        (0, _modalCount.dialogCounter).subscribe((v)=>{
            // ignores the 0.5 by tool dropdown
            this.upBtn.style.opacity = v >= 1 ? "0" : "";
            this.downBtn.style.opacity = v >= 1 ? "0" : "";
        });
    }
    updateUiState(uiState) {
        (0, _bb.BB).css(this.upBtn, {
            left: uiState === "left" ? "0" : "",
            right: uiState === "right" ? "0" : ""
        });
        (0, _bb.BB).css(this.downBtn, {
            left: uiState === "left" ? "0" : "",
            right: uiState === "right" ? "0" : ""
        });
    }
}

},{"../../../bb/bb":"dcQKo","../../../language/language":"iiYGN","../modals/modal-count":"lsSVM","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"boDxv":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Gradient Tool tab contents
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "GradientUi", ()=>GradientUi);
var _bb = require("../../../bb/bb");
var _klSlider = require("../components/kl-slider");
var _language = require("../../../language/language");
var _checkbox = require("../components/checkbox");
var _options = require("../components/options");
class GradientUi {
    updateIcons() {
        const col1 = this.settings.isReversed ? "#0000" : "#000";
        const col2 = this.settings.isReversed ? "#000" : "#0000";
        this.iconArr[0].style.background = `linear-gradient(${col1}, ${col2})`;
        this.iconArr[1].style.background = `linear-gradient(${col2}, ${col1}, ${col2})`;
        this.iconArr[2].style.background = `radial-gradient(${col1}, ${col2})`;
    }
    // ----- public -------
    constructor(p){
        this.settings = {
            opacity: 1,
            type: "linear",
            doLockAlpha: false,
            doSnap: false,
            isReversed: false,
            isEraser: false
        };
        this.colorSlider = p.colorSlider;
        this.rootEl = (0, _bb.BB).el({
            css: {
                margin: "10px"
            }
        });
        this.isVisible = true;
        this.colorDiv = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                marginBottom: "10px"
            }
        });
        this.iconArr = [];
        {
            const size = 33;
            [
                0,
                1,
                2
            ].forEach(()=>{
                const el = (0, _bb.BB).el({
                    className: "dark-invert",
                    css: {
                        width: size + "px",
                        height: size + "px",
                        borderRadius: "3px",
                        margin: "1px"
                    }
                });
                this.iconArr.push(el);
            });
        }
        this.updateIcons();
        const typeOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: "linear",
                    label: this.iconArr[0],
                    title: (0, _language.LANG)("gradient-linear")
                },
                {
                    id: "linear-mirror",
                    label: this.iconArr[1],
                    title: (0, _language.LANG)("gradient-linear-mirror")
                },
                {
                    id: "radial",
                    label: this.iconArr[2],
                    title: (0, _language.LANG)("gradient-radial")
                }
            ],
            initId: "linear",
            onChange: (id)=>{
                this.settings.type = id;
            }
        });
        this.rootEl.append(typeOptions.getElement());
        const opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("opacity"),
            width: 250,
            height: 30,
            min: 0.01,
            max: 1,
            value: this.settings.opacity,
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100,
            onChange: (val)=>{
                this.settings.opacity = val;
            }
        });
        (0, _bb.BB).css(opacitySlider.getElement(), {
            marginTop: "10px"
        });
        this.rootEl.append(opacitySlider.getElement());
        const row1 = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: "flex",
                alignItems: "center",
                marginTop: "10px"
            }
        });
        const reverseToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("reverse"),
            callback: (b)=>{
                this.settings.isReversed = b;
                this.updateIcons();
            },
            css: {
                width: "50%"
            }
        });
        const doSnapToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("angle-snap"),
            title: (0, _language.LANG)("angle-snap-title"),
            callback: (b)=>{
                this.settings.doSnap = b;
            },
            css: {
                width: "50%"
            }
        });
        row1.append(reverseToggle.getElement(), doSnapToggle.getElement());
        const row2 = (0, _bb.BB).el({
            parent: this.rootEl,
            css: {
                display: "flex",
                alignItems: "center",
                marginTop: "10px"
            }
        });
        const eraserToggle = new (0, _checkbox.Checkbox)({
            init: this.settings.isEraser,
            label: (0, _language.LANG)("eraser"),
            callback: (b)=>{
                this.settings.isEraser = b;
            },
            css: {
                width: "50%"
            }
        });
        const lockAlphaToggle = new (0, _checkbox.Checkbox)({
            init: false,
            label: (0, _language.LANG)("lock-alpha"),
            title: (0, _language.LANG)("lock-alpha-title"),
            callback: (b)=>{
                this.settings.doLockAlpha = b;
            },
            doHighlight: true,
            css: {
                width: "50%"
            }
        });
        row2.append(eraserToggle.getElement(), lockAlphaToggle.getElement());
    }
    getElement() {
        return this.rootEl;
    }
    setIsVisible(isVisible) {
        this.isVisible = !!isVisible;
        this.rootEl.style.display = isVisible ? "block" : "none";
        if (isVisible) this.colorDiv.append(this.colorSlider.getElement(), this.colorSlider.getOutputElement());
    }
    getSettings() {
        return (0, _bb.BB).copyObj(this.settings);
    }
}

},{"../../../bb/bb":"dcQKo","../components/kl-slider":"4hcvv","../../../language/language":"iiYGN","../components/checkbox":"8fYiz","../components/options":"hNLP6","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1tywk":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "KlApp", ()=>KlApp);
var _kl = require("../klecks/kl");
var _klHistory = require("../klecks/history/kl-history");
var _bb = require("../bb/bb");
var _showIframeModal = require("../klecks/ui/modals/show-iframe-modal");
var _embedToolspaceTopRow = require("../embed/embed-toolspace-top-row");
var _filtersLazy = require("../klecks/filters/filters-lazy");
var _base64ToBlob = require("../klecks/storage/base-64-to-blob");
var _klCanvasToPsdBlob = require("../klecks/storage/kl-canvas-to-psd-blob");
var _language = require("../language/language");
var _localStorage = require("../bb/base/local-storage");
var _lineSmoothing = require("../klecks/events/line-smoothing");
var _lineSanitizer = require("../klecks/events/line-sanitizer");
var _translateSmoothing = require("../klecks/utils/translate-smoothing");
var _importHandler = require("./import-handler");
var _toolPaintSvg = require("/src/app/img/ui/tool-paint.svg");
var _toolPaintSvgDefault = parcelHelpers.interopDefault(_toolPaintSvg);
var _toolHandSvg = require("/src/app/img/ui/tool-hand.svg");
var _toolHandSvgDefault = parcelHelpers.interopDefault(_toolHandSvg);
var _toolFillSvg = require("/src/app/img/ui/tool-fill.svg");
var _toolFillSvgDefault = parcelHelpers.interopDefault(_toolFillSvg);
var _toolGradientSvg = require("/src/app/img/ui/tool-gradient.svg");
var _toolGradientSvgDefault = parcelHelpers.interopDefault(_toolGradientSvg);
var _toolTextSvg = require("/src/app/img/ui/tool-text.svg");
var _toolTextSvgDefault = parcelHelpers.interopDefault(_toolTextSvg);
var _toolShapeSvg = require("/src/app/img/ui/tool-shape.svg");
var _toolShapeSvgDefault = parcelHelpers.interopDefault(_toolShapeSvg);
var _tabSettingsSvg = require("/src/app/img/ui/tab-settings.svg");
var _tabSettingsSvgDefault = parcelHelpers.interopDefault(_tabSettingsSvg);
var _tabLayersSvg = require("/src/app/img/ui/tab-layers.svg");
var _tabLayersSvgDefault = parcelHelpers.interopDefault(_tabLayersSvg);
var _consoleApi = require("./console-api");
var _eraseColor = require("../klecks/brushes/erase-color");
var _base = require("../bb/base/base");
var _klConfig = require("../klecks/kl-config");
(0, _filtersLazy.importFilters)();
class KlApp {
    updateCollapse() {
        //collapser
        if (this.uiWidth < this.collapseThreshold) {
            this.toolspaceCollapser.getElement().style.display = "block";
            this.toolspaceCollapser.setDirection(this.uiState);
            if (this.toolspaceCollapser.isOpen()) {
                if (this.uiState === "left") {
                    (0, _bb.BB).css(this.toolspaceCollapser.getElement(), {
                        left: "271px",
                        right: ""
                    });
                    (0, _bb.BB).css(this.klCanvasWorkspace.getElement(), {
                        left: "271px"
                    });
                } else {
                    (0, _bb.BB).css(this.toolspaceCollapser.getElement(), {
                        left: "",
                        right: "271px"
                    });
                    (0, _bb.BB).css(this.klCanvasWorkspace.getElement(), {
                        left: "0"
                    });
                }
                this.toolspace.style.display = "block";
                this.klCanvasWorkspace.setSize(Math.max(0, this.uiWidth - this.toolWidth), this.uiHeight);
                this.statusOverlay.setWide(false);
            } else {
                if (this.uiState === "left") {
                    (0, _bb.BB).css(this.toolspaceCollapser.getElement(), {
                        left: "0",
                        right: ""
                    });
                    (0, _bb.BB).css(this.klCanvasWorkspace.getElement(), {
                        left: "0"
                    });
                } else {
                    (0, _bb.BB).css(this.toolspaceCollapser.getElement(), {
                        left: "",
                        right: "0"
                    });
                    (0, _bb.BB).css(this.klCanvasWorkspace.getElement(), {
                        left: "0"
                    });
                }
                this.toolspace.style.display = "none";
                this.klCanvasWorkspace.setSize(Math.max(0, this.uiWidth), this.uiHeight);
                this.statusOverlay.setWide(true);
            }
        } else {
            this.toolspaceCollapser.getElement().style.display = "none";
            if (this.uiState === "left") (0, _bb.BB).css(this.klCanvasWorkspace.getElement(), {
                left: "271px"
            });
            else (0, _bb.BB).css(this.klCanvasWorkspace.getElement(), {
                left: "0"
            });
            this.toolspace.style.display = "block";
            this.klCanvasWorkspace.setSize(Math.max(0, this.uiWidth - this.toolWidth), this.uiHeight);
            this.statusOverlay.setWide(false);
        }
    }
    updateBottomBar() {
        if (!this.bottomBar) return;
        const isVisible = this.toolspaceInner.scrollHeight + 40 < window.innerHeight;
        const newDisplay = isVisible ? "" : "none";
        // check to prevent infinite MutationObserver loop in Pale Moon
        if (newDisplay !== this.bottomBarWrapper.style.display) this.bottomBarWrapper.style.display = newDisplay;
    }
    updateUi() {
        this.toolspace.classList.toggle("kl-toolspace--left", this.uiState === "left");
        this.toolspace.classList.toggle("kl-toolspace--right", this.uiState === "right");
        if (this.uiState === "left") {
            (0, _bb.BB).css(this.toolspace, {
                left: "0",
                right: ""
            });
            (0, _bb.BB).css(this.klCanvasWorkspace.getElement(), {
                left: "271px"
            });
        } else {
            (0, _bb.BB).css(this.toolspace, {
                left: "",
                right: "0"
            });
            (0, _bb.BB).css(this.klCanvasWorkspace.getElement(), {
                left: "0"
            });
        }
        this.statusOverlay.setUiState(this.uiState);
        this.layerPreview.setUiState(this.uiState);
        this.layerManager.setUiState(this.uiState);
        this.updateCollapse();
        this.toolspaceScroller.updateUiState(this.uiState);
    }
    // -------- public --------
    constructor(pProject, pOptions){
        this.collapseThreshold = 820;
        this.toolWidth = 271;
        this.getPSD = async ()=>{
            return await (0, _klCanvasToPsdBlob.klCanvasToPsdBlob)(this.klCanvas);
        };
        this.embed = pOptions.embed;
        // default 2048, unless your screen is bigger than that (that computer then probably has the horsepower for that)
        // but not larger than 4096 - a fairly arbitrary decision
        const klMaxCanvasSize = Math.min(4096, Math.max(2048, Math.max(window.screen.width, window.screen.height)));
        this.uiState = this.embed ? "left" : (0, _localStorage.LocalStorage).getItem("uiState") ? (0, _localStorage.LocalStorage).getItem("uiState") : "right";
        const projectStore = pOptions.projectStore;
        this.klRootEl = (0, _bb.BB).el({
            className: "g-root",
            css: {
                position: "absolute",
                left: "0",
                top: "0",
                right: "0",
                bottom: "0"
            }
        });
        this.uiWidth = Math.max(0, window.innerWidth);
        this.uiHeight = Math.max(0, window.innerHeight);
        let exportType = "png";
        this.klCanvas = new (0, _kl.KL).KlCanvas(pProject ? {
            projectObj: pProject
        } : {
            width: Math.max(10, Math.min(klMaxCanvasSize, window.innerWidth < this.collapseThreshold ? this.uiWidth : this.uiWidth - this.toolWidth)),
            height: Math.max(10, Math.min(klMaxCanvasSize, this.uiHeight))
        }, this.embed ? -1 : 0);
        this.klCanvas.setHistory((0, _klHistory.klHistory));
        let initState;
        let mainTabRow = undefined;
        if (!pOptions.saveReminder) pOptions.saveReminder = {
            init: ()=>{},
            reset: ()=>{}
        };
        if (pProject) {
            // attempt at freeing memory
            pProject.layers.forEach((layer)=>{
                layer.image = null;
            });
            pProject = null;
        } else {
            (0, _klHistory.klHistory).pause(true);
            this.klCanvas.addLayer();
            this.klCanvas.layerFill(0, {
                r: (0, _eraseColor.ERASE_COLOR),
                g: (0, _eraseColor.ERASE_COLOR),
                b: (0, _eraseColor.ERASE_COLOR)
            });
            (0, _klHistory.klHistory).pause(false);
        }
        try {
            initState = {
                canvas: new (0, _kl.KL).KlCanvas({
                    copy: this.klCanvas
                }, this.embed ? -1 : 0),
                focus: this.klCanvas.getLayerCount() - 1,
                brushes: {}
            };
        } catch (e) {
            if (e.message === "kl-create-canvas-error") this.klCanvas.destroy();
            throw e;
        }
        Object.entries((0, _kl.KL).brushes).forEach(([b, Brush])=>{
            initState.brushes[b] = new Brush();
            if (initState.canvas) initState.brushes[b].setContext(initState.canvas.getLayerContext(initState.focus));
        });
        let currentColor = new (0, _bb.BB).RGB(0, 0, 0);
        let currentBrushUi; // todo
        let currentBrushId;
        let lastNonEraserBrushId;
        let currentLayerCtx = (0, _base.throwIfNull)(this.klCanvas.getLayerContext(this.klCanvas.getLayerCount() - 1));
        // when cycling through brushes you need to know the next non-eraser brush
        const getNextBrushId = ()=>{
            if (currentBrushId === "eraserBrush") return lastNonEraserBrushId;
            const keyArr = Object.keys(brushUiMap).filter((item)=>item !== "eraserBrush");
            const i = keyArr.findIndex((item)=>item === currentBrushId);
            return keyArr[(i + 1) % keyArr.length];
        };
        const sizeWatcher = (val)=>{
            brushSettingService.emitSize(val);
            if (this.klCanvasWorkspace) this.klCanvasWorkspace.setCursorSize(val * 2);
        };
        const brushSettingService = new (0, _kl.KL).BrushSettingService((color)=>{
            this.klColorSlider.setColor(color);
            currentBrushUi.setColor(color);
            currentColor = (0, _bb.BB).copyObj(color);
        }, (size)=>{
            currentBrushUi.setSize(size);
            this.klCanvasWorkspace.setCursorSize(size * 2);
        }, (opacity)=>{
            currentBrushUi.setOpacity(opacity);
        }, ()=>this.klColorSlider.getColor(), ()=>brushUiMap[currentBrushId].getSize(), ()=>brushUiMap[currentBrushId].getOpacity(), ()=>{
            return {
                sizeSlider: (0, _kl.KL).brushesUI[currentBrushId].sizeSlider,
                opacitySlider: (0, _kl.KL).brushesUI[currentBrushId].opacitySlider
            };
        });
        const lineSmoothing = new (0, _lineSmoothing.LineSmoothing)({
            smoothing: (0, _translateSmoothing.translateSmoothing)(1)
        });
        this.lineSanitizer = new (0, _lineSanitizer.LineSanitizer)();
        const drawEventChain = new (0, _bb.BB).EventChain({
            chainArr: [
                this.lineSanitizer,
                lineSmoothing
            ]
        });
        drawEventChain.setChainOut((event)=>{
            if (event.type === "down") {
                this.toolspace.style.pointerEvents = "none";
                currentBrushUi.startLine(event.x, event.y, event.pressure);
                this.klCanvasWorkspace.requestFrame();
            }
            if (event.type === "move") {
                currentBrushUi.goLine(event.x, event.y, event.pressure, false, event.isCoalesced);
                this.klCanvasWorkspace.setLastDrawEvent(event.x, event.y, event.pressure);
                this.klCanvasWorkspace.requestFrame();
            }
            if (event.type === "up") {
                this.toolspace.style.pointerEvents = "";
                currentBrushUi.endLine();
                this.klCanvasWorkspace.requestFrame();
            }
            if (event.type === "line") {
                currentBrushUi.getBrush().drawLineSegment(event.x0, event.y0, event.x1, event.y1);
                this.klCanvasWorkspace.requestFrame();
            }
        });
        let textToolSettings = {
            size: 20,
            align: "left",
            isBold: false,
            isItalic: false,
            font: "sans-serif",
            letterSpacing: 0,
            lineHeight: 1,
            fill: {
                color: {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                }
            }
        };
        this.klCanvasWorkspace = new (0, _kl.KL).KlCanvasWorkspace({
            klCanvas: this.klCanvas,
            width: Math.max(0, this.uiWidth - this.toolWidth),
            height: this.uiHeight,
            onDraw: (e)=>drawEventChain.chainIn(e),
            onPick: (rgbObj, isDragDone)=>{
                brushSettingService.setColor(rgbObj);
                if (isDragDone) {
                    this.klColorSlider.pickingDone();
                    this.klCanvasWorkspace.setMode(this.toolspaceToolRow.getActive());
                }
            },
            onFill: (canvasX, canvasY)=>{
                const layerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(currentLayerCtx.canvas));
                this.klCanvas.floodFill(layerIndex, canvasX, canvasY, fillUi.getIsEraser() ? null : this.klColorSlider.getColor(), fillUi.getOpacity(), fillUi.getTolerance(), fillUi.getSample(), fillUi.getGrow(), fillUi.getContiguous());
                this.klCanvasWorkspace.requestFrame();
            },
            onGradient: (typeStr, canvasX, canvasY, angleRad)=>{
                if (typeStr === "down") gradientTool.onDown(canvasX, canvasY, angleRad);
                if (typeStr === "move") gradientTool.onMove(canvasX, canvasY);
                if (typeStr === "up") gradientTool.onUp(canvasX, canvasY);
            },
            onText: (canvasX, canvasY, angleRad)=>{
                if ((0, _kl.KL).dialogCounter.get() > 0) return;
                (0, _kl.KL).textToolDialog({
                    klCanvas: this.klCanvas,
                    layerIndex: (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(currentLayerCtx.canvas)),
                    primaryColor: this.klColorSlider.getColor(),
                    secondaryColor: this.klColorSlider.getSecondaryRGB(),
                    text: {
                        ...textToolSettings,
                        text: "",
                        x: canvasX,
                        y: canvasY,
                        angleRad: angleRad,
                        fill: textToolSettings.fill ? {
                            color: {
                                ...this.klColorSlider.getColor(),
                                a: textToolSettings.fill.color.a
                            }
                        } : undefined,
                        stroke: textToolSettings.stroke ? {
                            ...textToolSettings.stroke,
                            color: {
                                ...this.klColorSlider.getSecondaryRGB(),
                                a: textToolSettings.stroke.color.a
                            }
                        } : undefined
                    },
                    onConfirm: (val)=>{
                        textToolSettings = {
                            ...val,
                            text: ""
                        };
                        const layerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(currentLayerCtx.canvas));
                        this.klCanvas.text(layerIndex, val);
                        this.klCanvasWorkspace.requestFrame();
                    }
                });
            },
            onShape: (typeStr, canvasX, canvasY, angleRad)=>{
                if (typeStr === "down") shapeTool.onDown(canvasX, canvasY, angleRad);
                if (typeStr === "move") shapeTool.onMove(canvasX, canvasY);
                if (typeStr === "up") shapeTool.onUp(canvasX, canvasY);
            },
            onViewChange: (viewChangeObj)=>{
                if (viewChangeObj.changed.includes("scale")) this.statusOverlay.out({
                    type: "transform",
                    scale: viewChangeObj.scale,
                    angleDeg: viewChangeObj.angle * 180 / Math.PI
                });
                this.toolspaceToolRow.setEnableZoomIn(viewChangeObj.scale !== this.klCanvasWorkspace.getMaxScale());
                this.toolspaceToolRow.setEnableZoomOut(viewChangeObj.scale !== this.klCanvasWorkspace.getMinScale());
                handUi.update(viewChangeObj.scale, viewChangeObj.angle * 180 / Math.PI);
            },
            onUndo: ()=>{
                if ((0, _klHistory.klHistory).canUndo()) {
                    if (undoRedoCatchup.undo()) this.statusOverlay.out((0, _language.LANG)("undo"), true);
                }
            },
            onRedo: ()=>{
                if ((0, _klHistory.klHistory).canRedo()) {
                    if (undoRedoCatchup.redo()) this.statusOverlay.out((0, _language.LANG)("redo"), true);
                }
            }
        });
        const updateMainTabVisibility = ()=>{
            if (!mainTabRow) return;
            const toolObj = {
                "draw": {},
                "hand": {},
                "fill": {},
                "gradient": {},
                "text": {},
                "shape": {}
            };
            const activeStr = this.toolspaceToolRow.getActive();
            const oldTabId = mainTabRow.getOpenedTabId();
            const keysArr = Object.keys(toolObj);
            for(let i = 0; i < keysArr.length; i++)if (activeStr === keysArr[i]) mainTabRow.setIsVisible(keysArr[i], true);
            else {
                mainTabRow.setIsVisible(keysArr[i], false);
                if (oldTabId === keysArr[i]) mainTabRow.open(activeStr);
            }
        };
        const keyListener = new (0, _bb.BB).KeyListener({
            onDown: (keyStr, event, comboStr)=>{
                if ((0, _kl.KL).dialogCounter.get() > 0 || (0, _bb.BB).isInputFocused(true)) return;
                const isDrawing = this.lineSanitizer.getIsDrawing() || this.klCanvasWorkspace.getIsDrawing();
                if (isDrawing) return;
                if (comboStr === "plus") this.klCanvasWorkspace.zoomByStep(keyListener.isPressed("shift") ? 1 / 8 : 0.5);
                if (comboStr === "minus") this.klCanvasWorkspace.zoomByStep(keyListener.isPressed("shift") ? -1 / 8 : -0.5);
                if (comboStr === "home") this.klCanvasWorkspace.fitView(true);
                if (comboStr === "end") this.klCanvasWorkspace.resetView(true);
                if ([
                    "ctrl+z",
                    "cmd+z"
                ].includes(comboStr)) {
                    event.preventDefault();
                    undoRedoCatchup.undo();
                }
                if ([
                    "ctrl+y",
                    "cmd+y"
                ].includes(comboStr) || ((0, _bb.BB).sameKeys("ctrl+shift+z", comboStr) || (0, _bb.BB).sameKeys("cmd+shift+z", comboStr)) && keyStr === "z") {
                    event.preventDefault();
                    undoRedoCatchup.redo();
                }
                if (!this.embed) {
                    if ([
                        "ctrl+s",
                        "cmd+s"
                    ].includes(comboStr)) {
                        event.preventDefault();
                        this.saveToComputer.save();
                    }
                    if ([
                        "ctrl+shift+s",
                        "cmd+shift+s"
                    ].includes(comboStr)) {
                        event.preventDefault();
                        (async ()=>{
                            let success = true;
                            try {
                                await projectStore.store(this.klCanvas.getProject());
                            } catch (e) {
                                success = false;
                                setTimeout(()=>{
                                    throw new Error("keyboard-shortcut: failed to store browser storage, " + e);
                                }, 0);
                                this.statusOverlay.out("❌ " + (0, _language.LANG)("file-storage-failed"), true);
                            }
                            if (success) {
                                pOptions.saveReminder.reset();
                                this.statusOverlay.out((0, _language.LANG)("file-storage-stored"), true);
                            }
                        })();
                    }
                    if ([
                        "ctrl+c",
                        "cmd+c"
                    ].includes(comboStr)) {
                        event.preventDefault();
                        copyToClipboard(true);
                    }
                }
                if ([
                    "ctrl+a",
                    "cmd+a"
                ].includes(comboStr)) event.preventDefault();
                if (keyListener.comboOnlyContains([
                    "left",
                    "right",
                    "up",
                    "down"
                ])) {
                    if (keyStr === "left") this.klCanvasWorkspace.translateView(1, 0);
                    if (keyStr === "right") this.klCanvasWorkspace.translateView(-1, 0);
                    if (keyStr === "up") this.klCanvasWorkspace.translateView(0, 1);
                    if (keyStr === "down") this.klCanvasWorkspace.translateView(0, -1);
                }
                if ([
                    "r+left",
                    "r+right"
                ].includes(comboStr)) {
                    if (keyStr === "left") {
                        this.klCanvasWorkspace.setAngle(-15, true);
                        handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
                    }
                    if (keyStr === "right") {
                        this.klCanvasWorkspace.setAngle(15, true);
                        handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
                    }
                }
                if ([
                    "r+up"
                ].includes(comboStr)) {
                    this.klCanvasWorkspace.setAngle(0);
                    handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
                }
                if (comboStr === "sqbr_open") currentBrushUi.decreaseSize(0.03 / this.klCanvasWorkspace.getScale());
                if (comboStr === "sqbr_close") currentBrushUi.increaseSize(0.03 / this.klCanvasWorkspace.getScale());
                if (comboStr === "enter") {
                    this.klCanvas.layerFill((0, _base.throwIfNull)(this.klCanvas.getLayerIndex(currentLayerCtx.canvas)), this.klColorSlider.getColor());
                    this.statusOverlay.out((0, _language.LANG)("filled"), true);
                }
                if ([
                    "delete",
                    "backspace"
                ].includes(comboStr)) {
                    const layerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(currentLayerCtx.canvas));
                    if (layerIndex === 0 && !brushUiMap.eraserBrush.getIsTransparentBg()) this.klCanvas.layerFill(layerIndex, {
                        r: 255,
                        g: 255,
                        b: 255
                    }, "source-in");
                    else this.klCanvas.clearLayer(layerIndex);
                    this.statusOverlay.out((0, _language.LANG)("cleared-layer"), true);
                }
                if (comboStr === "shift+e") {
                    event.preventDefault();
                    currentBrushUi.toggleEraser && currentBrushUi.toggleEraser();
                } else if (comboStr === "e") {
                    event.preventDefault();
                    this.klCanvasWorkspace.setMode("draw");
                    this.toolspaceToolRow.setActive("draw");
                    mainTabRow && mainTabRow.open("draw");
                    updateMainTabVisibility();
                    brushTabRow.open("eraserBrush");
                }
                if (comboStr === "b") {
                    event.preventDefault();
                    const prevMode = this.klCanvasWorkspace.getMode();
                    this.klCanvasWorkspace.setMode("draw");
                    this.toolspaceToolRow.setActive("draw");
                    mainTabRow && mainTabRow.open("draw");
                    updateMainTabVisibility();
                    brushTabRow.open(prevMode === "draw" ? getNextBrushId() : currentBrushId);
                }
                if (comboStr === "g") {
                    event.preventDefault();
                    const newMode = this.klCanvasWorkspace.getMode() === "fill" ? "gradient" : "fill";
                    this.klCanvasWorkspace.setMode(newMode);
                    this.toolspaceToolRow.setActive(newMode);
                    mainTabRow && mainTabRow.open(newMode);
                    updateMainTabVisibility();
                }
                if (comboStr === "t") {
                    event.preventDefault();
                    this.klCanvasWorkspace.setMode("text");
                    this.toolspaceToolRow.setActive("text");
                    mainTabRow && mainTabRow.open("text");
                    updateMainTabVisibility();
                }
                if (comboStr === "u") {
                    event.preventDefault();
                    this.klCanvasWorkspace.setMode("shape");
                    this.toolspaceToolRow.setActive("shape");
                    mainTabRow && mainTabRow.open("shape");
                    updateMainTabVisibility();
                }
                if (comboStr === "x") {
                    event.preventDefault();
                    this.klColorSlider.swapColors();
                }
            },
            onUp: (keyStr, event)=>{}
        });
        const brushUiMap = {};
        // create brush UIs
        Object.entries((0, _kl.KL).brushesUI).forEach(([b, brushUi])=>{
            const ui = new brushUi.Ui({
                onSizeChange: sizeWatcher,
                onOpacityChange: (opacity)=>{
                    brushSettingService.emitOpacity(opacity);
                },
                onConfigChange: ()=>{
                    brushSettingService.emitSliderConfig({
                        sizeSlider: (0, _kl.KL).brushesUI[currentBrushId].sizeSlider,
                        opacitySlider: (0, _kl.KL).brushesUI[currentBrushId].opacitySlider
                    });
                }
            });
            brushUiMap[b] = ui;
            ui.getElement().style.padding = "10px";
        });
        this.statusOverlay = new (0, _kl.KL).StatusOverlay();
        this.toolspace = (0, _bb.BB).el({
            className: "kl-toolspace",
            css: {
                position: "absolute",
                right: "0",
                top: "0",
                bottom: "0",
                width: this.toolWidth + "px",
                overflow: "hidden",
                userSelect: "none",
                touchAction: "none"
            }
        });
        this.toolspaceInner = (0, _bb.BB).el({
            parent: this.toolspace
        });
        this.toolspace.oncontextmenu = ()=>{
            return false;
        };
        this.toolspace.onclick = (0, _bb.BB).handleClick;
        this.toolspaceCollapser = new (0, _kl.KL).ToolspaceCollapser({
            onChange: ()=>{
                this.updateCollapse();
            }
        });
        this.updateCollapse();
        let overlayToolspace;
        setTimeout(()=>{
            overlayToolspace = new (0, _kl.KL).OverlayToolspace({
                enabledTest: ()=>{
                    return (0, _kl.KL).dialogCounter.get() === 0 && !this.lineSanitizer.getIsDrawing();
                },
                brushSettingService
            });
            this.klRootEl.append(overlayToolspace.getElement());
        }, 0);
        (0, _bb.BB).append(this.klRootEl, [
            this.klCanvasWorkspace.getElement(),
            this.toolspace,
            this.toolspaceCollapser.getElement()
        ]);
        let toolspaceTopRow;
        if (this.embed) toolspaceTopRow = new (0, _embedToolspaceTopRow.EmbedToolspaceTopRow)({
            onHelp: ()=>{
                (0, _showIframeModal.showIframeModal)(this.embed.url + "/help.html", !!this.embed);
            },
            onSubmit: ()=>{
                const onFailure = ()=>{
                    let closeFunc;
                    const saveBtn = (0, _bb.BB).el({
                        tagName: "button",
                        textContent: (0, _language.LANG)("save-reminder-save-psd"),
                        css: {
                            display: "block"
                        }
                    });
                    saveBtn.onclick = ()=>{
                        this.saveAsPsd();
                        closeFunc();
                    };
                    (0, _kl.KL).popup({
                        target: this.klRootEl,
                        message: "<b>" + (0, _language.LANG)("upload-failed") + "</b>",
                        div: (0, _bb.BB).el({
                            content: [
                                (0, _bb.BB).el({
                                    content: (0, _language.LANG)("backup-drawing"),
                                    css: {
                                        marginBottom: "10px"
                                    }
                                }),
                                saveBtn
                            ]
                        }),
                        ignoreBackground: true,
                        closeFunc: (f)=>{
                            closeFunc = f;
                        }
                    });
                };
                (0, _kl.KL).popup({
                    target: this.klRootEl,
                    message: (0, _language.LANG)("submit-prompt"),
                    buttons: [
                        (0, _language.LANG)("submit"),
                        "Cancel"
                    ],
                    callback: async (result)=>{
                        if (result !== (0, _language.LANG)("submit")) return;
                        const overlay = (0, _bb.BB).el({
                            parent: this.klRootEl,
                            className: "upload-overlay",
                            content: '<div class="spinner"></div> ' + (0, _language.LANG)("submit-submitting")
                        });
                        this.embed.onSubmit(()=>{
                            pOptions.saveReminder.reset();
                            overlay.remove();
                        }, ()=>{
                            overlay.remove();
                            onFailure();
                        });
                    }
                });
            },
            onLeftRight: ()=>{
                this.uiState = this.uiState === "left" ? "right" : "left";
                this.updateUi();
            }
        });
        else toolspaceTopRow = new (0, _kl.KL).ToolspaceTopRow({
            logoImg: pOptions.logoImg,
            onLogo: ()=>{
                (0, _showIframeModal.showIframeModal)("./home/", !!this.embed);
            },
            onNew: ()=>{
                showNewImageDialog();
            },
            onImport: ()=>{
                fileTab.triggerImport();
            },
            onSave: ()=>{
                this.saveToComputer.save();
            },
            onShare: ()=>{
                shareImage();
            },
            onHelp: ()=>{
                (0, _showIframeModal.showIframeModal)("./help/", !!this.embed);
            }
        });
        toolspaceTopRow.getElement().style.marginBottom = "10px";
        this.toolspaceInner.append(toolspaceTopRow.getElement());
        this.toolspaceToolRow = new (0, _kl.KL).ToolspaceToolRow({
            onActivate: (activeStr)=>{
                if (activeStr === "draw") this.klCanvasWorkspace.setMode("draw");
                else if (activeStr === "hand") this.klCanvasWorkspace.setMode("hand");
                else if (activeStr === "fill") this.klCanvasWorkspace.setMode("fill");
                else if (activeStr === "gradient") this.klCanvasWorkspace.setMode("gradient");
                else if (activeStr === "text") this.klCanvasWorkspace.setMode("text");
                else if (activeStr === "shape") this.klCanvasWorkspace.setMode("shape");
                else throw new Error("unknown activeStr");
                mainTabRow && mainTabRow.open(activeStr);
                updateMainTabVisibility();
                this.klColorSlider.pickingDone();
            },
            onZoomIn: ()=>{
                this.klCanvasWorkspace.zoomByStep(keyListener.isPressed("shift") ? 1 / 8 : 0.5);
            },
            onZoomOut: ()=>{
                this.klCanvasWorkspace.zoomByStep(keyListener.isPressed("shift") ? -1 / 8 : -0.5);
            },
            onUndo: ()=>{
                undoRedoCatchup.undo();
            },
            onRedo: ()=>{
                undoRedoCatchup.redo();
            }
        });
        this.toolspaceToolRow.setIsSmall(this.uiHeight < 540);
        (0, _klHistory.klHistory).addListener(()=>{
            this.toolspaceToolRow.setEnableUndo((0, _klHistory.klHistory).canUndo());
            this.toolspaceToolRow.setEnableRedo((0, _klHistory.klHistory).canRedo());
        });
        this.toolspaceInner.append(this.toolspaceToolRow.getElement());
        const setBrushColor = (p_color)=>{
            currentColor = p_color;
            currentBrushUi.setColor(p_color);
            brushSettingService.emitColor(p_color);
            this.klColorSlider.pickingDone();
        };
        this.klColorSlider = new (0, _kl.KL).KlColorSlider({
            width: 250,
            height: 30,
            svHeight: 100,
            startValue: new (0, _bb.BB).RGB(0, 0, 0),
            onPick: setBrushColor
        });
        this.klColorSlider.setHeight(Math.max(163, Math.min(400, this.uiHeight - 505)));
        this.klColorSlider.setPickCallback((doPick)=>{
            if (doPick) this.klCanvasWorkspace.setMode("pick");
            else {
                this.klCanvasWorkspace.setMode(this.toolspaceToolRow.getActive());
                updateMainTabVisibility();
            }
        });
        const setCurrentBrush = (brushId)=>{
            if (brushId !== "eraserBrush") lastNonEraserBrushId = brushId;
            if (this.klColorSlider) {
                if (brushId === "eraserBrush") this.klColorSlider.enable(false);
                else this.klColorSlider.enable(true);
            }
            currentBrushId = brushId;
            currentBrushUi = brushUiMap[brushId];
            currentBrushUi.setColor(currentColor);
            currentBrushUi.setContext(currentLayerCtx);
            this.klCanvasWorkspace.setMode("draw");
            this.toolspaceToolRow.setActive("draw");
            updateMainTabVisibility();
        };
        const setCurrentLayer = (layer)=>{
            currentLayerCtx = layer.context;
            currentBrushUi.setContext(layer.context);
            this.layerPreview.setLayer(layer);
        };
        const brushDiv = (0, _bb.BB).el();
        const colorDiv = (0, _bb.BB).el({
            css: {
                margin: "10px",
                display: "flex",
                flexWrap: "wrap",
                justifyContent: "space-between",
                alignItems: "flex-end"
            }
        });
        const toolspaceStabilizerRow = new (0, _kl.KL).ToolspaceStabilizerRow({
            smoothing: 1,
            onSelect: (v)=>{
                lineSmoothing.setSmoothing((0, _translateSmoothing.translateSmoothing)(v));
            }
        });
        brushDiv.append(colorDiv);
        (0, _bb.BB).append(colorDiv, [
            this.klColorSlider.getElement(),
            this.klColorSlider.getOutputElement(),
            toolspaceStabilizerRow.getElement()
        ]);
        const brushTabRow = new (0, _kl.KL).TabRow({
            initialId: "penBrush",
            useAccent: true,
            tabArr: (()=>{
                const result = [];
                const createTab = (keyStr)=>{
                    return {
                        id: keyStr,
                        image: (0, _kl.KL).brushesUI[keyStr].image,
                        title: (0, _kl.KL).brushesUI[keyStr].tooltip,
                        onOpen: ()=>{
                            brushUiMap[keyStr].getElement().style.display = "block";
                            setCurrentBrush(keyStr);
                            this.klColorSlider.pickingDone();
                            brushSettingService.emitSliderConfig({
                                sizeSlider: (0, _kl.KL).brushesUI[keyStr].sizeSlider,
                                opacitySlider: (0, _kl.KL).brushesUI[keyStr].opacitySlider
                            });
                            sizeWatcher(brushUiMap[keyStr].getSize());
                            brushSettingService.emitOpacity(brushUiMap[keyStr].getOpacity());
                        },
                        onClose: ()=>{
                            brushUiMap[keyStr].getElement().style.display = "none";
                        }
                    };
                };
                const keyArr = Object.keys(brushUiMap);
                for(let i = 0; i < keyArr.length; i++)result.push(createTab(keyArr[i]));
                return result;
            })()
        });
        (0, _bb.BB).append(brushDiv, [
            brushTabRow.getElement(),
            ...Object.entries((0, _kl.KL).brushesUI).map(([b])=>brushUiMap[b].getElement())
        ]);
        const handUi = new (0, _kl.KL).HandUi({
            scale: this.klCanvasWorkspace.getScale(),
            angleDeg: 0,
            onReset: ()=>{
                this.klCanvasWorkspace.resetView(true);
                handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
            },
            onFit: ()=>{
                this.klCanvasWorkspace.fitView(true);
                handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
            },
            onAngleChange: (angleDeg, isRelative)=>{
                this.klCanvasWorkspace.setAngle(angleDeg, isRelative);
                handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
            }
        });
        const fillUi = new (0, _kl.KL).FillUi({
            colorSlider: this.klColorSlider
        });
        const gradientUi = new (0, _kl.KL).GradientUi({
            colorSlider: this.klColorSlider
        });
        const textUi = new (0, _kl.KL).TextUi({
            colorSlider: this.klColorSlider
        });
        const shapeUi = new (0, _kl.KL).ShapeUi({
            colorSlider: this.klColorSlider
        });
        const gradientTool = new (0, _kl.KL).GradientTool({
            onGradient: (isDone, x1, y1, x2, y2, angleRad)=>{
                const layerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(currentLayerCtx.canvas));
                const settings = gradientUi.getSettings();
                const gradientObj = {
                    type: settings.type,
                    color1: this.klColorSlider.getColor(),
                    isReversed: settings.isReversed,
                    opacity: settings.opacity,
                    doLockAlpha: settings.doLockAlpha,
                    isEraser: settings.isEraser,
                    doSnap: keyListener.isPressed("shift") || settings.doSnap,
                    x1,
                    y1,
                    x2,
                    y2,
                    angleRad
                };
                if (isDone) {
                    this.klCanvas.setComposite(layerIndex, null);
                    this.klCanvas.drawGradient(layerIndex, gradientObj);
                } else this.klCanvas.setComposite(layerIndex, {
                    draw: (ctx)=>{
                        (0, _kl.KL).drawGradient(ctx, gradientObj);
                    }
                });
                this.klCanvasWorkspace.requestFrame();
            }
        });
        const shapeTool = new (0, _kl.KL).ShapeTool({
            onShape: (isDone, x1, y1, x2, y2, angleRad)=>{
                const layerIndex = (0, _base.throwIfNull)(this.klCanvas.getLayerIndex(currentLayerCtx.canvas));
                const shapeObj = {
                    type: shapeUi.getShape(),
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2,
                    angleRad: angleRad,
                    isOutwards: shapeUi.getIsOutwards(),
                    opacity: shapeUi.getOpacity(),
                    isEraser: shapeUi.getIsEraser(),
                    doLockAlpha: shapeUi.getDoLockAlpha()
                };
                if (shapeUi.getShape() === "line") {
                    shapeObj.strokeRgb = this.klColorSlider.getColor();
                    shapeObj.lineWidth = shapeUi.getLineWidth();
                    shapeObj.isAngleSnap = shapeUi.getIsSnap() || keyListener.isPressed("shift");
                } else {
                    shapeObj.isFixedRatio = shapeUi.getIsFixed() || keyListener.isPressed("shift");
                    if (shapeUi.getMode() === "stroke") {
                        shapeObj.strokeRgb = this.klColorSlider.getColor();
                        shapeObj.lineWidth = shapeUi.getLineWidth();
                    } else shapeObj.fillRgb = this.klColorSlider.getColor();
                }
                if (isDone) {
                    this.klCanvas.setComposite(layerIndex, null);
                    this.klCanvas.drawShape(layerIndex, shapeObj);
                } else this.klCanvas.setComposite(layerIndex, {
                    draw: (ctx)=>{
                        (0, _kl.KL).drawShape(ctx, shapeObj);
                    }
                });
                this.klCanvasWorkspace.requestFrame();
            }
        });
        this.layerManager = new (0, _kl.KL).LayerManager(this.klCanvas, (val)=>{
            setCurrentLayer((0, _base.throwIfNull)(this.klCanvas.getLayer(val)));
            (0, _klHistory.klHistory).push({
                tool: [
                    "misc"
                ],
                action: "focusLayer",
                params: [
                    val
                ]
            });
        }, this.klRootEl, this.uiState);
        this.layerPreview = new (0, _kl.KL).LayerPreview({
            klRootEl: this.klRootEl,
            onClick: ()=>{
                mainTabRow && mainTabRow.open("layers");
            },
            uiState: this.uiState
        });
        this.layerPreview.setIsVisible(this.uiHeight >= 579);
        this.layerPreview.setLayer(this.klCanvas.getLayer(this.klCanvas.getLayerIndex(currentLayerCtx.canvas)));
        const filterTab = new (0, _kl.KL).FilterTab(this.klRootEl, this.klColorSlider, this.layerManager, this.klCanvasWorkspace, handUi, ()=>currentColor, ()=>klMaxCanvasSize, ()=>this.klCanvas, ()=>currentLayerCtx, !!this.embed, this.statusOverlay);
        const undoRedoCatchup = new (0, _kl.KL).UndoRedoCatchup(brushUiMap, this.layerPreview, this.layerManager, handUi, this.klCanvasWorkspace, ()=>{
            if (!initState) throw new Error("initState not initialized");
            return initState;
        }, ()=>this.klCanvas, ()=>currentLayerCtx, (ctx)=>{
            currentLayerCtx = ctx;
        }, ()=>currentBrushUi);
        (0, _klHistory.klHistory).addListener((p)=>{
            undoRedoCatchup.catchup(p);
        });
        const showNewImageDialog = ()=>{
            (0, _kl.KL).newImageDialog({
                currentColor: currentColor,
                secondaryColor: this.klColorSlider.getSecondaryRGB(),
                maxCanvasSize: klMaxCanvasSize,
                canvasWidth: this.klCanvas.getWidth(),
                canvasHeight: this.klCanvas.getHeight(),
                workspaceWidth: window.innerWidth < this.collapseThreshold ? this.uiWidth : this.uiWidth - this.toolWidth,
                workspaceHeight: this.uiHeight,
                onConfirm: (width, height, color)=>{
                    this.klCanvas.reset({
                        width: width,
                        height: height,
                        color: color.a === 1 ? color : undefined
                    });
                    this.layerManager.update(0);
                    setCurrentLayer((0, _base.throwIfNull)(this.klCanvas.getLayer(0)));
                    this.klCanvasWorkspace.resetOrFitView();
                    handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
                },
                onCancel: ()=>{}
            });
        };
        const shareImage = (callback)=>{
            (0, _bb.BB).shareCanvas({
                canvas: this.klCanvas.getCompleteCanvas(1),
                fileName: (0, _bb.BB).getDate() + (0, _klConfig.klConfig).filenameBase + ".png",
                title: (0, _bb.BB).getDate() + (0, _klConfig.klConfig).filenameBase + ".png",
                callback: callback ? callback : ()=>{}
            });
        };
        this.saveToComputer = new (0, _kl.KL).SaveToComputer(pOptions.saveReminder, ()=>exportType, ()=>this.klCanvas);
        const copyToClipboard = (showCrop)=>{
            (0, _kl.KL).clipboardDialog(this.klRootEl, this.klCanvas.getCompleteCanvas(1), (inputObj)=>{
                if (inputObj.left === 0 && inputObj.right === 0 && inputObj.top === 0 && inputObj.bottom === 0) return;
                //do a crop
                (0, _kl.KL).filterLib.cropExtend.apply({
                    context: currentLayerCtx,
                    klCanvas: this.klCanvas,
                    input: inputObj,
                    history: (0, _klHistory.klHistory)
                });
                this.layerManager.update();
                this.klCanvasWorkspace.resetOrFitView();
                handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
            }, this.statusOverlay, showCrop || false);
        };
        const fileTab = this.embed ? null : new (0, _kl.KL).FileTab(this.klRootEl, projectStore, ()=>this.klCanvas.getProject(), exportType, (type)=>{
            exportType = type;
        }, (files, optionsStr)=>importHandler.handleFileSelect(files, optionsStr), ()=>this.saveToComputer.save(), showNewImageDialog, shareImage, ()=>{
            (0, _kl.KL).imgurUpload(this.klCanvas, this.klRootEl, pOptions.saveReminder, pOptions.app && pOptions.app.imgurKey ? pOptions.app.imgurKey : "");
        }, copyToClipboard, pOptions.saveReminder);
        const settingsTab = new (0, _kl.KL).SettingsTab(()=>{
            this.uiState = this.uiState === "left" ? "right" : "left";
            this.updateUi();
            if (!this.embed) (0, _localStorage.LocalStorage).setItem("uiState", this.uiState);
        }, this.embed ? undefined : pOptions.saveReminder, pOptions.aboutEl);
        mainTabRow = new (0, _kl.KL).TabRow({
            initialId: "draw",
            tabArr: [
                {
                    id: "draw",
                    title: (0, _language.LANG)("tool-brush"),
                    image: (0, _toolPaintSvgDefault.default),
                    onOpen: ()=>{
                        if (currentBrushId === "eraserBrush") this.klColorSlider.enable(false);
                        (0, _bb.BB).append(colorDiv, [
                            this.klColorSlider.getElement(),
                            this.klColorSlider.getOutputElement(),
                            toolspaceStabilizerRow.getElement()
                        ]);
                        brushDiv.style.display = "block";
                    },
                    onClose: ()=>{
                        brushDiv.style.display = "none";
                    },
                    css: {
                        minWidth: "45px"
                    }
                },
                {
                    id: "hand",
                    title: (0, _language.LANG)("tool-hand"),
                    image: (0, _toolHandSvgDefault.default),
                    isVisible: false,
                    onOpen: ()=>{
                        handUi.setIsVisible(true);
                    },
                    onClose: ()=>{
                        handUi.setIsVisible(false);
                    },
                    css: {
                        minWidth: "45px"
                    }
                },
                {
                    id: "fill",
                    title: (0, _language.LANG)("tool-paint-bucket"),
                    image: (0, _toolFillSvgDefault.default),
                    isVisible: false,
                    onOpen: ()=>{
                        this.klColorSlider.enable(true);
                        fillUi.setIsVisible(true);
                    },
                    onClose: ()=>{
                        fillUi.setIsVisible(false);
                    },
                    css: {
                        minWidth: "45px"
                    }
                },
                {
                    id: "gradient",
                    title: (0, _language.LANG)("tool-gradient"),
                    image: (0, _toolGradientSvgDefault.default),
                    isVisible: false,
                    onOpen: ()=>{
                        this.klColorSlider.enable(true);
                        gradientUi.setIsVisible(true);
                    },
                    onClose: ()=>{
                        gradientUi.setIsVisible(false);
                    },
                    css: {
                        minWidth: "45px"
                    }
                },
                {
                    id: "text",
                    title: (0, _language.LANG)("tool-text"),
                    image: (0, _toolTextSvgDefault.default),
                    isVisible: false,
                    onOpen: ()=>{
                        this.klColorSlider.enable(true);
                        textUi.setIsVisible(true);
                    },
                    onClose: ()=>{
                        textUi.setIsVisible(false);
                    },
                    css: {
                        minWidth: "45px"
                    }
                },
                {
                    id: "shape",
                    title: (0, _language.LANG)("tool-shape"),
                    image: (0, _toolShapeSvgDefault.default),
                    isVisible: false,
                    onOpen: ()=>{
                        this.klColorSlider.enable(true);
                        shapeUi.setIsVisible(true);
                    },
                    onClose: ()=>{
                        shapeUi.setIsVisible(false);
                    },
                    css: {
                        minWidth: "45px"
                    }
                },
                {
                    id: "layers",
                    title: (0, _language.LANG)("layers"),
                    image: (0, _tabLayersSvgDefault.default),
                    onOpen: ()=>{
                        this.layerManager.update();
                        this.layerManager.getElement().style.display = "block";
                    },
                    onClose: ()=>{
                        this.layerManager.getElement().style.display = "none";
                    },
                    css: {
                        minWidth: "45px"
                    }
                },
                {
                    id: "edit",
                    label: (0, _language.LANG)("tab-edit"),
                    onOpen: ()=>{
                        filterTab.show();
                    },
                    onClose: ()=>{
                        filterTab.hide();
                    },
                    css: {
                        padding: "0 7px"
                    }
                },
                {
                    id: "file",
                    label: (0, _language.LANG)("tab-file"),
                    isVisible: !!fileTab,
                    onOpen: ()=>{
                        if (!fileTab) return;
                        fileTab.getElement().style.display = "block";
                        fileTab.setIsVisible(true);
                    },
                    onClose: ()=>{
                        if (!fileTab) return;
                        fileTab.getElement().style.display = "none";
                        fileTab.setIsVisible(false);
                    },
                    css: {
                        padding: "0 7px"
                    }
                },
                {
                    id: "settings",
                    title: (0, _language.LANG)("tab-settings"),
                    image: (0, _tabSettingsSvgDefault.default),
                    onOpen: ()=>{
                        settingsTab.getElement().style.display = "block";
                    // settingsTab.setIsVisible(true);
                    },
                    onClose: ()=>{
                        settingsTab.getElement().style.display = "none";
                    // settingsTab.setIsVisible(false);
                    },
                    css: {
                        minWidth: "45px"
                    }
                }
            ]
        });
        this.bottomBarWrapper = (0, _bb.BB).el({
            css: {
                width: "270px",
                position: "absolute",
                bottom: "0",
                left: "0"
            }
        });
        if (pOptions.bottomBar) {
            this.bottomBar = pOptions.bottomBar;
            this.bottomBarWrapper.append(this.bottomBar);
            const observer = new MutationObserver(()=>this.updateBottomBar());
            observer.observe(this.toolspaceInner, {
                attributes: true,
                childList: true,
                subtree: true
            });
        }
        (0, _bb.BB).append(this.toolspaceInner, [
            this.layerPreview.getElement(),
            mainTabRow.getElement(),
            brushDiv,
            handUi.getElement(),
            fillUi.getElement(),
            gradientUi.getElement(),
            textUi.getElement(),
            shapeUi.getElement(),
            this.layerManager.getElement(),
            filterTab.getElement(),
            fileTab ? fileTab.getElement() : undefined,
            settingsTab.getElement(),
            (0, _bb.BB).el({
                css: {
                    height: "10px"
                }
            }),
            this.bottomBarWrapper ? this.bottomBarWrapper : undefined
        ]);
        this.toolspaceScroller = new (0, _kl.KL).ToolspaceScroller({
            toolspace: this.toolspace,
            uiState: this.uiState
        });
        if (!this.embed) Object.defineProperty(window, "KL", {
            value: (0, _consoleApi.createConsoleApi)({
                onDraw: (path)=>{
                    if (!path || path.length === 0) return;
                    path.forEach((p, index)=>{
                        if (index === 0) currentBrushUi.startLine(p.x, p.y, 1);
                        else currentBrushUi.goLine(p.x, p.y, 1);
                    });
                    currentBrushUi.endLine();
                    this.klCanvasWorkspace.requestFrame();
                }
            }),
            writable: false
        });
        this.resize(this.uiWidth, this.uiHeight);
        this.updateUi();
        const importHandler = new (0, _importHandler.ImportHandler)({
            klRootEl: this.klRootEl,
            klMaxCanvasSize,
            layerManager: this.layerManager,
            setCurrentLayer,
            klCanvas: this.klCanvas,
            klCanvasWorkspace: this.klCanvasWorkspace,
            handUi
        }, {
            onColor: (rgb)=>brushSettingService.setColor(rgb)
        });
        if (!this.embed) {
            new (0, _kl.KL).KlImageDropper({
                target: document.body,
                onDrop: (files, optionStr)=>{
                    if ((0, _kl.KL).dialogCounter.get() > 0) return;
                    importHandler.handleFileSelect(files, optionStr);
                },
                enabledTest: ()=>{
                    return (0, _kl.KL).dialogCounter.get() === 0;
                }
            });
            window.document.addEventListener("paste", (e)=>importHandler.onPaste(e), false);
        }
        {
            window.addEventListener("resize", ()=>{
                this.resize(window.innerWidth, window.innerHeight);
            });
            window.addEventListener("orientationchange", ()=>{
                this.resize(window.innerWidth, window.innerHeight);
            });
            // iPad doesn't trigger 'resize' event when using text zoom, although it's resizing the window.
            // Workaround: place a div in the body that fills the window, and use a ResizeObserver
            const windowResizeWatcher = (0, _bb.BB).el({
                parent: document.body,
                css: {
                    position: "fixed",
                    left: "0",
                    top: "0",
                    right: "0",
                    bottom: "0",
                    pointerEvents: "none",
                    zIndex: "-1",
                    userSelect: "none"
                }
            });
            try {
                // Not all browsers support ResizeObserver. Not critical though.
                const observer = new ResizeObserver(()=>this.resize(window.innerWidth, window.innerHeight));
                observer.observe(windowResizeWatcher);
            } catch (e) {
                windowResizeWatcher.remove();
            }
            // prevent ctrl scroll -> zooming page
            this.klRootEl.addEventListener("wheel", (event)=>{
                if (keyListener.isPressed("ctrl")) event.preventDefault();
            });
            //maybe prevent zooming on safari mac os - todo still needed?
            const prevent = (e)=>{
                e.preventDefault();
            };
            window.addEventListener("gesturestart", prevent);
            window.addEventListener("gesturechange", prevent);
            window.addEventListener("gestureend", prevent);
        }
    }
    // -------- interface --------
    getEl() {
        return this.klRootEl;
    }
    resize(w, h) {
        // iPad scrolls down when increasing text zoom
        if (window.scrollY > 0) window.scrollTo(0, 0);
        if (this.uiWidth === Math.max(0, w) && this.uiHeight === Math.max(0, h)) return;
        this.uiWidth = Math.max(0, w);
        this.uiHeight = Math.max(0, h);
        this.updateCollapse();
        this.updateBottomBar();
        this.layerPreview.setIsVisible(this.uiHeight >= 579);
        this.klColorSlider.setHeight(Math.max(163, Math.min(400, this.uiHeight - 505)));
        this.toolspaceToolRow.setIsSmall(this.uiHeight < 540);
    }
    out(msg) {
        this.statusOverlay.out(msg);
    }
    getPNG() {
        return (0, _base64ToBlob.base64ToBlob)(this.klCanvas.getCompleteCanvas(1).toDataURL("image/png"));
    }
    getProject() {
        return this.klCanvas.getProject();
    }
    swapUiLeftRight() {
        this.uiState = this.uiState === "left" ? "right" : "left";
        if (!this.embed) (0, _localStorage.LocalStorage).setItem("uiState", this.uiState);
        this.updateUi();
    }
    saveAsPsd() {
        this.saveToComputer.save("psd");
    }
    isDrawing() {
        return this.lineSanitizer.getIsDrawing() || this.klCanvasWorkspace.getIsDrawing();
    }
}

},{"../klecks/kl":"8nmWp","../klecks/history/kl-history":"klzEn","../bb/bb":"dcQKo","../klecks/ui/modals/show-iframe-modal":"2luNL","../embed/embed-toolspace-top-row":"5eqf9","../klecks/filters/filters-lazy":"eBdPo","../klecks/storage/base-64-to-blob":"4JT2T","../klecks/storage/kl-canvas-to-psd-blob":"gh8aB","../language/language":"iiYGN","../bb/base/local-storage":"04p5O","../klecks/events/line-smoothing":"573tG","../klecks/events/line-sanitizer":"gOeVc","../klecks/utils/translate-smoothing":"4b82o","./import-handler":"1HaN7","/src/app/img/ui/tool-paint.svg":"cAWlT","/src/app/img/ui/tool-hand.svg":"anjr6","/src/app/img/ui/tool-fill.svg":"fT68h","/src/app/img/ui/tool-gradient.svg":"er4Xu","/src/app/img/ui/tool-text.svg":"jYwrt","/src/app/img/ui/tool-shape.svg":"3ZxcT","/src/app/img/ui/tab-settings.svg":"cXRWb","/src/app/img/ui/tab-layers.svg":"87cTe","./console-api":"S0mIC","../klecks/brushes/erase-color":"lUgDd","../bb/base/base":"k6nNY","../klecks/kl-config":"argRu","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5eqf9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Topmost row of buttons in toolspace. (embed)
 *
 * @param p
 * @constructor
 */ parcelHelpers.export(exports, "EmbedToolspaceTopRow", ()=>EmbedToolspaceTopRow);
var _bb = require("../bb/bb");
var _uiSwapLrSvg = require("/src/app/img/ui/ui-swap-lr.svg");
var _uiSwapLrSvgDefault = parcelHelpers.interopDefault(_uiSwapLrSvg);
var _helpSvg = require("/src/app/img/ui/help.svg");
var _helpSvgDefault = parcelHelpers.interopDefault(_helpSvg);
var _language = require("../language/language");
class EmbedToolspaceTopRow {
    // ---- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            className: "kl-toolspace-row",
            css: {
                height: "36px",
                display: "flex"
            }
        });
        function createButton(p) {
            const padding = 6 + (p.extraPadding ? p.extraPadding : 0);
            const el = (0, _bb.BB).el({
                className: "toolspace-row-button nohighlight",
                title: p.title,
                onClick: p.onClick,
                css: {
                    padding: p.content ? "" : p.contain ? padding + "px 0" : ""
                }
            });
            if (p.content) el.append(p.content);
            else {
                const im = (0, _bb.BB).el({
                    className: "dark-invert",
                    css: {
                        backgroundImage: "url('" + p.image + "')",
                        backgroundRepeat: "no-repeat",
                        backgroundPosition: "center",
                        backgroundSize: p.contain ? "contain" : "",
                        //filter: 'grayscale(1)',
                        height: "100%"
                    }
                });
                im.style.pointerEvents = "none";
                el.append(im);
            }
            const pointerListener = new (0, _bb.BB).PointerListener({
                target: el,
                onEnterLeave: function(isOver) {
                    el.classList.toggle("toolspace-row-button-hover", isOver);
                }
            });
            return {
                el,
                pointerListener
            };
        }
        const submitButton = createButton({
            onClick: p.onSubmit,
            title: (0, _language.LANG)("submit-title"),
            content: (0, _bb.BB).el({
                content: (0, _language.LANG)("submit"),
                className: "toolspace-row-button__submit",
                css: {
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center",
                    width: "100%",
                    height: "100%"
                }
            }),
            contain: true
        });
        submitButton.el.style.width = "45px";
        const helpButton = createButton({
            onClick: p.onHelp,
            title: (0, _language.LANG)("help"),
            image: (0, _helpSvgDefault.default),
            contain: true
        });
        const leftRightButton = createButton({
            onClick: p.onLeftRight,
            title: (0, _language.LANG)("switch-ui-left-right"),
            image: (0, _uiSwapLrSvgDefault.default),
            contain: true
        });
        this.rootEl.append(submitButton.el, leftRightButton.el, helpButton.el);
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../bb/bb":"dcQKo","/src/app/img/ui/ui-swap-lr.svg":"29m0f","/src/app/img/ui/help.svg":"e1IQ4","../language/language":"iiYGN","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eBdPo":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "importFilters", ()=>importFilters);
var _filters = require("./filters");
var _filterBrightnessContrast = require("./filter-brightness-contrast");
var _filterCropExtend = require("./filter-crop-extend");
var _filterCurves = require("./filter-curves");
var _filterFlip = require("./filter-flip");
var _filterHueSaturation = require("./filter-hue-saturation");
var _filterInvert = require("./filter-invert");
var _filterPerspective = require("./filter-perspective");
var _filterResize = require("./filter-resize");
var _filterRotate = require("./filter-rotate");
var _filterTiltShift = require("./filter-tilt-shift");
var _filterTransform = require("./filter-transform");
var _filterBlur = require("./filter-blur");
var _filterUnsharpMask = require("./filter-unsharp-mask");
var _filterToAlpha = require("./filter-to-alpha");
var _filterGrid = require("./filter-grid");
var _filterNoise = require("./filter-noise");
var _filterPattern = require("./filter-pattern");
var _filterDistort = require("./filter-distort");
var _filterVanishPoint = require("./filter-vanish-point");
function importFilter(libObj, moduleObj) {
    if (moduleObj.getDialog) libObj.getDialog = moduleObj.getDialog;
    libObj.apply = moduleObj.apply;
}
function importFilters() {
    if ((0, _filters.filterLibStatus).isLoaded) return;
    importFilter((0, _filters.filterLib).brightnessContrast, (0, _filterBrightnessContrast.filterBrightnessContrast));
    importFilter((0, _filters.filterLib).cropExtend, (0, _filterCropExtend.filterCropExtend));
    importFilter((0, _filters.filterLib).curves, (0, _filterCurves.filterCurves));
    importFilter((0, _filters.filterLib).flip, (0, _filterFlip.filterFlip));
    importFilter((0, _filters.filterLib).hueSaturation, (0, _filterHueSaturation.filterHueSaturation));
    importFilter((0, _filters.filterLib).invert, (0, _filterInvert.filterInvert));
    importFilter((0, _filters.filterLib).perspective, (0, _filterPerspective.filterPerspective));
    importFilter((0, _filters.filterLib).resize, (0, _filterResize.filterResize));
    importFilter((0, _filters.filterLib).rotate, (0, _filterRotate.filterRotate));
    importFilter((0, _filters.filterLib).tiltShift, (0, _filterTiltShift.filterTiltShift));
    importFilter((0, _filters.filterLib).transform, (0, _filterTransform.filterTransform));
    importFilter((0, _filters.filterLib).blur, (0, _filterBlur.filterBlur));
    importFilter((0, _filters.filterLib).unsharpMask, (0, _filterUnsharpMask.filterUnsharpMask));
    importFilter((0, _filters.filterLib).toAlpha, (0, _filterToAlpha.filterToAlpha));
    importFilter((0, _filters.filterLib).grid, (0, _filterGrid.filterGrid));
    importFilter((0, _filters.filterLib).noise, (0, _filterNoise.filterNoise));
    importFilter((0, _filters.filterLib).pattern, (0, _filterPattern.filterPattern));
    importFilter((0, _filters.filterLib).distort, (0, _filterDistort.filterDistort));
    importFilter((0, _filters.filterLib).vanishPoint, (0, _filterVanishPoint.filterVanishPoint));
    (0, _filters.filterLibStatus).isLoaded = true;
}

},{"./filters":"lIjDv","./filter-brightness-contrast":"8bXtn","./filter-crop-extend":"46o4U","./filter-curves":"gJs7S","./filter-flip":"4eiAA","./filter-hue-saturation":"kj8ue","./filter-invert":"1YJog","./filter-perspective":"3vxXl","./filter-resize":"kqYtn","./filter-rotate":"8CV7p","./filter-tilt-shift":"5Dznd","./filter-transform":"7kdP4","./filter-blur":"5iOmO","./filter-unsharp-mask":"1fHVB","./filter-to-alpha":"iGpbg","./filter-grid":"bN7Vm","./filter-noise":"eLTh7","./filter-pattern":"ltDe9","./filter-distort":"dW7B1","./filter-vanish-point":"ftQ30","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"8bXtn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterBrightnessContrast", ()=>filterBrightnessContrast);
var _klSlider = require("../ui/components/kl-slider");
var _filtersConsts = require("./filters-consts");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _language = require("../../language/language");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _emotionCssCjs = require("@emotion/css/dist/emotion-css.cjs");
var _bb = require("../../bb/bb");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterBrightnessContrast = {
    getDialog (params) {
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        let brightness = 0, contrast = 0;
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas)=>{
                return fxCanvas.brightnessContrast(brightness, contrast);
            }
        });
        function finishInit() {
            const brightnessSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-bright-contrast-brightness"),
                width: 300,
                height: 30,
                min: 0,
                max: 100,
                value: (brightness + 1) * 50,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    brightness = val / 50 - 1;
                    preview.render();
                }
            });
            const contrastSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-bright-contrast-contrast"),
                width: 300,
                height: 30,
                min: 0,
                max: 100,
                value: (contrast + 1) * 50,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    contrast = val / 50 - 1;
                    preview.render();
                }
            });
            brightnessSlider.getElement().style.marginBottom = "10px";
            contrastSlider.getElement().style.marginBottom = "10px";
            rootEl.append(brightnessSlider.getElement(), contrastSlider.getElement());
            const previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
                isVisible: layers[i].isVisible,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr,
                hasClipping: false
            });
            const preview = new (0, _preview.Preview)({
                width: (0, _previewSize.getPreviewWidth)(isSmall),
                height: (0, _previewSize.getPreviewHeight)(isSmall),
                project: {
                    width: context.canvas.width,
                    height: context.canvas.height,
                    layers: previewLayerArr
                }
            });
            preview.render();
            preview.getElement().classList.add((0, _emotionCssCjs.css)({
                marginLeft: "-20px",
                marginRight: "-20px"
            }));
            rootEl.append(preview.getElement());
            result.destroy = ()=>{
                brightnessSlider.destroy();
                contrastSlider.destroy();
                fxPreviewRenderer.destroy();
                preview.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    brightness: brightness,
                    contrast: contrast
                };
            };
        }
        setTimeout(finishInit, 1); // the canvas isn't ready for some reason
        return result;
    },
    apply (params) {
        const context = params.context;
        const brightness = params.input.brightness;
        const contrast = params.input.contrast;
        const history = params.history;
        if (!context || !history) return false;
        history.pause(true);
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).brightnessContrast(brightness, contrast).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(fxCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "brightnessContrast"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../ui/components/kl-slider":"4hcvv","./filters-consts":"7Xzbl","../../fx-canvas/shared-fx":"oGCP8","../../language/language":"iiYGN","../ui/project-viewport/fx-preview-renderer":"1TBrm","../ui/project-viewport/preview":"iWTRk","@emotion/css/dist/emotion-css.cjs":"djBls","../../bb/bb":"dcQKo","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Xzbl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "eventResMs", ()=>eventResMs);
const eventResMs = 60;

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1TBrm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "FxPreviewRenderer", ()=>FxPreviewRenderer);
var _bb = require("../../../bb/bb");
var _sharedFx = require("../../../fx-canvas/shared-fx");
var _base = require("../../../bb/base/base");
var _transformationMatrix = require("transformation-matrix");
var _createTransformMatrix = require("./utils/create-transform-matrix");
class FxPreviewRenderer {
    // --- public ---
    constructor(p){
        this.texture = undefined;
        this.oldOnUpdateProps = {
            textureWidth: 0,
            textureHeight: 0,
            transform: {
                scaleX: 0,
                scaleY: 0,
                angleDeg: 0,
                x: 0,
                y: 0
            }
        };
        this.render = (viewportTransform, viewportWidth, viewportHeight)=>{
            const viewportMat = (0, _createTransformMatrix.createTransformMatrix)(viewportTransform);
            const padding = 0; // render more than visible with padding < 0
            let clippedViewportRect; // rect in viewport coordinates which contains the canvas
            {
                const topLeft = (0, _transformationMatrix.applyToPoint)(viewportMat, {
                    x: 0,
                    y: 0
                });
                const bottomRight = (0, _transformationMatrix.applyToPoint)(viewportMat, {
                    x: this.original.width,
                    y: this.original.height
                });
                bottomRight.x = Math.round(bottomRight.x);
                bottomRight.y = Math.round(bottomRight.y);
                const clippedTL = {
                    x: Math.max(padding, topLeft.x),
                    y: Math.max(padding, topLeft.y)
                };
                const clippedBR = {
                    x: Math.min(viewportWidth - padding, bottomRight.x),
                    y: Math.min(viewportHeight - padding, bottomRight.y)
                };
                clippedViewportRect = {
                    x: clippedTL.x,
                    y: clippedTL.y,
                    width: clippedBR.x - clippedTL.x,
                    height: clippedBR.y - clippedTL.y
                };
                if (clippedViewportRect.width <= 0 || clippedViewportRect.height <= 0) {
                    this.textureSource.width = 1;
                    this.textureSource.height = 1;
                    return this.textureSource;
                }
            }
            let resultTransform = (0, _transformationMatrix.compose)((0, _transformationMatrix.inverse)(viewportMat), (0, _transformationMatrix.translate)(padding, padding), (0, _transformationMatrix.translate)(clippedViewportRect.x - padding, clippedViewportRect.y - padding));
            const onUpdateProps = {
                textureWidth: Math.ceil(clippedViewportRect.width),
                textureHeight: Math.ceil(clippedViewportRect.height),
                transform: {
                    scaleX: viewportTransform.scaleX,
                    scaleY: viewportTransform.scaleY,
                    angleDeg: viewportTransform.angleDeg,
                    x: viewportTransform.x - clippedViewportRect.x,
                    y: viewportTransform.y - clippedViewportRect.y
                }
            };
            let tlOffsetX = 0;
            let tlOffsetY = 0;
            if (viewportTransform.scaleX > 1) {
                // what pixels of original canvas are actually visible
                const canvasTopLeft = (0, _transformationMatrix.applyToPoint)(resultTransform, {
                    x: 0,
                    y: 0
                });
                tlOffsetX = -canvasTopLeft.x;
                tlOffsetY = -canvasTopLeft.y;
                canvasTopLeft.x = Math.max(0, Math.floor(canvasTopLeft.x));
                canvasTopLeft.y = Math.max(0, Math.floor(canvasTopLeft.y));
                tlOffsetX += canvasTopLeft.x;
                tlOffsetY += canvasTopLeft.y;
                const canvasBottomRight = (0, _transformationMatrix.applyToPoint)(resultTransform, {
                    x: clippedViewportRect.width,
                    y: clippedViewportRect.height
                });
                canvasBottomRight.x = Math.min(this.original.width, Math.ceil(canvasBottomRight.x));
                canvasBottomRight.y = Math.min(this.original.height, Math.ceil(canvasBottomRight.y));
                const cw = canvasBottomRight.x - canvasTopLeft.x;
                const ch = canvasBottomRight.y - canvasTopLeft.y;
                onUpdateProps.textureWidth = cw;
                onUpdateProps.textureHeight = ch;
                onUpdateProps.transform = {
                    scaleX: 1,
                    scaleY: 1,
                    angleDeg: 0,
                    x: -canvasTopLeft.x,
                    y: -canvasTopLeft.y
                };
                resultTransform = (0, _transformationMatrix.compose)(resultTransform, (0, _transformationMatrix.scale)(viewportTransform.scaleX, viewportTransform.scaleY), (0, _transformationMatrix.translate)(tlOffsetX, tlOffsetY));
            }
            if (!this.texture || JSON.stringify(onUpdateProps) !== JSON.stringify(this.oldOnUpdateProps) || this.postMix) {
                // update texture
                this.textureSource.width = onUpdateProps.textureWidth;
                this.textureSource.height = onUpdateProps.textureHeight;
                // draw original canvas into temp
                this.ctx.save();
                this.ctx.imageSmoothingEnabled = false;
                if (viewportTransform.scaleX > 1) this.ctx.setTransform((0, _createTransformMatrix.createTransformMatrix)(onUpdateProps.transform));
                else this.ctx.setTransform((0, _transformationMatrix.inverse)(resultTransform));
                this.ctx.drawImage(this.original, 0, 0);
                this.ctx.restore();
                // debug
                /*BB.css(this.canvas, {
                position: 'absolute',
                left: '0',
                top: '0',
                zIndex: '1000',
                boxShadow: '0 0 0 1px #f00',
            });
            document.body.append(this.canvas);*/ if (!this.texture || JSON.stringify(onUpdateProps) !== JSON.stringify(this.oldOnUpdateProps)) {
                    this.texture && this.texture.destroy();
                    this.texture = this.fxCanvas.texture(this.textureSource);
                }
                if (!this.postMix) {
                    this.textureSource.width = 1;
                    this.textureSource.height = 1;
                }
            }
            this.oldOnUpdateProps = onUpdateProps;
            const resultFx = this.onUpdate(this.fxCanvas.draw(this.texture), onUpdateProps.transform).update();
            if (this.postMix) {
                this.ctx.save();
                this.ctx.globalAlpha = this.postMix.opacity;
                this.ctx.globalCompositeOperation = this.postMix.operation;
                this.ctx.drawImage(resultFx, 0, 0);
                this.ctx.restore();
                return {
                    image: this.textureSource,
                    transform: resultTransform
                };
            }
            return {
                image: resultFx,
                transform: resultTransform
            };
        };
        this.original = p.original;
        this.onUpdate = p.onUpdate;
        this.textureSource = (0, _bb.BB).canvas(1, 1);
        this.ctx = (0, _bb.BB).ctx(this.textureSource);
        this.fxCanvas = (0, _base.throwIfNull)((0, _sharedFx.getSharedFx)());
        this.postMix = p.postMix;
    }
    setPostMix(postMix) {
        this.postMix = postMix;
    }
    destroy() {
        (0, _bb.BB).freeCanvas(this.textureSource);
        if (this.texture) {
            this.texture = this.fxCanvas.texture(this.textureSource);
            this.fxCanvas.draw(this.texture).update();
            this.texture && this.texture.destroy();
        }
    }
}

},{"../../../bb/bb":"dcQKo","../../../fx-canvas/shared-fx":"oGCP8","../../../bb/base/base":"k6nNY","transformation-matrix":"3I2Wq","./utils/create-transform-matrix":"6WuHP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"46o4U":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterCropExtend", ()=>filterCropExtend);
var _bb = require("../../bb/bb");
var _input = require("../ui/components/input");
var _checkbox = require("../ui/components/checkbox");
var _colorOptions = require("../ui/components/color-options");
var _cropper = require("../ui/components/cropper");
var _language = require("../../language/language");
var _theme = require("../../theme/theme");
var _previewSize = require("../ui/utils/preview-size");
const filterCropExtend = {
    getDialog (params) {
        const klCanvas = params.klCanvas;
        if (!klCanvas) return false;
        const tempCanvas = (0, _bb.BB).canvas();
        {
            const fit = (0, _bb.BB).fitInto(klCanvas.getWidth(), klCanvas.getHeight(), 560, 400, 1);
            const w = parseInt("" + fit.width), h = parseInt("" + fit.height);
            const previewFactor = w / klCanvas.getWidth();
            tempCanvas.width = w;
            tempCanvas.height = h;
            tempCanvas.style.display = "block";
            (0, _bb.BB).ctx(tempCanvas).drawImage(klCanvas.getCompleteCanvas(previewFactor), 0, 0, w, h);
        }
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        let left = 0, right = 0, top = 0, bottom = 0;
        let leftChanged = false, rightChanged = false, topChanged = false, bottomChanged = false;
        const maxWidth = params.maxWidth, maxHeight = params.maxHeight;
        let scale = 1;
        // --- input elements ---
        const lrWrapper = (0, _bb.BB).el({
            css: {
                lineHeight: "30px",
                height: "35px"
            }
        });
        const tbWrapper = (0, _bb.BB).el({
            css: {
                lineHeight: "30px",
                height: "35px"
            }
        });
        rootEl.append(lrWrapper, tbWrapper);
        const leftInput = (0, _input.input)({
            init: 0,
            type: "number",
            min: -klCanvas.getWidth(),
            max: maxWidth,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function() {
                leftChanged = true;
                updateInput();
            }
        });
        const rightInput = (0, _input.input)({
            init: 0,
            type: "number",
            min: -klCanvas.getWidth(),
            max: maxWidth,
            css: {
                width: "75px"
            },
            callback: function() {
                rightChanged = true;
                updateInput();
            }
        });
        const topInput = (0, _input.input)({
            init: 0,
            type: "number",
            min: -klCanvas.getHeight(),
            max: maxHeight,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function() {
                topChanged = true;
                updateInput();
            }
        });
        const bottomInput = (0, _input.input)({
            init: 0,
            type: "number",
            min: -klCanvas.getHeight(),
            max: maxHeight,
            css: {
                width: "75px"
            },
            callback: function() {
                bottomChanged = true;
                updateInput();
            }
        });
        const labelStyle = {
            display: "inline-block",
            width: "60px"
        };
        lrWrapper.append((0, _bb.BB).el({
            content: (0, _language.LANG)("filter-crop-left") + ":",
            css: labelStyle
        }), leftInput, (0, _bb.BB).el({
            content: (0, _language.LANG)("filter-crop-right") + ":",
            css: labelStyle
        }), rightInput);
        tbWrapper.append((0, _bb.BB).el({
            content: (0, _language.LANG)("filter-crop-top") + ":",
            css: labelStyle
        }), topInput, (0, _bb.BB).el({
            content: (0, _language.LANG)("filter-crop-bottom") + ":",
            css: labelStyle
        }), bottomInput);
        function updateInput() {
            left = parseInt(leftInput.value);
            right = parseInt(rightInput.value);
            top = parseInt(topInput.value);
            bottom = parseInt(bottomInput.value);
            let newWidth = klCanvas.getWidth() + left + right;
            let newHeight = klCanvas.getHeight() + top + bottom;
            if (newWidth <= 0) {
                if (leftChanged) {
                    left = -klCanvas.getWidth() - right + 1;
                    leftInput.value = "" + left;
                }
                if (rightChanged) {
                    right = -klCanvas.getWidth() - left + 1;
                    rightInput.value = "" + right;
                }
                newWidth = 1;
            }
            if (newWidth > maxWidth) {
                if (leftChanged) {
                    left = -klCanvas.getWidth() - right + maxWidth;
                    leftInput.value = "" + left;
                }
                if (rightChanged) {
                    right = -klCanvas.getWidth() - left + maxWidth;
                    rightInput.value = "" + right;
                }
                newWidth = maxWidth;
            }
            if (newHeight <= 0) {
                if (topChanged) {
                    top = -klCanvas.getHeight() - bottom + 1;
                    topInput.value = "" + top;
                }
                if (bottomChanged) {
                    bottom = -klCanvas.getHeight() - top + 1;
                    bottomInput.value = "" + bottom;
                }
                newHeight = 1;
            }
            if (newHeight > maxHeight) {
                if (topChanged) {
                    top = -klCanvas.getHeight() - bottom + maxHeight;
                    topInput.value = "" + top;
                }
                if (bottomChanged) {
                    bottom = -klCanvas.getHeight() - top + maxHeight;
                    bottomInput.value = "" + bottom;
                }
                newHeight = maxHeight;
            }
            cropper.setTransform({
                x: -left,
                y: -top,
                width: newWidth,
                height: newHeight
            });
            leftChanged = false;
            rightChanged = false;
            topChanged = false;
            bottomChanged = false;
        }
        let useRuleOfThirds = true;
        const ruleOThirdsCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)("filter-crop-rule-thirds"),
            allowTab: true,
            callback: function(b) {
                useRuleOfThirds = b;
                cropper.showThirds(useRuleOfThirds);
            }
        });
        rootEl.append((0, _bb.BB).el({
            css: {
                clear: "both"
            }
        }));
        let selectedRgbaObj = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        };
        const colorOptionsArr = [
            {
                r: 0,
                g: 0,
                b: 0,
                a: 0
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            },
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            }
        ];
        colorOptionsArr.push({
            r: params.currentColorRgb.r,
            g: params.currentColorRgb.g,
            b: params.currentColorRgb.b,
            a: 1
        });
        colorOptionsArr.push({
            r: params.secondaryColorRgb.r,
            g: params.secondaryColorRgb.g,
            b: params.secondaryColorRgb.b,
            a: 1
        });
        const colorOptions = new (0, _colorOptions.ColorOptions)({
            label: (0, _language.LANG)("filter-crop-fill"),
            colorArr: colorOptionsArr,
            onChange: function(rgbaObj) {
                selectedRgbaObj = rgbaObj;
                updateBg();
            }
        });
        const flexRow = (0, _bb.BB).el({
            css: {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                marginTop: "10px"
            }
        });
        rootEl.append(flexRow);
        flexRow.append(ruleOThirdsCheckbox.getElement(), colorOptions.getElement());
        // when input field changed, or dragging in preview finished
        // adjusts the zoom
        function update(transform) {
            const fit = (0, _bb.BB).fitInto(transform.width, transform.height, 260, 180, 1);
            scale = fit.width / transform.width;
            const offset = (0, _bb.BB).centerWithin((0, _previewSize.smallPreview).width, previewHeight, fit.width, fit.height);
            tempCanvas.style.width = klCanvas.getWidth() * scale + "px";
            tempCanvas.style.height = klCanvas.getHeight() * scale + "px";
            offsetWrapper.style.left = offset.x - transform.x * scale + "px";
            offsetWrapper.style.top = offset.y - transform.y * scale + "px";
            left = parseInt("" + -transform.x);
            top = parseInt("" + -transform.y);
            right = parseInt("" + (transform.x + transform.width - klCanvas.getWidth()));
            bottom = parseInt("" + (transform.y + transform.height - klCanvas.getHeight()));
            leftInput.value = "" + left;
            topInput.value = "" + top;
            rightInput.value = "" + right;
            bottomInput.value = "" + bottom;
            (0, _bb.BB).createCheckerDataUrl(parseInt("" + 50 * scale), function(url) {
                previewWrapper.style.background = "url(" + url + ")";
                if (selectedRgbaObj.a !== 0) tempCanvas.style.background = "url(" + url + ")";
            }, (0, _theme.theme).isDark());
            previewWrapper.style.backgroundPosition = offset.x + "px " + offset.y + "px";
            cropper.setScale(scale);
        }
        const previewHeight = (0, _previewSize.smallPreview).height - 2; // two less because of border
        const previewWrapper = (0, _bb.BB).el({
            className: "kl-edit-crop-preview",
            css: {
                width: (0, _previewSize.smallPreview).width + "px",
                marginTop: "10px",
                marginLeft: "-20px",
                height: previewHeight + "px",
                backgroundColor: "#9e9e9e",
                position: "relative",
                borderTop: "1px solid rgb(144,144,144)",
                borderBottom: "1px solid rgb(144,144,144)",
                overflow: "hidden",
                userSelect: "none",
                touchAction: "none"
            }
        });
        previewWrapper.oncontextmenu = function() {
            return false;
        };
        const bgColorOverlay = (0, _bb.BB).el({
            css: {
                position: "absolute",
                left: "0",
                top: "0",
                bottom: "0",
                right: "0"
            }
        });
        previewWrapper.append(bgColorOverlay);
        const offsetWrapper = (0, _bb.BB).el({
            parent: previewWrapper,
            css: {
                position: "absolute",
                left: "0",
                top: "0"
            }
        });
        (0, _bb.BB).el({
            parent: offsetWrapper,
            content: tempCanvas,
            css: {
                boxShadow: "0 0 0px 1px rgb(130,130,130)",
                position: "absolute",
                left: "0px",
                top: "0px"
            }
        });
        rootEl.append(previewWrapper);
        const cropper = new (0, _cropper.Cropper)({
            x: 0,
            y: 0,
            width: klCanvas.getWidth(),
            height: klCanvas.getHeight(),
            scale: scale,
            callback: update,
            maxW: maxWidth,
            maxH: maxHeight
        });
        update(cropper.getTransform());
        offsetWrapper.append(cropper.getElement());
        function updateBg() {
            if (selectedRgbaObj.a === 0) {
                bgColorOverlay.style.background = "";
                tempCanvas.style.background = "";
            } else {
                bgColorOverlay.style.background = (0, _bb.BB).ColorConverter.toRgbStr(selectedRgbaObj);
                (0, _bb.BB).createCheckerDataUrl(parseInt("" + 50 * scale), function(url) {
                    tempCanvas.style.background = "url(" + url + ")";
                }, (0, _theme.theme).isDark());
            }
        }
        function updateIsDark() {
            updateInput();
        }
        (0, _theme.theme).addIsDarkListener(updateIsDark);
        result.destroy = ()=>{
            cropper.destroy();
            ruleOThirdsCheckbox.destroy();
            (0, _theme.theme).removeIsDarkListener(updateIsDark);
            colorOptions.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                left: left,
                right: right,
                top: top,
                bottom: bottom,
                fillColor: selectedRgbaObj.a === 0 ? undefined : selectedRgbaObj
            };
        };
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        const history = params.history;
        if (!klCanvas || !history || isNaN(params.input.left) || isNaN(params.input.right) || isNaN(params.input.top) || isNaN(params.input.bottom)) return false;
        history.pause(true);
        klCanvas.resizeCanvas(params.input);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "cropExtend"
            ],
            action: "apply",
            params: [
                {
                    input: (0, _bb.BB).copyObj(params.input)
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/components/input":"je8IE","../ui/components/checkbox":"8fYiz","../ui/components/color-options":"iXzf7","../ui/components/cropper":"bajkn","../../language/language":"iiYGN","../../theme/theme":"4G3JB","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gJs7S":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterCurves", ()=>filterCurves);
var _bb = require("../../bb/bb");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _curvesInput = require("./filter-curves/curves-input");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _emotionCssCjs = require("@emotion/css/dist/emotion-css.cjs");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterCurves = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        let curves = (0, _curvesInput.getDefaultCurvesInput)();
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas)=>{
                return fxCanvas.curves(curves.r, curves.g, curves.b);
            }
        });
        function finishInit() {
            const previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
                isVisible: layers[i].isVisible,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr,
                hasClipping: false
            });
            const preview = new (0, _preview.Preview)({
                width: (0, _previewSize.getPreviewWidth)(isSmall),
                height: (0, _previewSize.getPreviewHeight)(isSmall),
                project: {
                    width: context.canvas.width,
                    height: context.canvas.height,
                    layers: previewLayerArr
                }
            });
            preview.getElement().classList.add((0, _emotionCssCjs.css)({
                marginLeft: "-20px",
                marginRight: "-20px"
            }));
            const input = new (0, _curvesInput.CurvesInput)({
                curves,
                callback: function(val) {
                    curves = val;
                    preview.render();
                }
            });
            const modeButtons = input.getModeButtons();
            rootEl.append(input.getElement(), preview.getElement());
            result.destroy = ()=>{
                input.destroy();
                modeButtons.destroy();
                fxPreviewRenderer.destroy();
                preview.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    curves: curves
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        const context = params.context;
        const curves = params.input.curves;
        const history = params.history;
        if (!context || !history) return false;
        history.pause(true);
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).curves(curves.r, curves.g, curves.b).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(fxCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "curves"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../../fx-canvas/shared-fx":"oGCP8","./filter-curves/curves-input":"kuBVK","../ui/project-viewport/fx-preview-renderer":"1TBrm","../ui/project-viewport/preview":"iWTRk","@emotion/css/dist/emotion-css.cjs":"djBls","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kuBVK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "getDefaultCurvesInput", ()=>getDefaultCurvesInput);
parcelHelpers.export(exports, "CurvesInput", ()=>CurvesInput);
var _options = require("../../ui/components/options");
var _language = require("../../../language/language");
var _bb = require("../../../bb/bb");
function getDefaultCurvesInput() {
    return (0, _bb.BB).copyObj({
        r: [
            [
                0,
                0
            ],
            [
                1 / 3,
                1 / 3
            ],
            [
                2 / 3,
                2 / 3
            ],
            [
                1,
                1
            ]
        ],
        g: [
            [
                0,
                0
            ],
            [
                1 / 3,
                1 / 3
            ],
            [
                2 / 3,
                2 / 3
            ],
            [
                1,
                1
            ]
        ],
        b: [
            [
                0,
                0
            ],
            [
                1 / 3,
                1 / 3
            ],
            [
                2 / 3,
                2 / 3
            ],
            [
                1,
                1
            ]
        ]
    });
}
class CurvesInput {
    // ---- public ----
    constructor(p){
        this.rootEl = (0, _bb.BB).el({
            css: {
                position: "relative",
                marginBottom: "10px"
            }
        });
        this.rootEl.oncontextmenu = ()=>false;
        let mode = "All";
        let curves = p.curves;
        this.modeButtons = new (0, _options.Options)({
            optionArr: [
                {
                    id: "All",
                    label: (0, _language.LANG)("filter-curves-all")
                },
                {
                    id: "Red",
                    label: (0, _language.LANG)("red")
                },
                {
                    id: "Green",
                    label: (0, _language.LANG)("green")
                },
                {
                    id: "Blue",
                    label: (0, _language.LANG)("blue")
                }
            ],
            initId: "All",
            onChange: (id)=>{
                mode = id;
                if (mode === "All") curves = getDefaultCurvesInput();
                let curve = curves.r;
                if (mode === "Green") curve = curves.g;
                if (mode === "Blue") curve = curves.b;
                this.p0.setPos(0, areaH - curve[0][1] * areaH);
                this.p1.setPos(curve[1][0] * areaW, areaH - curve[1][1] * areaH);
                this.p2.setPos(curve[2][0] * areaW, areaH - curve[2][1] * areaH);
                this.p3.setPos(areaW, areaH - curve[3][1] * areaH);
                update();
            }
        });
        this.rootEl.append(this.modeButtons.getElement());
        const curveArea = (0, _bb.BB).el({
            parent: this.rootEl,
            className: "kl-curves-graph",
            css: {
                position: "relative",
                marginTop: "10px"
            }
        });
        const areaW = 300, areaH = 100;
        const canvas = (0, _bb.BB).canvas(areaW, areaH);
        let ctx = (0, _bb.BB).ctx(canvas);
        curveArea.append(canvas);
        const fit = (v)=>{
            return Math.max(0, Math.min(1, v));
        };
        const createPoint = (x, y, callback, lock)=>{
            const gripSize = 14;
            let internalY = y, internalX = x;
            const pointEl = (0, _bb.BB).el({
                className: "kl-curves-graph__grip",
                css: {
                    left: x - gripSize / 2 + "px",
                    top: y - gripSize / 2 + "px",
                    width: gripSize + "px",
                    height: gripSize + "px",
                    borderRadius: gripSize + "px"
                }
            });
            const update = ()=>{
                (0, _bb.BB).css(pointEl, {
                    left: x - gripSize / 2 + "px",
                    top: y - gripSize / 2 + "px"
                });
            };
            const pointerListener = new (0, _bb.BB).PointerListener({
                target: pointEl,
                onPointer: (event)=>{
                    event.eventPreventDefault();
                    if (event.type === "pointerdown") {
                        internalX = x;
                        internalY = y;
                    }
                    if (event.button === "left" && event.type === "pointermove") {
                        if (!lock) internalX += event.dX;
                        x = Math.max(0, Math.min(areaW, internalX));
                        internalY += event.dY;
                        y = Math.max(0, Math.min(areaH, internalY));
                        update();
                        callback({
                            x: x,
                            y: y
                        });
                    }
                }
            });
            curveArea.append(pointEl);
            const setPos = (newX, newY)=>{
                x = newX;
                y = newY;
                internalY = y;
                internalX = x;
                (0, _bb.BB).css(pointEl, {
                    left: x - gripSize / 2 + "px",
                    top: y - gripSize / 2 + "px"
                });
            };
            return {
                el: pointEl,
                setPos,
                pointerListener
            };
        };
        const updateControl = (i, x, y)=>{
            if (mode === "All") {
                curves.r[i] = [
                    fit(x / areaW),
                    fit(1 - y / areaH)
                ];
                curves.g[i] = [
                    fit(x / areaW),
                    fit(1 - y / areaH)
                ];
                curves.b[i] = [
                    fit(x / areaW),
                    fit(1 - y / areaH)
                ];
            }
            if (mode === "Red") curves.r[i] = [
                fit(x / areaW),
                fit(1 - y / areaH)
            ];
            if (mode === "Green") curves.g[i] = [
                fit(x / areaW),
                fit(1 - y / areaH)
            ];
            if (mode === "Blue") curves.b[i] = [
                fit(x / areaW),
                fit(1 - y / areaH)
            ];
        };
        this.p0 = createPoint(0, areaH, (val)=>{
            updateControl(0, val.x, val.y);
            update();
        }, true);
        this.p1 = createPoint(areaW / 3, areaH / 3 * 2, (val)=>{
            updateControl(1, val.x, val.y);
            update();
        });
        this.p2 = createPoint(areaW / 3 * 2, areaH / 3, (val)=>{
            updateControl(2, val.x, val.y);
            update();
        });
        this.p3 = createPoint(areaW, 0, (val)=>{
            updateControl(3, val.x, val.y);
            update();
        }, true);
        const update = ()=>{
            ctx = (0, _bb.BB).ctx(canvas);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const outCurves = {
                r: [],
                g: [],
                b: []
            };
            for(let i = 0; i < curves.r.length; i++){
                outCurves.r.push(curves.r[i]);
                outCurves.g.push(curves.g[i]);
                outCurves.b.push(curves.b[i]);
            }
            const drawCurve = (curve)=>{
                ctx.beginPath();
                const spline = new (0, _bb.BB).SplineInterpolator(curve);
                for(let i = 0; i < 100; i++){
                    let y = spline.interpolate(i / 100);
                    y = Math.max(0, Math.min(1, y));
                    if (i === 0) ctx.moveTo(i / 100 * areaW, areaH - y * areaH);
                    else ctx.lineTo(i / 100 * areaW, areaH - y * areaH);
                }
                ctx.stroke();
            };
            ctx.save();
            if (mode === "All") {
                ctx.strokeStyle = "black";
                drawCurve(outCurves.r);
            } else {
                ctx.globalAlpha = 0.5;
                ctx.strokeStyle = "red";
                drawCurve(outCurves.r);
                ctx.strokeStyle = "green";
                drawCurve(outCurves.g);
                ctx.strokeStyle = "blue";
                drawCurve(outCurves.b);
            }
            ctx.restore();
            p.callback(outCurves);
        };
        update();
    }
    // ---- interface ----
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.p0.pointerListener.destroy();
        this.p1.pointerListener.destroy();
        this.p2.pointerListener.destroy();
        this.p3.pointerListener.destroy();
    }
    getModeButtons() {
        return this.modeButtons;
    }
}

},{"../../ui/components/options":"hNLP6","../../../language/language":"iiYGN","../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4eiAA":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterFlip", ()=>filterFlip);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/components/checkbox");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _language = require("../../language/language");
var _base = require("../../bb/base/base");
var _options = require("../ui/components/options");
var _previewSize = require("../ui/utils/preview-size");
const filterFlip = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, 280, 200, 1);
        const w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        let isHorizontal = true;
        let isVertical = false;
        let doFlipCanvas = true;
        const horizontalCheckbox = new (0, _checkbox.Checkbox)({
            init: isHorizontal,
            label: (0, _language.LANG)("filter-flip-horizontal") + " ⟷",
            allowTab: true,
            callback: function(v) {
                isHorizontal = v;
                updatePreview();
            },
            css: {
                marginBottom: "10px"
            }
        });
        const verticalCheckbox = new (0, _checkbox.Checkbox)({
            init: isVertical,
            label: (0, _language.LANG)("filter-flip-vertical") + " ↕",
            allowTab: true,
            callback: function(v) {
                isVertical = v;
                updatePreview();
            },
            css: {
                marginBottom: "10px"
            }
        });
        rootEl.append(horizontalCheckbox.getElement());
        rootEl.append(verticalCheckbox.getElement());
        const targetOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: true,
                    label: (0, _language.LANG)("filter-flip-image")
                },
                {
                    id: false,
                    label: (0, _language.LANG)("filter-flip-layer")
                }
            ],
            onChange: (val)=>{
                doFlipCanvas = val;
                updatePreview();
            }
        });
        rootEl.append(targetOptions.getElement());
        const previewWrapper = (0, _bb.BB).el({
            className: "kl-preview-wrapper",
            css: {
                width: (0, _previewSize.smallPreview).width + "px",
                height: (0, _previewSize.smallPreview).height + "px"
            }
        });
        const previewLayer = {
            image: (0, _bb.BB).canvas(Math.round(w), Math.round(h)),
            isVisible: true,
            opacity: 1,
            mixModeStr: "source-over"
        };
        const klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
            width: Math.round(w),
            height: Math.round(h),
            layers: [
                previewLayer
            ]
        });
        const previewInnerWrapper = (0, _bb.BB).el({
            className: "kl-preview-wrapper__canvas",
            css: {
                width: parseInt("" + w) + "px",
                height: parseInt("" + h) + "px"
            }
        });
        previewInnerWrapper.append(klCanvasPreview.getElement());
        previewWrapper.append(previewInnerWrapper);
        function updatePreview() {
            const ctx = (0, _bb.BB).ctx(previewLayer.image);
            ctx.save();
            ctx.clearRect(0, 0, previewLayer.image.width, previewLayer.image.height);
            if (doFlipCanvas) {
                if (isHorizontal) {
                    ctx.translate(previewLayer.image.width, 0);
                    ctx.scale(-1, 1);
                }
                if (isVertical) {
                    ctx.translate(0, previewLayer.image.height);
                    ctx.scale(1, -1);
                }
            }
            for(let i = 0; i < layers.length; i++){
                if (!layers[i].isVisible) continue;
                ctx.save();
                if (!doFlipCanvas && selectedLayerIndex === i) {
                    if (isHorizontal) {
                        ctx.translate(previewLayer.image.width, 0);
                        ctx.scale(-1, 1);
                    }
                    if (isVertical) {
                        ctx.translate(0, previewLayer.image.height);
                        ctx.scale(1, -1);
                    }
                }
                if (ctx.canvas.width > layers[i].context.canvas.width) ctx.imageSmoothingEnabled = false;
                ctx.globalAlpha = layers[i].opacity;
                ctx.globalCompositeOperation = layers[i].mixModeStr;
                ctx.drawImage(layers[i].context.canvas, 0, 0, previewLayer.image.width, previewLayer.image.height);
                ctx.restore();
            }
            klCanvasPreview.render();
            ctx.restore();
        }
        setTimeout(updatePreview, 0);
        rootEl.append(previewWrapper);
        result.destroy = ()=>{
            horizontalCheckbox.destroy();
            verticalCheckbox.destroy();
            targetOptions.destroy();
            klCanvasPreview.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return {
                horizontal: isHorizontal,
                vertical: isVertical,
                flipCanvas: doFlipCanvas
            };
        };
        return result;
    },
    apply (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        const history = params.history;
        const horizontal = params.input.horizontal;
        const vertical = params.input.vertical;
        const flipCanvas = params.input.flipCanvas;
        if (!context || !klCanvas || !history) return false;
        history.pause(true);
        klCanvas.flip(horizontal, vertical, flipCanvas ? undefined : (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas)));
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "flip"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/components/checkbox":"8fYiz","../canvas-ui/canvas-preview":"gRZnS","../../language/language":"iiYGN","../../bb/base/base":"k6nNY","../ui/components/options":"hNLP6","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kj8ue":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterHueSaturation", ()=>filterHueSaturation);
var _filtersConsts = require("./filters-consts");
var _klSlider = require("../ui/components/kl-slider");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _language = require("../../language/language");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _emotionCssCjs = require("@emotion/css/dist/emotion-css.cjs");
var _bb = require("../../bb/bb");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterHueSaturation = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        let hue = 0, saturation = 0;
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas)=>{
                return fxCanvas.hueSaturation(hue, saturation);
            }
        });
        function finishInit() {
            const hueSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-hue-sat-hue"),
                width: 300,
                height: 30,
                min: -100,
                max: 100,
                value: hue * 100,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    hue = val / 100;
                    preview.render();
                }
            });
            const saturationSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-hue-sat-saturation"),
                width: 300,
                height: 30,
                min: 0,
                max: 100,
                value: (saturation + 1) * 50,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    saturation = val / 50 - 1;
                    preview.render();
                }
            });
            hueSlider.getElement().style.marginBottom = "10px";
            saturationSlider.getElement().style.marginBottom = "10px";
            rootEl.append(hueSlider.getElement(), saturationSlider.getElement());
            const previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
                isVisible: layers[i].isVisible,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr,
                hasClipping: false
            });
            const preview = new (0, _preview.Preview)({
                width: (0, _previewSize.getPreviewWidth)(isSmall),
                height: (0, _previewSize.getPreviewHeight)(isSmall),
                project: {
                    width: context.canvas.width,
                    height: context.canvas.height,
                    layers: previewLayerArr
                }
            });
            preview.render();
            preview.getElement().classList.add((0, _emotionCssCjs.css)({
                marginLeft: "-20px",
                marginRight: "-20px"
            }));
            rootEl.append(preview.getElement());
            result.destroy = ()=>{
                hueSlider.destroy();
                saturationSlider.destroy();
                fxPreviewRenderer.destroy();
                preview.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    hue: hue,
                    saturation: saturation
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        const context = params.context;
        const hue = params.input.hue;
        const history = params.history;
        const saturation = params.input.saturation;
        if (!context || hue === null || saturation === null || !history) return false;
        history.pause(true);
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).hueSaturation(hue, saturation).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(fxCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "hueSaturation"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"./filters-consts":"7Xzbl","../ui/components/kl-slider":"4hcvv","../../fx-canvas/shared-fx":"oGCP8","../../language/language":"iiYGN","../ui/project-viewport/fx-preview-renderer":"1TBrm","../ui/project-viewport/preview":"iWTRk","@emotion/css/dist/emotion-css.cjs":"djBls","../../bb/bb":"dcQKo","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1YJog":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterInvert", ()=>filterInvert);
var _sharedFx = require("../../fx-canvas/shared-fx");
const filterInvert = {
    apply (params) {
        const context = params.context;
        const history = params.history;
        if (!context || !history) return false;
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false;
        history.pause(true);
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).invert().update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(fxCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "invert"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../fx-canvas/shared-fx":"oGCP8","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"3vxXl":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterPerspective", ()=>filterPerspective);
var _bb = require("../../bb/bb");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _language = require("../../language/language");
var _twoTabs = require("../ui/components/two-tabs");
var _transformationMatrix = require("transformation-matrix");
var _preview = require("../ui/project-viewport/preview");
var _base = require("../../bb/base/base");
var _draggableInput = require("../ui/components/draggable-input");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterPerspective = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const isSmall = (0, _testIsSmall.testIsSmall)();
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        if (!isSmall) result.width = (0, _previewSize.mediumPreview).width;
        function finishInit() {
            const fxCanvas = (0, _base.throwIfNull)((0, _sharedFx.getSharedFx)());
            const texture = (0, _base.throwIfUndefined)(fxCanvas?.texture(context.canvas));
            function update() {
                if (isBefore) fxCanvas.draw(texture).update();
                else fxCanvas.draw(texture).perspective(getFlatArr(beforeInputs), getFlatArr(afterInputs)).update();
                preview.render();
            }
            const rectPoints = [
                {
                    x: 0,
                    y: 0
                },
                {
                    x: context.canvas.width,
                    y: 0
                },
                {
                    x: context.canvas.width,
                    y: context.canvas.height
                },
                {
                    x: 0,
                    y: context.canvas.height
                }
            ];
            const beforeInputs = rectPoints.map((point)=>{
                return new (0, _draggableInput.DraggableInput)({
                    value: point,
                    onChange: ()=>{
                        update();
                    }
                });
            });
            beforeInputs.forEach((item)=>item.getElement().style.display = "none");
            const afterInputs = rectPoints.map((point)=>{
                return new (0, _draggableInput.DraggableInput)({
                    value: point,
                    onChange: ()=>{
                        update();
                    }
                });
            });
            function getFlatArr(inputs, matrix) {
                return inputs.flatMap((item)=>{
                    let value = item.getValue();
                    if (matrix) value = (0, _transformationMatrix.applyToPoint)(matrix, value);
                    return [
                        value.x,
                        value.y
                    ];
                });
            }
            let isBefore = false;
            const beforeAfterTabs = new (0, _twoTabs.TwoTabs)({
                left: (0, _language.LANG)("compare-before"),
                right: (0, _language.LANG)("compare-after"),
                init: 1,
                onChange: (val)=>{
                    isBefore = val === 0;
                    if (isBefore) {
                        beforeInputs.forEach((item)=>item.getElement().style.display = "block");
                        afterInputs.forEach((item)=>item.getElement().style.display = "none");
                    } else {
                        beforeInputs.forEach((item, index)=>{
                            afterInputs[index].setValue(item.getValue());
                        });
                        beforeInputs.forEach((item)=>item.getElement().style.display = "none");
                        afterInputs.forEach((item)=>item.getElement().style.display = "block");
                    }
                    update();
                }
            });
            rootEl.append(beforeAfterTabs.getElement());
            const previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? fxCanvas : layers[i].context.canvas,
                isVisible: layers[i].isVisible,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr,
                hasClipping: false
            });
            const preview = new (0, _preview.Preview)({
                width: (0, _previewSize.getPreviewWidth)(isSmall),
                height: (0, _previewSize.getPreviewHeight)(isSmall),
                project: {
                    width: context.canvas.width,
                    height: context.canvas.height,
                    layers: previewLayerArr
                },
                onTransformChange: (transform)=>{
                    beforeInputs.forEach((item)=>item.setTransform(transform));
                    afterInputs.forEach((item)=>item.setTransform(transform));
                }
            });
            (0, _bb.BB).css(preview.getElement(), {
                overflow: "hidden",
                marginLeft: "-20px",
                marginRight: "-20px"
            });
            preview.getElement().append(...beforeInputs.map((item)=>item.getElement()), ...afterInputs.map((item)=>item.getElement()));
            rootEl.append(preview.getElement());
            update();
            result.destroy = ()=>{
                preview.destroy();
                texture.destroy;
                beforeInputs.forEach((item)=>item.destroy());
                afterInputs.forEach((item)=>item.destroy());
            };
            result.getInput = ()=>{
                result.destroy();
                return {
                    before: getFlatArr(beforeInputs),
                    after: getFlatArr(afterInputs)
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        const context = params.context;
        const history = params.history;
        const before = params.input.before;
        const after = params.input.after;
        if (!context || !before || !after || !history) return false;
        history.pause(true);
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).multiplyAlpha().perspective(before, after).unmultiplyAlpha().update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(fxCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "perspective"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../../fx-canvas/shared-fx":"oGCP8","../../language/language":"iiYGN","../ui/components/two-tabs":"edCwK","transformation-matrix":"3I2Wq","../ui/project-viewport/preview":"iWTRk","../../bb/base/base":"k6nNY","../ui/components/draggable-input":"7Vl8c","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"edCwK":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Two buttons next to each other, each representing a tab. one at a time can be active.
 */ parcelHelpers.export(exports, "TwoTabs", ()=>TwoTabs);
var _bb = require("../../../bb/bb");
class TwoTabs {
    update() {
        this.leftTab.classList.toggle("kl-2-tabs--active", this.value === 0);
        this.rightTab.classList.toggle("kl-2-tabs--active", this.value === 1);
    }
    // ---- public ----
    constructor(params){
        this.value = params.init;
        this.rootEl = (0, _bb.BB).el({
            className: "kl-2-tabs"
        });
        this.leftTab = (0, _bb.BB).el({
            parent: this.rootEl,
            content: params.left,
            className: "kl-2-tabs__left"
        });
        this.leftTab.onpointerdown = ()=>false;
        this.rightTab = (0, _bb.BB).el({
            parent: this.rootEl,
            content: params.right,
            className: "kl-2-tabs__right"
        });
        this.rightTab.onpointerdown = ()=>false;
        this.update();
        this.leftTab.onclick = ()=>{
            if (this.value === 0) return;
            this.value = 0;
            this.update();
            params.onChange(this.value);
        };
        this.rightTab.onclick = ()=>{
            if (this.value === 1) return;
            this.value = 1;
            this.update();
            params.onChange(this.value);
        };
    }
    getElement() {
        return this.rootEl;
    }
}

},{"../../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7Vl8c":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "DraggableInput", ()=>DraggableInput);
var _bb = require("../../../bb/bb");
var _transformationMatrix = require("transformation-matrix");
var _createTransformMatrix = require("../project-viewport/utils/create-transform-matrix");
const SIZE = 16;
class DraggableInput {
    update() {
        const p = (0, _transformationMatrix.applyToPoint)((0, _createTransformMatrix.createTransformMatrix)(this.transform), this.value);
        (0, _bb.BB).css(this.rootEl, {
            left: p.x - SIZE / 2 + "px",
            top: p.y - SIZE / 2 + "px"
        });
    }
    // ------ public ------
    constructor(p){
        this.value = {
            ...p.value
        };
        this.transform = {
            x: 0,
            y: 0,
            scale: 1,
            angleDeg: 0
        };
        this.rootEl = (0, _bb.BB).el({
            css: {
                width: SIZE + "px",
                height: SIZE + "px",
                backgroundColor: "#fff",
                border: "2px solid #000",
                borderRadius: SIZE + "px",
                position: "absolute",
                cursor: "move",
                userSelect: "none",
                touchAction: "none"
            }
        });
        this.pointerListener = new (0, _bb.BB).PointerListener({
            target: this.rootEl,
            onPointer: (event)=>{
                event.eventPreventDefault();
                if (event.button === "left" && event.type === "pointermove") {
                    this.value.x += event.dX / this.transform.scale;
                    this.value.y += event.dY / this.transform.scale;
                    this.update();
                    p.onChange(this.value);
                }
            }
        });
    }
    setTransform(transform) {
        if (JSON.stringify(this.transform) === JSON.stringify(transform)) return;
        this.transform = transform;
        this.update();
    }
    getValue() {
        return this.value;
    }
    setValue(p) {
        this.value = {
            ...p
        };
        this.update();
    }
    getElement() {
        return this.rootEl;
    }
    destroy() {
        this.rootEl.remove();
        this.pointerListener.destroy();
    }
}

},{"../../../bb/bb":"dcQKo","transformation-matrix":"3I2Wq","../project-viewport/utils/create-transform-matrix":"6WuHP","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"kqYtn":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterResize", ()=>filterResize);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/components/checkbox");
var _select = require("../ui/components/select");
var _constrainSvg = require("/src/app/img/ui/constrain.svg");
var _constrainSvgDefault = parcelHelpers.interopDefault(_constrainSvg);
var _language = require("../../language/language");
var _table = require("../ui/components/table");
var _theme = require("../../theme/theme");
var _previewSize = require("../ui/utils/preview-size");
const filterResize = {
    getDialog (params) {
        //BB.centerWithin
        const klCanvas = params.klCanvas;
        if (!klCanvas) return false;
        const fit = (0, _bb.BB).fitInto(klCanvas.getWidth(), klCanvas.getHeight(), 280, 200, 1);
        const w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        let previewFactor = w / klCanvas.getWidth();
        const tempCanvas = klCanvas.getCompleteCanvas(1);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        let newWidth = klCanvas.getWidth(), newHeight = klCanvas.getHeight();
        const maxWidth = params.maxWidth, maxHeight = params.maxHeight;
        const widthWrapper = (0, _bb.BB).el({
            css: {
                width: "150px",
                height: "35px",
                lineHeight: "30px"
            }
        });
        const heightWrapper = (0, _bb.BB).el({
            css: {
                width: "150px",
                height: "35px",
                lineHeight: "30px"
            }
        });
        const widthInput = (0, _bb.BB).el({
            tagName: "input",
            css: {
                cssFloat: "right",
                width: "90px"
            },
            custom: {
                type: "number",
                min: "1",
                max: "" + maxWidth,
                value: "" + klCanvas.getWidth()
            }
        });
        const heightInput = (0, _bb.BB).el({
            tagName: "input",
            css: {
                cssFloat: "right",
                width: "90px"
            },
            custom: {
                type: "number",
                min: "1",
                max: "" + maxHeight,
                value: "" + klCanvas.getHeight()
            }
        });
        widthInput.onclick = function() {
            this.focus();
            widthChanged = true;
            update();
        };
        heightInput.onclick = function() {
            this.focus();
            heightChanged = true;
            update();
        };
        widthInput.onchange = function() {
            widthChanged = true;
            update();
        };
        heightInput.onchange = function() {
            heightChanged = true;
            update();
        };
        widthWrapper.append((0, _language.LANG)("width") + ": ", widthInput);
        heightWrapper.append((0, _language.LANG)("height") + ": ", heightInput);
        const inputWrapper = (0, _bb.BB).el({
            css: {
                background: "url(" + (0, _constrainSvgDefault.default) + ") no-repeat 140px 5px",
                backgroundSize: "50px 52px"
            }
        });
        inputWrapper.append(widthWrapper, heightWrapper);
        const constrainIm = new Image();
        constrainIm.src = (0, _constrainSvgDefault.default);
        constrainIm.height = 40;
        const sizeTable = (0, _table.table)([
            [
                (0, _language.LANG)("width") + ":&nbsp;",
                widthInput,
                constrainIm
            ],
            [
                (0, _bb.BB).el({
                    css: {
                        height: "5px"
                    }
                }),
                "",
                ""
            ],
            [
                (0, _language.LANG)("height") + ":&nbsp;",
                heightInput
            ]
        ], {
            "0.2": {
                rowspan: 3
            }
        });
        (0, _bb.BB).css(sizeTable, {
            marginBottom: "10px"
        });
        rootEl.append(sizeTable);
        //contrain checkbox
        let heightChanged = false, widthChanged = false;
        const ratio = klCanvas.getWidth() / klCanvas.getHeight();
        function updateConstrain() {
            constrainIm.style.display = isConstrained ? "" : "none";
            if (isConstrained) {
                widthInput.value = "" + klCanvas.getWidth();
                heightInput.value = "" + klCanvas.getHeight();
                update();
            }
        }
        let isConstrained = true;
        const constrainCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)("constrain-proportions"),
            allowTab: true,
            callback: function(b) {
                isConstrained = b;
                updateConstrain();
            }
        });
        rootEl.append((0, _bb.BB).el({
            css: {
                clear: "both"
            }
        }));
        const algorithmSelect = new (0, _select.Select)({
            isFocusable: true,
            optionArr: [
                [
                    "smooth",
                    (0, _language.LANG)("algorithm-smooth")
                ],
                [
                    "pixelated",
                    (0, _language.LANG)("algorithm-pixelated")
                ]
            ],
            title: (0, _language.LANG)("scaling-algorithm"),
            initValue: "smooth",
            onChange: ()=>{
                update();
            }
        });
        const secondRowElement = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: "flex",
                justifyContent: "space-between",
                "alignItems": "center"
            }
        });
        secondRowElement.append(constrainCheckbox.getElement(), algorithmSelect.getElement());
        const previewCanvas = (0, _bb.BB).canvas(w, h);
        previewCanvas.style.imageRendering = "pixelated";
        const previewCtx = (0, _bb.BB).ctx(previewCanvas);
        function draw() {
            if (algorithmSelect.getValue() === "smooth") {
                previewCanvas.style.imageRendering = previewFactor > 1 ? "pixelated" : "";
                previewCanvas.width = klCanvas.getWidth();
                previewCanvas.height = klCanvas.getHeight();
                previewCtx.save();
                previewCtx.imageSmoothingQuality = "high";
                previewCtx.drawImage(tempCanvas, 0, 0);
                (0, _bb.BB).resizeCanvas(previewCanvas, newWidth, newHeight);
                previewCtx.restore();
            } else {
                previewCanvas.style.imageRendering = "pixelated";
                previewCanvas.width = newWidth;
                previewCanvas.height = newHeight;
                previewCtx.save();
                previewCtx.imageSmoothingEnabled = false;
                previewCtx.drawImage(tempCanvas, 0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.restore();
            }
        }
        function update() {
            if (widthInput.value.length === 0 && widthChanged || heightInput.value.length === 0 && heightChanged) {
                heightChanged = false;
                widthChanged = false;
                return;
            }
            widthInput.value = "" + Math.max(1, parseInt(widthInput.value));
            heightInput.value = "" + Math.max(1, parseInt(heightInput.value));
            if (isConstrained) {
                if (heightChanged) widthInput.value = "" + parseInt("" + parseInt(heightInput.value) * ratio);
                if (widthChanged) heightInput.value = "" + parseInt("" + parseInt(widthInput.value) / ratio);
                if (parseInt(widthInput.value) > maxWidth || parseInt(heightInput.value) > maxHeight) {
                    const fit = (0, _bb.BB).fitInto(parseInt(widthInput.value), parseInt(heightInput.value), maxWidth, maxHeight, 1);
                    widthInput.value = "" + parseInt("" + fit.width);
                    heightInput.value = "" + parseInt("" + fit.height);
                }
            }
            if (parseInt(widthInput.value) > maxWidth) widthInput.value = "" + maxWidth;
            if (parseInt(heightInput.value) > maxHeight) heightInput.value = "" + maxHeight;
            heightChanged = false;
            widthChanged = false;
            newWidth = parseInt(widthInput.value);
            newHeight = parseInt(heightInput.value);
            const preview = (0, _bb.BB).fitInto(newWidth, newHeight, 280, 200, 1);
            const previewW = parseInt("" + preview.width), previewH = parseInt("" + preview.height);
            previewFactor = previewW / newWidth;
            const offset = (0, _bb.BB).centerWithin((0, _previewSize.smallPreview).width, (0, _previewSize.smallPreview).height, previewW, previewH);
            draw();
            previewCanvas.style.width = Math.max(1, previewW) + "px";
            previewCanvas.style.height = Math.max(1, previewH) + "px";
            canvasWrapper.style.left = offset.x + "px";
            canvasWrapper.style.top = offset.y + "px";
            canvasWrapper.style.width = Math.max(1, previewW) + "px";
            canvasWrapper.style.height = Math.max(1, previewH) + "px";
        }
        const previewWrapper = (0, _bb.BB).el({
            className: "kl-transparent-preview",
            css: {
                width: (0, _previewSize.smallPreview).width + "px",
                height: (0, _previewSize.smallPreview).height + "px",
                marginLeft: "-20px",
                display: "table",
                marginTop: "10px",
                position: "relative",
                userSelect: "none"
            }
        });
        const canvasWrapper = (0, _bb.BB).el({
            parent: previewWrapper,
            content: previewCanvas,
            className: "kl-transparent-preview__canvas",
            css: {
                width: w + "px",
                height: h + "px",
                position: "absolute",
                overflow: "hidden"
            }
        });
        function updateCheckerboard() {
            (0, _bb.BB).createCheckerDataUrl(8, function(url) {
                previewWrapper.style.background = "url(" + url + ")";
            }, (0, _theme.theme).isDark());
        }
        (0, _theme.theme).addIsDarkListener(updateCheckerboard);
        updateCheckerboard();
        rootEl.append(previewWrapper);
        update();
        result.destroy = ()=>{
            constrainCheckbox.destroy();
            (0, _theme.theme).removeIsDarkListener(updateCheckerboard);
        };
        result.getInput = function() {
            result.destroy();
            return {
                width: newWidth,
                height: newHeight,
                algorithm: algorithmSelect.getValue()
            };
        };
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        const history = params.history;
        const width = params.input.width;
        const height = params.input.height;
        const algorithm = params.input.algorithm;
        if (!klCanvas || !history) return false;
        history.pause(true);
        klCanvas.resize(width, height, algorithm);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "resize"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/components/checkbox":"8fYiz","../ui/components/select":"jmugN","/src/app/img/ui/constrain.svg":"6rCPO","../../language/language":"iiYGN","../ui/components/table":"cV3Jw","../../theme/theme":"4G3JB","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"6rCPO":[function(require,module,exports) {
module.exports = require("2976b670bc0c41be").getBundleURL("d3gnI") + "constrain.21f8c00a.svg" + "?" + Date.now();

},{"2976b670bc0c41be":"lgJ39"}],"8CV7p":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterRotate", ()=>filterRotate);
var _bb = require("../../bb/bb");
var _theme = require("../../theme/theme");
var _previewSize = require("../ui/utils/preview-size");
const filterRotate = {
    getDialog (params) {
        const klCanvas = params.klCanvas;
        if (!klCanvas) return false;
        const fit = (0, _bb.BB).fitInto(klCanvas.getWidth(), klCanvas.getHeight(), 280, 200, 1);
        const w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        const previewFactor = w / klCanvas.getWidth();
        const tempCanvas = (0, _bb.BB).canvas(w, h);
        tempCanvas.style.display = "block";
        (0, _bb.BB).ctx(tempCanvas).drawImage(klCanvas.getCompleteCanvas(previewFactor), 0, 0, w, h);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        let deg = 0;
        function update() {
            canvasWrapper.style.transform = "rotate(" + deg + "deg)";
            if (Math.abs(deg % 180) === 90) {
                //height has to fit width because of rotation
                const fit = (0, _bb.BB).fitInto(h, w, 280, 200, 1);
                const scale = parseInt("" + fit.height) / w;
                canvasWrapper.style.transform = "rotate(" + deg + "deg) scale(" + scale + ")";
            }
        }
        const btnPlus = document.createElement("button");
        btnPlus.innerHTML = "<span style='font-size: 1.3em'>⟳</span> 90\xb0";
        const btnMinus = document.createElement("button");
        btnMinus.innerHTML = "<span style='font-size: 1.3em'>⟲</span> 90\xb0";
        btnMinus.style.marginRight = "5px";
        btnPlus.onclick = function() {
            deg += 90;
            update();
        };
        btnMinus.onclick = function() {
            deg -= 90;
            update();
        };
        rootEl.append(btnMinus, btnPlus);
        const previewWrapper = (0, _bb.BB).el({
            className: "kl-preview-wrapper",
            css: {
                width: (0, _previewSize.smallPreview).width + "px",
                height: (0, _previewSize.smallPreview).height + "px",
                display: "table"
            }
        });
        const previewcell = (0, _bb.BB).el({
            parent: previewWrapper,
            css: {
                display: "table-cell",
                verticalAlign: "middle"
            }
        });
        const canvasWrapper = (0, _bb.BB).el({
            parent: previewcell,
            content: tempCanvas,
            className: "kl-preview-wrapper__canvas",
            css: {
                width: w + "px",
                height: h + "px",
                marginLeft: "auto",
                marginRight: "auto",
                overflow: "hidden"
            }
        });
        function updateCheckerboard() {
            (0, _bb.BB).createCheckerDataUrl(8, function(url) {
                canvasWrapper.style.background = "url(" + url + ")";
            }, (0, _theme.theme).isDark());
        }
        (0, _theme.theme).addIsDarkListener(updateCheckerboard);
        updateCheckerboard();
        canvasWrapper.style.transition = "all 0.2s ease-out";
        rootEl.append(previewWrapper);
        update();
        result.destroy = ()=>{
            (0, _theme.theme).removeIsDarkListener(updateCheckerboard);
        };
        result.getInput = function() {
            result.destroy();
            return {
                deg: deg
            };
        };
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        const history = params.history;
        if (!klCanvas || !history) return false;
        history.pause(true);
        klCanvas.rotate(params.input.deg);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "rotate"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../../theme/theme":"4G3JB","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5Dznd":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterTiltShift", ()=>filterTiltShift);
var _bb = require("../../bb/bb");
var _filtersConsts = require("./filters-consts");
var _klSlider = require("../ui/components/kl-slider");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _language = require("../../language/language");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _createTransformMatrix = require("../ui/project-viewport/utils/create-transform-matrix");
var _transformationMatrix = require("transformation-matrix");
var _draggableInput = require("../ui/components/draggable-input");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterTiltShift = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        let blur = 20, gradient = 200;
        let fxPreviewRenderer = {
            destroy: ()=>{}
        };
        function finishInit() {
            fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
                original: context.canvas,
                onUpdate: (fxCanvas, transform)=>{
                    fa.setTransform(preview.getTransform());
                    fb.setTransform(preview.getTransform());
                    const m = (0, _createTransformMatrix.createTransformMatrix)(transform);
                    const a = (0, _transformationMatrix.applyToPoint)(m, fa.getValue());
                    const b = (0, _transformationMatrix.applyToPoint)(m, fb.getValue());
                    return fxCanvas.multiplyAlpha().tiltShift(a.x, a.y, b.x, b.y, blur * transform.scaleX, gradient * transform.scaleX).unmultiplyAlpha();
                }
            });
            function update() {
                preview.render();
            }
            // focus line control points
            const fa = new (0, _draggableInput.DraggableInput)({
                value: {
                    x: context.canvas.width / 4,
                    y: context.canvas.height / 2
                },
                onChange: ()=>{
                    update();
                }
            });
            const fb = new (0, _draggableInput.DraggableInput)({
                value: {
                    x: 3 * context.canvas.width / 4,
                    y: context.canvas.height / 2
                },
                onChange: ()=>{
                    update();
                }
            });
            const gradientSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-tilt-shift-gradient"),
                width: 300,
                height: 30,
                min: 0,
                max: 1000,
                value: gradient,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    gradient = val;
                    update();
                }
            });
            gradientSlider.getElement().style.marginBottom = "10px";
            rootEl.append(gradientSlider.getElement());
            const blurSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-tilt-shift-blur"),
                width: 300,
                height: 30,
                min: 0,
                max: 200,
                value: blur,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: function(val) {
                    blur = val;
                    update();
                }
            });
            blurSlider.getElement().style.marginBottom = "10px";
            rootEl.append(blurSlider.getElement());
            const previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
                isVisible: layers[i].isVisible,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr,
                hasClipping: false
            });
            const preview = new (0, _preview.Preview)({
                width: (0, _previewSize.getPreviewWidth)(isSmall),
                height: (0, _previewSize.getPreviewHeight)(isSmall),
                project: {
                    width: context.canvas.width,
                    height: context.canvas.height,
                    layers: previewLayerArr
                }
            });
            preview.render();
            (0, _bb.BB).css(preview.getElement(), {
                overflow: "hidden",
                marginLeft: "-20px",
                marginRight: "-20px"
            });
            preview.getElement().append(fa.getElement(), fb.getElement());
            rootEl.append(preview.getElement());
            result.destroy = ()=>{
                blurSlider.destroy();
                gradientSlider.destroy();
                fa.destroy();
                fb.destroy();
                fxPreviewRenderer.destroy();
                preview.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    a: fa.getValue(),
                    b: fb.getValue(),
                    blur: blur,
                    gradient: gradient
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        const context = params.context;
        const history = params.history;
        const a = params.input.a;
        const b = params.input.b;
        const blur = params.input.blur;
        const gradient = params.input.gradient;
        if (!context || !history) return false;
        history.pause(true);
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).multiplyAlpha().tiltShift(a.x, a.y, b.x, b.y, blur, gradient).unmultiplyAlpha().update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(fxCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "tiltShift"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","./filters-consts":"7Xzbl","../ui/components/kl-slider":"4hcvv","../../fx-canvas/shared-fx":"oGCP8","../../language/language":"iiYGN","../ui/project-viewport/fx-preview-renderer":"1TBrm","../ui/project-viewport/preview":"iWTRk","../ui/project-viewport/utils/create-transform-matrix":"6WuHP","transformation-matrix":"3I2Wq","../ui/components/draggable-input":"7Vl8c","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"7kdP4":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterTransform", ()=>filterTransform);
var _bb = require("../../bb/bb");
var _checkbox = require("../ui/components/checkbox");
var _freeTransform = require("../ui/components/free-transform");
var _select = require("../ui/components/select");
var _language = require("../../language/language");
var _base = require("../../bb/base/base");
var _preview = require("../ui/project-viewport/preview");
var _emotionCssCjs = require("@emotion/css/dist/emotion-css.cjs");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterTransform = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const isSmall = (0, _testIsSmall.testIsSmall)();
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        // determine bounds and initial transformation
        const boundsObj = (0, _bb.BB).canvasBounds(context);
        if (!boundsObj) return {
            error: (0, _language.LANG)("filter-transform-empty")
        };
        const initTransform = {
            x: boundsObj.x + boundsObj.width / 2,
            y: boundsObj.y + boundsObj.height / 2,
            width: boundsObj.width,
            height: boundsObj.height,
            angleDeg: 0
        };
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        if (!isSmall) result.width = (0, _previewSize.mediumPreview).width;
        const keyListener = new (0, _bb.BB).KeyListener({
            onDown: function(keyStr) {
                if ((0, _bb.BB).isInputFocused(true)) return;
                if (keyStr === "left") {
                    inputX.value = "" + (parseFloat(inputX.value) - 1);
                    onInputsChanged();
                }
                if (keyStr === "right") {
                    inputX.value = "" + (parseFloat(inputX.value) + 1);
                    onInputsChanged();
                }
                if (keyStr === "up") {
                    inputY.value = "" + (parseFloat(inputY.value) - 1);
                    onInputsChanged();
                }
                if (keyStr === "down") {
                    inputY.value = "" + (parseFloat(inputY.value) + 1);
                    onInputsChanged();
                }
            }
        });
        const leftWrapper = (0, _bb.BB).el();
        const rightWrapper = (0, _bb.BB).el();
        const rotWrapper = (0, _bb.BB).el();
        const inputY = (0, _bb.BB).el({
            tagName: "input"
        });
        const inputX = (0, _bb.BB).el({
            tagName: "input"
        });
        const inputR = (0, _bb.BB).el({
            tagName: "input"
        });
        leftWrapper.style.width = "100px";
        leftWrapper.style.height = "30px";
        rightWrapper.style.width = "100px";
        rightWrapper.style.height = "30px";
        rightWrapper.style.display = "inline-block";
        leftWrapper.style.display = "inline-block";
        rotWrapper.style.display = "inline-block";
        rotWrapper.style.width = "150px";
        rotWrapper.style.height = "30px";
        inputY.type = "number";
        inputX.type = "number";
        inputR.type = "number";
        inputX.style.width = "70px";
        inputY.style.width = "70px";
        inputR.style.width = "70px";
        inputY.value = "0";
        inputX.value = "0";
        inputR.value = "0";
        inputY.onclick = function() {
            inputY.focus();
            onInputsChanged();
        };
        inputX.onclick = function() {
            inputX.focus();
            onInputsChanged();
        };
        inputR.onclick = function() {
            inputR.focus();
            onInputsChanged();
        };
        inputY.onchange = function() {
            onInputsChanged();
        };
        inputX.onchange = function() {
            onInputsChanged();
        };
        inputR.onchange = function() {
            onInputsChanged();
        };
        inputY.onkeyup = function() {
            onInputsChanged();
        };
        inputX.onkeyup = function() {
            onInputsChanged();
        };
        inputR.onkeyup = function() {
            onInputsChanged();
        };
        leftWrapper.append("X: ", inputX);
        rightWrapper.append("Y: ", inputY);
        rotWrapper.append((0, _language.LANG)("filter-transform-rotation") + ": ", inputR);
        if (!isSmall) {
            const inputRow = (0, _bb.BB).el({
                parent: rootEl,
                css: {
                    marginTop: "10px"
                }
            });
            inputRow.append(leftWrapper, rightWrapper, rotWrapper);
        }
        // buttons
        const actionBtnCss = {
            marginLeft: "10px",
            marginTop: "10px"
        };
        const buttonRow = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: "flex",
                flexWrap: "wrap",
                marginLeft: "-10px"
            }
        });
        const flipXBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: (0, _language.LANG)("filter-transform-flip") + " X",
            onClick: ()=>{
                const t = freeTransform.getValue();
                freeTransform.setSize(-t.width, t.height);
            },
            css: actionBtnCss
        });
        const flipYBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: (0, _language.LANG)("filter-transform-flip") + " Y",
            onClick: ()=>{
                const t = freeTransform.getValue();
                freeTransform.setSize(t.width, -t.height);
            },
            css: actionBtnCss
        });
        const scaleRotLeftBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: "-90\xb0",
            onClick: ()=>{
                const t = freeTransform.getValue();
                t.angleDeg -= 90;
                t.angleDeg %= 360;
                freeTransform.setAngleDeg(t.angleDeg);
                inputR.value = "" + Math.round(t.angleDeg);
                updatePreview();
            },
            css: actionBtnCss
        });
        const scaleRotRightBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: "+90\xb0",
            onClick: ()=>{
                const t = freeTransform.getValue();
                t.angleDeg += 90;
                t.angleDeg %= 360;
                freeTransform.setAngleDeg(t.angleDeg);
                inputR.value = "" + Math.round(t.angleDeg);
                updatePreview();
            },
            css: actionBtnCss
        });
        const scaleDoubleBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: "2x",
            onClick: ()=>{
                const t = freeTransform.getValue();
                if (constrainCheckbox.getValue()) freeTransform.setSize(freeTransform.getRatio() * t.height * 2, t.height * 2);
                else freeTransform.setSize(t.width * 2, t.height * 2);
            },
            css: actionBtnCss
        });
        const scaleHalfBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: "1/2x",
            onClick: ()=>{
                const t = freeTransform.getValue();
                freeTransform.setSize(Math.round(t.width / 2), Math.round(t.height / 2));
            },
            css: actionBtnCss
        });
        const centerBtn = (0, _bb.BB).el({
            parent: buttonRow,
            tagName: "button",
            content: (0, _language.LANG)("center"),
            onClick: ()=>{
                const t = freeTransform.getValue();
                freeTransform.setPos({
                    x: context.canvas.width / 2,
                    y: context.canvas.height / 2
                });
                freeTransform.setAngleDeg(t.angleDeg);
                updatePreview();
            },
            css: actionBtnCss
        });
        let isConstrained = true;
        const constrainCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)("filter-transform-constrain"),
            title: (0, _language.LANG)("constrain-proportions"),
            allowTab: true,
            callback: function(b) {
                isConstrained = b;
                freeTransform.setIsConstrained(isConstrained);
            },
            css: {
                display: "inline-block"
            }
        });
        let isSnapping = false;
        const snappingCheckbox = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)("filter-transform-snap"),
            title: (0, _language.LANG)("filter-transform-snap-title"),
            allowTab: true,
            callback: function(b) {
                isSnapping = b;
                freeTransform.setSnapping(isSnapping);
            },
            css: {
                display: "inline-block",
                marginLeft: "10px"
            }
        });
        const checkboxWrapper = (0, _bb.BB).el();
        checkboxWrapper.append(constrainCheckbox.getElement(), snappingCheckbox.getElement());
        rootEl.append((0, _bb.BB).el({
            css: {
                clear: "both",
                height: "10px"
            }
        }));
        const bottomRow = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: "flex",
                justifyContent: "space-between",
                alignItems: "center",
                marginBottom: "10px"
            }
        });
        const algorithmSelect = new (0, _select.Select)({
            isFocusable: true,
            optionArr: [
                [
                    "smooth",
                    (0, _language.LANG)("algorithm-smooth")
                ],
                [
                    "pixelated",
                    (0, _language.LANG)("algorithm-pixelated")
                ]
            ],
            initValue: "smooth",
            title: (0, _language.LANG)("scaling-algorithm"),
            onChange: ()=>{
                updatePreview(true);
            }
        });
        bottomRow.append(checkboxWrapper, algorithmSelect.getElement());
        const previewCanvas = (0, _bb.BB).canvas(context.canvas.width, context.canvas.height);
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? previewCanvas : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            },
            hasEditMode: true,
            onModeChange: (m)=>{
                freeTransform.getElement().style.pointerEvents = m === "edit" ? "" : "none";
                freeTransform.getElement().style.opacity = m === "edit" ? "" : "0.5";
            },
            onTransformChange: (transform)=>{
                freeTransform.setViewportTransform(transform);
            },
            padding: 30
        });
        preview.render();
        preview.getElement().classList.add((0, _emotionCssCjs.css)({
            overflow: "hidden",
            marginLeft: "-20px",
            marginRight: "-20px"
        }));
        rootEl.append(preview.getElement());
        let lastDrawnTransformStr = "";
        function updatePreview(doForce = false) {
            if (!freeTransform) return;
            const transform = freeTransform.getValue();
            if (JSON.stringify(transform) === lastDrawnTransformStr && !doForce) return;
            lastDrawnTransformStr = JSON.stringify(transform);
            const ctx = (0, _bb.BB).ctx(previewCanvas);
            ctx.save();
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            (0, _bb.BB).drawTransformedImageWithBounds(ctx, layers[selectedLayerIndex].context.canvas, transform, boundsObj, algorithmSelect.getValue() === "pixelated" || (0, _bb.BB).testShouldPixelate(transform, transform.width / initTransform.width, transform.height / initTransform.height));
            ctx.restore();
            preview.render();
        }
        const freeTransform = new (0, _freeTransform.FreeTransform)({
            x: initTransform.x,
            y: initTransform.y,
            width: initTransform.width,
            height: initTransform.height,
            angleDeg: initTransform.angleDeg,
            isConstrained: true,
            snapX: [
                0,
                context.canvas.width
            ],
            snapY: [
                0,
                context.canvas.height
            ],
            callback: function(t) {
                inputX.value = "" + Math.round(t.x - initTransform.x);
                inputY.value = "" + Math.round(t.y - initTransform.y);
                inputR.value = "" + Math.round(t.angleDeg);
                updatePreview();
            },
            viewportTransform: preview.getTransform()
        });
        (0, _bb.BB).css(freeTransform.getElement(), {
            position: "absolute",
            left: "0",
            top: "0"
        });
        preview.getElement().append(freeTransform.getElement());
        function onInputsChanged() {
            freeTransform.setPos({
                x: parseInt(inputX.value) + initTransform.x,
                y: parseInt(inputY.value) + initTransform.y
            });
            freeTransform.setAngleDeg(parseInt(inputR.value));
            updatePreview();
        }
        updatePreview();
        result.destroy = ()=>{
            keyListener.destroy();
            freeTransform.destroy();
            constrainCheckbox.destroy();
            snappingCheckbox.destroy();
            (0, _bb.BB).destroyEl(flipXBtn);
            (0, _bb.BB).destroyEl(flipYBtn);
            (0, _bb.BB).destroyEl(scaleRotLeftBtn);
            (0, _bb.BB).destroyEl(scaleRotRightBtn);
            (0, _bb.BB).destroyEl(scaleDoubleBtn);
            (0, _bb.BB).destroyEl(scaleHalfBtn);
            (0, _bb.BB).destroyEl(centerBtn);
            preview.destroy();
            (0, _bb.BB).freeCanvas(previewCanvas);
        };
        result.getInput = function() {
            const transform = freeTransform.getValue();
            const input = {
                transform,
                bounds: boundsObj,
                isPixelated: algorithmSelect.getValue() === "pixelated" || (0, _bb.BB).testShouldPixelate(transform, transform.width / initTransform.width, transform.height / initTransform.height)
            };
            result.destroy();
            return (0, _bb.BB).copyObj(input);
        };
        return result;
    },
    apply (params) {
        const context = params.context;
        const history = params.history;
        if (!context || !history) return false;
        history.pause(true);
        const input = params.input;
        const copyCanvas = (0, _bb.BB).copyCanvas(context.canvas);
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        (0, _bb.BB).drawTransformedImageWithBounds(context, copyCanvas, input.transform, input.bounds, input.isPixelated);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "transform"
            ],
            action: "apply",
            params: [
                {
                    input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/components/checkbox":"8fYiz","../ui/components/free-transform":"izcGJ","../ui/components/select":"jmugN","../../language/language":"iiYGN","../../bb/base/base":"k6nNY","../ui/project-viewport/preview":"iWTRk","@emotion/css/dist/emotion-css.cjs":"djBls","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"5iOmO":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterBlur", ()=>filterBlur);
var _klSlider = require("../ui/components/kl-slider");
var _filtersConsts = require("./filters-consts");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _language = require("../../language/language");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _emotionCssCjs = require("@emotion/css/dist/emotion-css.cjs");
var _bb = require("../../bb/bb");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterBlur = {
    getDialog (params) {
        const klCanvas = params.klCanvas;
        const context = params.context;
        if (!klCanvas || !context) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        let radius = 10;
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas, transform)=>{
                return fxCanvas.multiplyAlpha().triangleBlur(radius * transform.scaleX).unmultiplyAlpha();
            }
        });
        function finishInit() {
            const radiusSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("radius"),
                width: 300,
                height: 30,
                min: 1,
                max: 200,
                value: radius,
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: (val)=>{
                    radius = val;
                    preview.render();
                }
            });
            radiusSlider.getElement().style.marginBottom = "10px";
            rootEl.append(radiusSlider.getElement());
            const previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
                isVisible: layers[i].isVisible,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr,
                hasClipping: false
            });
            const preview = new (0, _preview.Preview)({
                width: (0, _previewSize.getPreviewWidth)(isSmall),
                height: (0, _previewSize.getPreviewHeight)(isSmall),
                project: {
                    width: context.canvas.width,
                    height: context.canvas.height,
                    layers: previewLayerArr
                }
            });
            preview.render();
            preview.getElement().classList.add((0, _emotionCssCjs.css)({
                marginLeft: "-20px",
                marginRight: "-20px"
            }));
            rootEl.append(preview.getElement());
            result.destroy = ()=>{
                radiusSlider.destroy();
                fxPreviewRenderer.destroy();
                preview.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    radius: radius
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        const context = params.context;
        const history = params.history;
        const radius = params.input.radius;
        if (!context || !radius || !history) return false;
        history.pause(true);
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).multiplyAlpha().triangleBlur(radius).unmultiplyAlpha().update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(fxCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "blur"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../ui/components/kl-slider":"4hcvv","./filters-consts":"7Xzbl","../../fx-canvas/shared-fx":"oGCP8","../../language/language":"iiYGN","../ui/project-viewport/fx-preview-renderer":"1TBrm","../ui/project-viewport/preview":"iWTRk","@emotion/css/dist/emotion-css.cjs":"djBls","../../bb/bb":"dcQKo","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1fHVB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterUnsharpMask", ()=>filterUnsharpMask);
var _klSlider = require("../ui/components/kl-slider");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _language = require("../../language/language");
var _preview = require("../ui/project-viewport/preview");
var _css = require("@emotion/css");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _bb = require("../../bb/bb");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterUnsharpMask = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        let radius = 2, strength = 0.51;
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas, transform)=>{
                return fxCanvas.unsharpMask(radius * transform.scaleX, strength);
            }
        });
        function finishInit() {
            function update() {
                preview.render();
            }
            const radiusSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("radius"),
                width: 300,
                height: 30,
                min: 0,
                max: 200,
                value: 2,
                //eventResMs: eventResMs,
                onChange: function(val) {
                    radius = val;
                    update();
                },
                curve: [
                    [
                        0,
                        0
                    ],
                    [
                        0.1,
                        2
                    ],
                    [
                        0.5,
                        50
                    ],
                    [
                        1,
                        200
                    ]
                ]
            });
            const strengthSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-unsharp-mask-strength"),
                width: 300,
                height: 30,
                min: 0,
                max: 50,
                value: 5.1,
                //eventResMs: eventResMs,
                onChange: function(val) {
                    strength = val / 10;
                    update();
                },
                curve: [
                    [
                        0,
                        0
                    ],
                    [
                        0.1,
                        2
                    ],
                    [
                        0.5,
                        10
                    ],
                    [
                        1,
                        50
                    ]
                ]
            });
            radiusSlider.getElement().style.marginBottom = "10px";
            strengthSlider.getElement().style.marginBottom = "10px";
            rootEl.append(radiusSlider.getElement());
            rootEl.append(strengthSlider.getElement());
            const previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
                isVisible: layers[i].isVisible,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr,
                hasClipping: false
            });
            const preview = new (0, _preview.Preview)({
                width: (0, _previewSize.getPreviewWidth)(isSmall),
                height: (0, _previewSize.getPreviewHeight)(isSmall),
                project: {
                    width: context.canvas.width,
                    height: context.canvas.height,
                    layers: previewLayerArr
                }
            });
            update();
            preview.getElement().classList.add((0, _css.css)({
                marginLeft: "-20px",
                marginRight: "-20px"
            }));
            rootEl.append(preview.getElement());
            result.destroy = ()=>{
                radiusSlider.destroy();
                strengthSlider.destroy();
                fxPreviewRenderer.destroy();
                preview.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    radius: radius,
                    strength: strength
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        const context = params.context;
        const history = params.history;
        const radius = params.input.radius;
        const strength = params.input.strength;
        if (!context || radius === null || strength === null || !history) return false;
        history.pause(true);
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).unsharpMask(radius, strength).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(fxCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "unsharpMask"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../ui/components/kl-slider":"4hcvv","../../fx-canvas/shared-fx":"oGCP8","../../language/language":"iiYGN","../ui/project-viewport/preview":"iWTRk","@emotion/css":"gyRZs","../ui/project-viewport/fx-preview-renderer":"1TBrm","../../bb/bb":"dcQKo","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iGpbg":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterToAlpha", ()=>filterToAlpha);
var _options = require("../ui/components/options");
var _colorOptions = require("../ui/components/color-options");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _language = require("../../language/language");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _emotionCssCjs = require("@emotion/css/dist/emotion-css.cjs");
var _bb = require("../../bb/bb");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterToAlpha = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = klCanvas.getLayerIndex(context.canvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        function finishInit() {
            const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
                original: context.canvas,
                onUpdate: (fxCanvas)=>{
                    return fxCanvas.toAlpha(sourceId === "inverted-luminance", selectedRgbaObj);
                }
            });
            // source
            let sourceId = "inverted-luminance";
            const sourceOptions = new (0, _options.Options)({
                optionArr: [
                    {
                        id: "inverted-luminance",
                        label: (0, _language.LANG)("filter-to-alpha-inverted-lum")
                    },
                    {
                        id: "luminance",
                        label: (0, _language.LANG)("filter-to-alpha-lum")
                    }
                ],
                initId: sourceId,
                onChange: function(id) {
                    sourceId = id;
                    preview.render();
                }
            });
            rootEl.append(sourceOptions.getElement());
            // color
            let selectedRgbaObj = {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            };
            const colorOptionsArr = [
                null,
                {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                },
                {
                    r: 255,
                    g: 255,
                    b: 255,
                    a: 1
                },
                {
                    r: params.currentColorRgb.r,
                    g: params.currentColorRgb.g,
                    b: params.currentColorRgb.b,
                    a: 1
                },
                {
                    r: params.secondaryColorRgb.r,
                    g: params.secondaryColorRgb.g,
                    b: params.secondaryColorRgb.b,
                    a: 1
                }
            ];
            const colorOptions = new (0, _colorOptions.ColorOptions)({
                label: (0, _language.LANG)("filter-to-alpha-replace"),
                colorArr: colorOptionsArr,
                initialIndex: 1,
                onChange: function(rgbaObj) {
                    selectedRgbaObj = rgbaObj;
                    preview.render();
                }
            });
            colorOptions.getElement().style.marginTop = "10px";
            colorOptions.getElement().style.marginBottom = "10px";
            rootEl.append(colorOptions.getElement());
            const previewLayerArr = [];
            for(let i = 0; i < layers.length; i++)previewLayerArr.push({
                image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
                isVisible: layers[i].isVisible,
                opacity: layers[i].opacity,
                mixModeStr: layers[i].mixModeStr,
                hasClipping: false
            });
            const preview = new (0, _preview.Preview)({
                width: (0, _previewSize.getPreviewWidth)(isSmall),
                height: (0, _previewSize.getPreviewHeight)(isSmall),
                project: {
                    width: context.canvas.width,
                    height: context.canvas.height,
                    layers: previewLayerArr
                }
            });
            preview.render();
            preview.getElement().classList.add((0, _emotionCssCjs.css)({
                marginLeft: "-20px",
                marginRight: "-20px"
            }));
            rootEl.append(preview.getElement());
            result.destroy = ()=>{
                sourceOptions.destroy();
                colorOptions.destroy();
                fxPreviewRenderer.destroy();
                preview.destroy();
            };
            result.getInput = function() {
                result.destroy();
                return {
                    sourceId: sourceId,
                    selectedRgbaObj: selectedRgbaObj
                };
            };
        }
        setTimeout(finishInit, 1);
        return result;
    },
    apply (params) {
        const context = params.context;
        const history = params.history;
        const sourceId = params.input.sourceId;
        const selectedRgbaObj = params.input.selectedRgbaObj;
        if (!context || !sourceId || !history) return false;
        history.pause(true);
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).toAlpha(sourceId === "inverted-luminance", selectedRgbaObj).update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(fxCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "toAlpha"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../ui/components/options":"hNLP6","../ui/components/color-options":"iXzf7","../../fx-canvas/shared-fx":"oGCP8","../../language/language":"iiYGN","../ui/project-viewport/fx-preview-renderer":"1TBrm","../ui/project-viewport/preview":"iWTRk","@emotion/css/dist/emotion-css.cjs":"djBls","../../bb/bb":"dcQKo","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"bN7Vm":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterGrid", ()=>filterGrid);
var _bb = require("../../bb/bb");
var _language = require("../../language/language");
var _input = require("../ui/components/input");
var _colorOptions = require("../ui/components/color-options");
var _drawGrid = require("../image-operations/draw-grid");
var _base = require("../../bb/base/base");
var _preview = require("../ui/project-viewport/preview");
var _emotionCssCjs = require("@emotion/css/dist/emotion-css.cjs");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterGrid = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        const settingsObj = {
            x: 2,
            y: 2,
            thickness: 8,
            color: "#000",
            opacity: 1
        };
        const line1 = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: "flex",
                alignItems: "center"
            }
        });
        const line2 = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: "flex",
                alignItems: "center",
                marginTop: "10px",
                marginBottom: "10px"
            }
        });
        const xInput = (0, _input.input)({
            init: 2,
            type: "number",
            min: 1,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.x = parseFloat(v);
                updatePreview();
            }
        });
        const yInput = (0, _input.input)({
            init: 2,
            type: "number",
            min: 1,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.y = parseFloat(v);
                updatePreview();
            }
        });
        const thicknessInput = (0, _input.input)({
            init: settingsObj.thickness,
            type: "number",
            min: 1,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.thickness = parseFloat(v);
                updatePreview();
            }
        });
        let selectedRgbaObj = {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        };
        const colorOptionsArr = [
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            }
        ];
        colorOptionsArr.push({
            r: params.currentColorRgb.r,
            g: params.currentColorRgb.g,
            b: params.currentColorRgb.b,
            a: 1
        });
        colorOptionsArr.push({
            r: params.secondaryColorRgb.r,
            g: params.secondaryColorRgb.g,
            b: params.secondaryColorRgb.b,
            a: 1
        });
        settingsObj.color = (0, _bb.BB).ColorConverter.toRgbStr(selectedRgbaObj);
        const colorOptions = new (0, _colorOptions.ColorOptions)({
            label: (0, _language.LANG)("shape-stroke"),
            colorArr: colorOptionsArr,
            onChange: function(rgbaObj) {
                selectedRgbaObj = rgbaObj;
                settingsObj.color = (0, _bb.BB).ColorConverter.toRgbStr(selectedRgbaObj);
                updatePreview();
            }
        });
        const labelStyle = {
            display: "inline-block",
            marginRight: "5px"
        };
        line1.append((0, _bb.BB).el({
            content: "X:",
            css: labelStyle
        }), xInput, (0, _bb.BB).el({
            content: "Y:",
            css: labelStyle
        }), yInput);
        line2.append((0, _bb.BB).el({
            content: (0, _language.LANG)("shape-line-width") + ":",
            css: labelStyle
        }), thicknessInput, (0, _bb.BB).el({
            css: {
                flexGrow: "1"
            }
        }), colorOptions.getElement());
        const previewCanvas = (0, _bb.BB).canvas(context.canvas.width, context.canvas.height);
        const previewCtx = (0, _bb.BB).ctx(previewCanvas);
        const previewLayerArr = layers.map((item, i)=>{
            return {
                image: i === selectedLayerIndex ? previewCanvas : item.context.canvas,
                isVisible: item.isVisible,
                opacity: item.opacity,
                mixModeStr: item.mixModeStr,
                hasClipping: false
            };
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            }
        });
        preview.getElement().classList.add((0, _emotionCssCjs.css)({
            marginLeft: "-20px",
            marginRight: "-20px"
        }));
        rootEl.append(preview.getElement());
        function updatePreview() {
            const ctx = previewCtx;
            ctx.save();
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            ctx.drawImage(context.canvas, 0, 0);
            (0, _drawGrid.drawGrid)(ctx, settingsObj.x, settingsObj.y, Math.max(settingsObj.thickness, 1), settingsObj.color, settingsObj.opacity);
            ctx.restore();
            preview.render();
        }
        updatePreview();
        preview.render();
        result.destroy = ()=>{
            preview.destroy();
            (0, _bb.BB).freeCanvas(previewCanvas);
            colorOptions.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return (0, _bb.BB).copyObj(settingsObj);
        };
        return result;
    },
    apply (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        const history = params.history;
        if (!context || !klCanvas || !history) return false;
        history.pause(true);
        (0, _drawGrid.drawGrid)(context, params.input.x, params.input.y, params.input.thickness, params.input.color, params.input.opacity);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "grid"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../../language/language":"iiYGN","../ui/components/input":"je8IE","../ui/components/color-options":"iXzf7","../image-operations/draw-grid":"iJ0f6","../../bb/base/base":"k6nNY","../ui/project-viewport/preview":"iWTRk","@emotion/css/dist/emotion-css.cjs":"djBls","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"iJ0f6":[function(require,module,exports) {
// ideas: padding, gutter, other shapes
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawGrid", ()=>drawGrid);
function drawGrid(ctx, cellsX, cellsY, thickness, color, opacity) {
    ctx.save();
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    thickness = Math.round(thickness);
    const thickIsRound = thickness % 2 === 0;
    ctx.beginPath();
    ctx.lineWidth = thickness;
    ctx.strokeStyle = color;
    ctx.globalAlpha = opacity;
    for(let i = 0; i < cellsX - 1; i++){
        const cw = w / cellsX;
        let pos = cw * (i + 1);
        if (thickIsRound) pos = Math.round(pos);
        else pos = Math.round(pos + 0.5) - 0.5;
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, h);
    }
    for(let i = 0; i < cellsY - 1; i++){
        const ch = h / cellsY;
        let pos = ch * (i + 1);
        if (thickIsRound) pos = Math.round(pos);
        else pos = Math.round(pos + 0.5) - 0.5;
        ctx.moveTo(0, pos);
        ctx.lineTo(w, pos);
    }
    ctx.stroke();
    ctx.restore();
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"eLTh7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterNoise", ()=>filterNoise);
var _bb = require("../../bb/bb");
var _language = require("../../language/language");
var _klSlider = require("../ui/components/kl-slider");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _options = require("../ui/components/options");
var _filtersConsts = require("./filters-consts");
var _select = require("../ui/components/select");
var _translateBlending = require("../canvas/translate-blending");
var _kl = require("../kl");
var _color = require("../../bb/color/color");
var _checkbox = require("../ui/components/checkbox");
var _base = require("../../bb/base/base");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _emotionCssCjs = require("@emotion/css/dist/emotion-css.cjs");
var _previewSize = require("../ui/utils/preview-size");
var _testIsSmall = require("../ui/utils/test-is-small");
const presetArr = [
    // each pixel random value
    {
        type: 0,
        scaleX: 1,
        scaleY: 1,
        offsetX: 0,
        offsetY: 0,
        octaves: 1,
        samples: 1,
        peaks: 0,
        brightness: 0,
        contrast: 0,
        isReversed: true
    },
    // cloud
    {
        type: 1,
        scaleX: 166,
        scaleY: 164,
        offsetX: 105,
        offsetY: 30,
        octaves: 6,
        samples: 1,
        peaks: 0,
        brightness: 0.055,
        contrast: 0.23,
        isReversed: true
    },
    // thin lines
    {
        type: 1,
        scaleX: 235,
        scaleY: 190,
        offsetX: 3227,
        offsetY: 2156,
        octaves: 4,
        samples: 16,
        peaks: 22,
        brightness: -0.375,
        contrast: 1,
        isReversed: false
    },
    // soft large simplex, only 1 octave
    {
        type: 1,
        scaleX: 40,
        scaleY: 40,
        offsetX: 0,
        offsetY: 0,
        octaves: 1,
        samples: 1,
        peaks: 0,
        brightness: 0,
        contrast: 0,
        isReversed: false
    },
    // two value large pixels
    {
        type: 0,
        scaleX: 26,
        scaleY: 26,
        offsetX: 557,
        offsetY: 365,
        octaves: 1,
        samples: 1,
        peaks: 0,
        brightness: 0.02,
        contrast: 1,
        isReversed: true
    },
    // zebra
    {
        type: 1,
        scaleX: 1500,
        scaleY: 1500,
        offsetX: 745,
        offsetY: 2871,
        octaves: 5,
        samples: 16,
        peaks: 156.02,
        brightness: 0.03,
        contrast: 1,
        isReversed: true
    },
    // sparse dots / stars
    {
        type: 1,
        scaleX: 11,
        scaleY: 11,
        offsetX: 2940,
        offsetY: 2045,
        octaves: 1,
        samples: 16,
        peaks: 1,
        brightness: -0.045,
        contrast: 1,
        isReversed: true
    },
    // pseudo marble
    {
        type: 2,
        scaleX: 74,
        scaleY: 74,
        offsetX: 4816,
        offsetY: 1304,
        octaves: 3,
        samples: 1,
        peaks: 2.78,
        brightness: 0,
        contrast: 0,
        isReversed: false
    }
];
function drawNoise(fxCanvas, settings) {
    fxCanvas.noise(settings.seed, settings.type, [
        settings.scaleX,
        settings.scaleY
    ], [
        fxCanvas.width / 2,
        fxCanvas.height / 2
    ], settings.octaves, settings.samples, settings.peaks, settings.brightness, settings.contrast, settings.isReversed, settings.colA, settings.colB, settings.channels ? settings.channels : "rgb").update();
}
const filterNoise = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        const thumbImgArr = [];
        const thumbSize = 32;
        {
            const fxCanvas = (0, _base.throwIfNull)((0, _sharedFx.getSharedFx)());
            const canvas = (0, _bb.BB).canvas(thumbSize, thumbSize);
            const ctx = (0, _bb.BB).ctx(canvas);
            const texture = fxCanvas.texture(canvas);
            fxCanvas.draw(texture).update(); // update fxCanvas size
            texture.destroy();
            presetArr.forEach((preset)=>{
                const thumbImg = new Image();
                const presetCopy = (0, _bb.BB).copyObj(preset);
                presetCopy.scaleX /= 10;
                presetCopy.scaleY /= 10;
                drawNoise(fxCanvas, presetCopy);
                ctx.drawImage(fxCanvas, 0, 0);
                thumbImg.src = canvas.toDataURL("image/png");
                thumbImgArr.push(thumbImg);
            });
            texture.destroy();
        }
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        const settingsObj = {
            seed: Math.random() * 300,
            presetIndex: 0,
            scale: 50,
            opacity: 0.5,
            isReversed: false,
            channels: "rgb",
            mixModeStr: "source-over",
            colA: {
                r: 0,
                g: 0,
                b: 0
            },
            colB: {
                r: 255,
                g: 255,
                b: 255
            }
        };
        const presetOptions = new (0, _options.Options)({
            optionArr: thumbImgArr.map((img, index)=>{
                (0, _bb.BB).css(img, {
                    margin: "1px",
                    borderRadius: "3px",
                    transition: "all 0.1s ease-in-out"
                });
                return {
                    id: "" + index,
                    label: img
                };
            }),
            initId: "0",
            onChange: (id)=>{
                settingsObj.presetIndex = Number(id);
                update();
            }
        });
        presetOptions.getElement().style.marginBottom = "10px";
        rootEl.append(presetOptions.getElement());
        const scaleSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("filter-noise-scale"),
            width: 300,
            height: 30,
            min: 1,
            max: 1000,
            value: settingsObj.scale,
            eventResMs: (0, _filtersConsts.eventResMs),
            curve: (0, _bb.BB).quadraticSplineInput(1, 1000, 0.1),
            onChange: (value)=>{
                settingsObj.scale = value;
                update();
            }
        });
        scaleSlider.getElement().style.marginBottom = "10px";
        const opacitySlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("opacity"),
            width: 300,
            height: 30,
            min: 0.01,
            max: 1,
            value: settingsObj.opacity,
            eventResMs: (0, _filtersConsts.eventResMs),
            toValue: (displayValue)=>displayValue / 100,
            toDisplayValue: (value)=>value * 100,
            onChange: (value)=>{
                settingsObj.opacity = value;
                update();
            }
        });
        opacitySlider.getElement().style.marginBottom = "10px";
        const row1El = (0, _bb.BB).el({
            css: {
                display: "flex",
                alignItems: "center",
                marginBottom: "10px"
            }
        });
        const row2El = (0, _bb.BB).el({
            css: {
                display: "flex",
                marginBottom: "10px"
            }
        });
        const channelsOptions = new (0, _options.Options)({
            optionArr: [
                {
                    id: "rgb",
                    label: "RGB"
                },
                {
                    id: "alpha",
                    label: (0, _language.LANG)("filter-noise-alpha")
                }
            ],
            initId: "rgb",
            onChange: (id)=>{
                settingsObj.channels = id;
                if (id === "rgb") row2El.style.visibility = "";
                else row2El.style.visibility = "hidden";
                update();
            }
        });
        const reverseToggle = new (0, _checkbox.Checkbox)({
            label: (0, _language.LANG)("reverse"),
            callback: (val)=>{
                settingsObj.isReversed = val;
                update();
            },
            allowTab: true
        });
        const mixModes = [
            "source-over",
            undefined,
            "darken",
            "multiply",
            "color-burn",
            undefined,
            "lighten",
            "screen",
            "color-dodge",
            undefined,
            "overlay",
            "soft-light",
            "hard-light",
            undefined,
            "difference",
            "exclusion",
            undefined,
            "hue",
            "saturation",
            "color",
            "luminosity"
        ];
        const blendSelect = new (0, _select.Select)({
            isFocusable: true,
            optionArr: mixModes.map((item)=>{
                return item ? [
                    item,
                    (0, _translateBlending.translateBlending)(item)
                ] : undefined;
            }),
            initValue: settingsObj.mixModeStr,
            onChange: (val)=>{
                settingsObj.mixModeStr = val;
                update();
            }
        });
        blendSelect.getElement().title = (0, _language.LANG)("layers-blending");
        const colorWrapper = (0, _bb.BB).el({
            css: {
                display: "flex"
            }
        });
        const colInputStyle = {
            width: "34px",
            height: "34px",
            marginRight: "5px"
        };
        const colAInput = (0, _kl.KL).input({
            type: "color",
            init: "#" + (0, _color.ColorConverter).toHexString(settingsObj.colA),
            callback: (val)=>{
                const newColor = (0, _color.ColorConverter).hexToRGB(val);
                if (newColor) {
                    settingsObj.colA = newColor;
                    update();
                }
            },
            css: colInputStyle
        });
        const colBInput = (0, _kl.KL).input({
            type: "color",
            init: "#" + (0, _color.ColorConverter).toHexString(settingsObj.colB),
            callback: (val)=>{
                const newColor = (0, _color.ColorConverter).hexToRGB(val);
                if (newColor) {
                    settingsObj.colB = newColor;
                    update();
                }
            },
            css: colInputStyle
        });
        colorWrapper.append(colAInput, colBInput);
        row1El.append(channelsOptions.getElement(), (0, _bb.BB).el({
            css: {
                flexGrow: "1"
            }
        }), reverseToggle.getElement());
        row2El.append(blendSelect.getElement(), (0, _bb.BB).el({
            css: {
                flexGrow: "1"
            }
        }), colorWrapper);
        rootEl.append(scaleSlider.getElement(), opacitySlider.getElement(), row1El, row2El);
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas, transform)=>{
                const settingsCopy = (0, _bb.BB).copyObj(presetArr[settingsObj.presetIndex]);
                settingsCopy.seed = settingsObj.seed;
                settingsCopy.scaleX = settingsCopy.scaleX * settingsObj.scale / 50 * transform.scaleX;
                settingsCopy.scaleY = settingsCopy.scaleY * settingsObj.scale / 50 * transform.scaleY;
                settingsCopy.colA = settingsObj.colA;
                settingsCopy.colB = settingsObj.colB;
                settingsCopy.isReversed = settingsObj.isReversed ? !settingsCopy.isReversed : settingsCopy.isReversed;
                settingsCopy.channels = settingsObj.channels;
                settingsCopy.offsetX = context.canvas.width / 2 * transform.scaleX + transform.x;
                settingsCopy.offsetY = context.canvas.height / 2 * transform.scaleY + transform.y;
                return fxCanvas.noise(settingsCopy.seed, settingsCopy.type, [
                    settingsCopy.scaleX,
                    settingsCopy.scaleY
                ], [
                    settingsCopy.offsetX,
                    settingsCopy.offsetY
                ], settingsCopy.octaves, settingsCopy.samples, settingsCopy.peaks, settingsCopy.brightness, settingsCopy.contrast, settingsCopy.isReversed, settingsCopy.colA, settingsCopy.colB, settingsCopy.channels ? settingsCopy.channels : "rgb");
            },
            postMix: {
                opacity: settingsObj.opacity,
                operation: settingsObj.channels === "alpha" ? "destination-out" : settingsObj.mixModeStr
            }
        });
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? fxPreviewRenderer.render : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            }
        });
        preview.render();
        preview.getElement().classList.add((0, _emotionCssCjs.css)({
            marginLeft: "-20px",
            marginRight: "-20px"
        }));
        rootEl.append(preview.getElement());
        function update() {
            fxPreviewRenderer.setPostMix({
                opacity: settingsObj.opacity,
                operation: settingsObj.channels === "alpha" ? "destination-out" : settingsObj.mixModeStr
            });
            preview.render();
        }
        result.destroy = ()=>{
            presetOptions.destroy();
            scaleSlider.destroy();
            opacitySlider.destroy();
            reverseToggle.destroy();
            channelsOptions.destroy();
            blendSelect.destroy();
            preview.destroy();
            fxPreviewRenderer.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return (0, _bb.BB).copyObj(settingsObj);
        };
        return result;
    },
    apply (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        const history = params.history;
        if (!context || !klCanvas || !history) return false;
        history.pause(true);
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).update();
        texture.destroy();
        const input = params.input;
        const presetCopy = (0, _bb.BB).copyObj(presetArr[input.presetIndex]);
        presetCopy.seed = input.seed;
        presetCopy.scaleX = presetCopy.scaleX * input.scale / 50;
        presetCopy.scaleY = presetCopy.scaleY * input.scale / 50;
        presetCopy.colA = input.colA;
        presetCopy.colB = input.colB;
        presetCopy.isReversed = input.isReversed ? !presetCopy.isReversed : presetCopy.isReversed;
        presetCopy.channels = input.channels;
        drawNoise(fxCanvas, presetCopy);
        context.save();
        context.globalAlpha = input.opacity;
        if (input.channels === "alpha") context.globalCompositeOperation = "destination-out";
        else context.globalCompositeOperation = input.mixModeStr;
        context.drawImage(fxCanvas, 0, 0);
        context.restore();
        history.pause(false);
        history.push({
            tool: [
                "canvas"
            ],
            action: "replaceLayer",
            params: [
                klCanvas.getLayerIndex(context.canvas),
                context.getImageData(0, 0, context.canvas.width, context.canvas.height)
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../../language/language":"iiYGN","../ui/components/kl-slider":"4hcvv","../../fx-canvas/shared-fx":"oGCP8","../ui/components/options":"hNLP6","./filters-consts":"7Xzbl","../ui/components/select":"jmugN","../canvas/translate-blending":"6hHQR","../kl":"8nmWp","../../bb/color/color":"iVNo9","../ui/components/checkbox":"8fYiz","../../bb/base/base":"k6nNY","../ui/project-viewport/fx-preview-renderer":"1TBrm","../ui/project-viewport/preview":"iWTRk","@emotion/css/dist/emotion-css.cjs":"djBls","../ui/utils/preview-size":"llYOD","../ui/utils/test-is-small":"giqoI","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ltDe9":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterPattern", ()=>filterPattern);
var _bb = require("../../bb/bb");
var _input = require("../ui/components/input");
var _klSlider = require("../ui/components/kl-slider");
var _language = require("../../language/language");
var _filtersConsts = require("./filters-consts");
var _canvasPreview = require("../canvas-ui/canvas-preview");
var _twoTabs = require("../ui/components/two-tabs");
var _base = require("../../bb/base/base");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
/**
 * Draws pattern onto context. Pattern generated from context.
 * Can use blending for smoother transition. Will use area outside of bounds for blending.
 *
 * @param context
 * @param settings
 */ function drawPattern(context, settings) {
    // keep bounds in center via offset
    // because blending done towards bottom right
    const blendOffsetX = settings.blend ? Math.round(settings.blend * settings.width / 2) : 0;
    const blendOffsetY = settings.blend ? Math.round(settings.blend * settings.height / 2) : 0;
    const finalPatternCanvas = (0, _bb.BB).canvas(settings.width, settings.height);
    if (settings.blend) {
        // construct pattern via linear blending
        const blendCanvas = (0, _bb.BB).canvas(settings.width * 2, settings.height * 2);
        const blendCtx = (0, _bb.BB).ctx(blendCanvas);
        const colTransparent = "#0000";
        const colOpaque = "#000";
        // transfer source to blendCanvas
        blendCtx.drawImage(context.canvas, -settings.x + blendOffsetX, -settings.y + blendOffsetY);
        // --- 1 cross-fade vertical ------------------------
        // erase vertical gradient bottom half
        blendCtx.save();
        let blendGradient = blendCtx.createLinearGradient(0, settings.height, 0, settings.height * 2);
        blendGradient.addColorStop(0, colOpaque);
        blendGradient.addColorStop(settings.blend, colTransparent);
        blendCtx.globalCompositeOperation = "destination-in";
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, blendCanvas.width, blendCanvas.height);
        blendCtx.restore();
        // erase vertical gradient top half
        blendCtx.save();
        blendGradient = blendCtx.createLinearGradient(0, 0, 0, settings.height);
        blendGradient.addColorStop(0, colTransparent);
        blendGradient.addColorStop(settings.blend, colOpaque);
        blendCtx.globalCompositeOperation = "destination-in";
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, settings.width * 2, settings.height * 2);
        blendCtx.restore();
        // draw bottom half over top half
        blendCtx.save();
        // lighter needed for accurate cross-fade
        blendCtx.globalCompositeOperation = "lighter";
        blendCtx.drawImage(blendCanvas, 0, -settings.height);
        blendCtx.restore();
        // --- 2 cross-fade horizontal ------------------------
        // erase horizontal gradient right half
        blendCtx.save();
        blendGradient = blendCtx.createLinearGradient(settings.width, 0, settings.width * 2, 0);
        blendGradient.addColorStop(0, colOpaque);
        blendGradient.addColorStop(settings.blend, colTransparent);
        blendCtx.globalCompositeOperation = "destination-in";
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, blendCanvas.width, blendCanvas.height);
        blendCtx.restore();
        // erase horizontal gradient left half
        blendCtx.save();
        blendGradient = blendCtx.createLinearGradient(0, 0, settings.width, 0);
        blendGradient.addColorStop(0, colTransparent);
        blendGradient.addColorStop(settings.blend, colOpaque);
        blendCtx.globalCompositeOperation = "destination-in";
        blendCtx.fillStyle = blendGradient;
        blendCtx.fillRect(0, 0, settings.width * 2, settings.height * 2);
        blendCtx.restore();
        // draw right half over left half
        blendCtx.save();
        // lighter needed for accurate cross-fade
        blendCtx.globalCompositeOperation = "lighter";
        blendCtx.drawImage(blendCanvas, -settings.width, 0);
        blendCtx.restore();
        // transfer to pattern canvas
        (0, _bb.BB).ctx(finalPatternCanvas).drawImage(blendCanvas, 0, 0);
    } else (0, _bb.BB).ctx(finalPatternCanvas).drawImage(context.canvas, -settings.x, -settings.y);
    context.save();
    context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    context.translate(settings.offsetX - blendOffsetX, settings.offsetY - blendOffsetY);
    context.fillStyle = (0, _base.throwIfNull)(context.createPattern(finalPatternCanvas, "repeat"));
    context.fillRect(-settings.offsetX + blendOffsetX, -settings.offsetY + blendOffsetY, context.canvas.width, context.canvas.height);
    context.restore();
}
const filterPattern = {
    getDialog (params) {
        const isSmall = (0, _testIsSmall.testIsSmall)();
        const maxSize = 1024;
        const rootEl = (0, _bb.BB).el();
        const context = params.context;
        const width = context.canvas.width;
        const height = context.canvas.height;
        let settings = {
            x: 0,
            y: 0,
            width: width <= 250 ? Math.round(width / 4) : 200,
            height: height <= 250 ? Math.round(height / 4) : 200,
            blend: 0,
            offsetX: 0,
            offsetY: 0
        };
        let lastDrawnSettings;
        // determine bounds
        const bounds = (0, _bb.BB).canvasBounds(context);
        // adjust settings according to bounds
        if (bounds && bounds.width <= maxSize && bounds.height <= maxSize && // don't exceed max size
        (bounds.width < width * 0.75 || bounds.height < height * 0.75 // aren't too large (heuristic)
        )) {
            settings.x = bounds.x;
            settings.y = bounds.y;
            settings.width = bounds.width;
            settings.height = bounds.height;
        } else {
            settings.x = Math.round(width / 2 - settings.width / 2);
            settings.y = Math.round(height / 2 - settings.height / 2);
        }
        // ---- controls ----
        const xInput = (0, _input.input)({
            init: settings.x,
            type: "number",
            min: 0,
            max: width,
            css: {
                width: "100%"
            },
            callback: function(v) {
                settings.x = Number(v);
                updatePreview();
            }
        });
        const yInput = (0, _input.input)({
            init: settings.y,
            type: "number",
            min: 0,
            max: height,
            css: {
                width: "100%"
            },
            callback: function(v) {
                settings.y = Number(v);
                updatePreview();
            }
        });
        const widthInput = (0, _input.input)({
            init: settings.width,
            type: "number",
            min: 1,
            max: Math.min(maxSize, width),
            css: {
                width: "100%"
            },
            callback: function(v) {
                settings.width = Number(v);
                updatePreview();
            }
        });
        const heightInput = (0, _input.input)({
            init: settings.height,
            type: "number",
            min: 1,
            max: Math.min(maxSize, height),
            css: {
                width: "100%"
            },
            callback: function(v) {
                settings.height = Number(v);
                updatePreview();
            }
        });
        const inputStyle = {
            marginLeft: "5px",
            flex: "1"
        };
        rootEl.append((0, _bb.BB).el({
            content: [
                (0, _bb.BB).el({
                    tagName: "label",
                    content: [
                        "X:",
                        xInput
                    ],
                    css: inputStyle
                }),
                (0, _bb.BB).el({
                    tagName: "label",
                    content: [
                        "Y:",
                        yInput
                    ],
                    css: inputStyle
                }),
                (0, _bb.BB).el({
                    tagName: "label",
                    content: [
                        (0, _language.LANG)("width") + ":",
                        widthInput
                    ],
                    css: inputStyle
                }),
                (0, _bb.BB).el({
                    tagName: "label",
                    content: [
                        (0, _language.LANG)("height") + ":",
                        heightInput
                    ],
                    css: inputStyle
                })
            ],
            css: {
                display: "flex",
                marginLeft: "-5px"
            }
        }));
        const blendSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("brush-blending"),
            width: 300,
            height: 30,
            min: 0,
            max: 1,
            value: settings.blend,
            eventResMs: (0, _filtersConsts.eventResMs),
            onChange: function(val) {
                settings.blend = val;
                updatePreview();
            },
            formatFunc: (val)=>{
                return (0, _bb.BB).round(val, 2);
            },
            manualInputRoundDigits: 2
        });
        (0, _bb.BB).css(blendSlider.getElement(), {
            margin: "10px 0"
        });
        rootEl.append(blendSlider.getElement());
        // ---- preview tabs ----
        let previewMode = 1; // 0 before, 1 after
        const beforeAfterTabs = new (0, _twoTabs.TwoTabs)({
            left: (0, _language.LANG)("compare-before"),
            right: (0, _language.LANG)("compare-after"),
            init: previewMode,
            onChange: (val)=>{
                previewMode = val;
                overlayCanvas.style.display = val === 0 ? "block" : "none";
                updatePreview(true);
            }
        });
        rootEl.append(beforeAfterTabs.getElement());
        // ---- previews ----
        const klCanvas = params.klCanvas;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        const fit = (0, _bb.BB).fitInto(context.canvas.width, context.canvas.height, isSmall ? 280 : 490, isSmall ? 200 : 240, 1);
        const w = parseInt("" + fit.width), h = parseInt("" + fit.height);
        const renderW = Math.min(w, context.canvas.width);
        const renderH = Math.min(h, context.canvas.height);
        // const renderFactor = renderW / context.canvas.width;
        const previewFactor = w / context.canvas.width;
        const previewWrapper = (0, _bb.BB).el({
            className: "kl-preview-wrapper",
            css: {
                width: (0, _previewSize.getPreviewWidth)(isSmall) + "px",
                height: (0, _previewSize.getPreviewHeight)(isSmall) + "px",
                marginTop: "0"
            }
        });
        const previewLayer = {
            image: (0, _bb.BB).canvas(renderW, renderH),
            isVisible: layers[selectedLayerIndex].isVisible,
            opacity: layers[selectedLayerIndex].opacity,
            mixModeStr: layers[selectedLayerIndex].mixModeStr
        };
        const previewLayerArr = layers.map((item, i)=>{
            if (i === selectedLayerIndex) return previewLayer;
            else return {
                image: item.context.canvas,
                isVisible: item.isVisible,
                opacity: item.opacity,
                mixModeStr: item.mixModeStr
            };
        });
        const klCanvasPreview = new (0, _canvasPreview.KlCanvasPreview)({
            width: Math.round(w),
            height: Math.round(h),
            layers: previewLayerArr
        });
        const overlayCanvas = (0, _bb.BB).canvas(w, h);
        (0, _bb.BB).css(overlayCanvas, {
            position: "absolute",
            left: "0",
            top: "0",
            mixBlendMode: "difference",
            imageRendering: "pixelated"
        });
        const previewInnerWrapper = (0, _bb.BB).el({
            className: "kl-preview-wrapper__canvas",
            css: {
                width: parseInt("" + w) + "px",
                height: parseInt("" + h) + "px"
            }
        });
        previewInnerWrapper.append(klCanvasPreview.getElement(), overlayCanvas);
        previewWrapper.append(previewInnerWrapper);
        rootEl.append(previewWrapper);
        // ---- preview input processing ----
        const inputs = {};
        function syncInputs() {
            xInput.value = "" + settings.x;
            yInput.value = "" + settings.y;
            widthInput.value = "" + settings.width;
            heightInput.value = "" + settings.height;
        }
        const keyListener = new (0, _bb.BB).KeyListener({});
        previewWrapper.oncontextmenu = function() {
            return false;
        };
        previewInnerWrapper.style.touchAction = "none";
        const pointerListener = new (0, _bb.BB).PointerListener({
            target: previewInnerWrapper,
            onPointer: (event)=>{
                if (previewMode === 0) {
                    if (event.type === "pointerdown") {
                        if (!inputs.state) {
                            inputs.oldSettings = (0, _bb.BB).copyObj(settings);
                            const x = event.relX / previewFactor;
                            const y = event.relY / previewFactor;
                            if ((0, _bb.BB).isInsideRect({
                                x,
                                y
                            }, {
                                x: settings.x,
                                y: settings.y,
                                width: settings.width,
                                height: settings.height
                            })) inputs.state = "move";
                            else inputs.state = "select";
                            inputs.start = {
                                x,
                                y
                            };
                        }
                    } else if (event.type === "pointermove") {
                        const x = event.relX / previewFactor;
                        const y = event.relY / previewFactor;
                        if (inputs.state === "select") {
                            inputs.end = {
                                x,
                                y
                            };
                            const x1 = Math.max(0, Math.min(inputs.start.x, inputs.end.x));
                            const y1 = Math.max(0, Math.min(inputs.start.y, inputs.end.y));
                            const x2 = Math.min(width, Math.max(inputs.start.x, inputs.end.x));
                            const y2 = Math.min(height, Math.max(inputs.start.y, inputs.end.y));
                            settings.x = Math.floor(x1);
                            settings.y = Math.floor(y1);
                            settings.width = Math.min(maxSize, Math.ceil(x2 - settings.x));
                            settings.height = Math.min(maxSize, Math.ceil(y2 - settings.y));
                            if (keyListener.isPressed("shift")) {
                                settings.width = Math.min(settings.width, settings.height);
                                settings.height = Math.min(settings.width, settings.height);
                            }
                            if (settings.width === 0 || settings.height === 0) settings = (0, _bb.BB).copyObj(inputs.oldSettings);
                            syncInputs();
                            updatePreview();
                        } else if (inputs.state === "move") {
                            const dX = Math.round(x - inputs.start.x);
                            const dY = Math.round(y - inputs.start.y);
                            settings.x = (0, _bb.BB).clamp(inputs.oldSettings.x + dX, 0, width - settings.width);
                            settings.y = (0, _bb.BB).clamp(inputs.oldSettings.y + dY, 0, height - settings.height);
                            syncInputs();
                            updatePreview();
                        }
                    } else if (event.type === "pointerup") {
                        if (inputs.state) inputs.state = null;
                    }
                } else {
                    if (event.type === "pointerdown") {
                        if (!inputs.state) {
                            inputs.state = "move";
                            inputs.oldSettings = (0, _bb.BB).copyObj(settings);
                            inputs.start = {
                                x: event.relX / previewFactor,
                                y: event.relY / previewFactor
                            };
                            inputs.end = null;
                        }
                    } else if (event.type === "pointermove") {
                        if (inputs.state) {
                            inputs.end = {
                                x: event.relX / previewFactor,
                                y: event.relY / previewFactor
                            };
                            settings.offsetX = Math.round(inputs.end.x - inputs.start.x) + inputs.oldSettings.offsetX;
                            settings.offsetY = Math.round(inputs.end.y - inputs.start.y) + inputs.oldSettings.offsetY;
                            updatePreview();
                        }
                    } else if (event.type === "pointerup") {
                        if (inputs.state) {
                            if (!inputs.end) {
                                settings.offsetX = 0;
                                settings.offsetY = 0;
                                updatePreview();
                            }
                            inputs.state = null;
                        }
                    }
                }
            }
        });
        // ---------- rendering ---------------------
        const fullSizeCanvas = (0, _bb.BB).canvas(width, height);
        const fullSizeCtx = (0, _bb.BB).ctx(fullSizeCanvas);
        function sharpStrokeRect(context, x, y, width, height) {
            const drawX = Math.round(x + 0.5) - 0.5;
            const drawY = Math.round(y + 0.5) - 0.5;
            const drawWidth = Math.round(x + width - drawX);
            const drawHeight = Math.round(y + height - drawY);
            context.strokeRect(drawX, drawY, drawWidth, drawHeight);
        }
        function updatePreview(doForce) {
            if (!doForce && lastDrawnSettings && JSON.stringify(lastDrawnSettings) === JSON.stringify(settings)) return;
            if (previewMode === 0) {
                fullSizeCtx.clearRect(0, 0, width, height);
                fullSizeCtx.drawImage(context.canvas, 0, 0);
                const previewCanvas = previewLayer.image;
                const previewCtx = (0, _bb.BB).ctx(previewCanvas);
                previewCtx.save();
                previewCtx.clearRect(0, 0, renderW, renderH);
                previewCtx.drawImage(fullSizeCanvas, 0, 0, renderW, renderH);
                previewCtx.restore();
                const pW = settings.width * previewFactor;
                const pH = settings.height * previewFactor;
                const overlayCtx = (0, _bb.BB).ctx(overlayCanvas);
                overlayCtx.save();
                overlayCtx.clearRect(0, 0, w, h);
                overlayCtx.strokeStyle = "#fff";
                sharpStrokeRect(overlayCtx, settings.x * previewFactor, settings.y * previewFactor, pW, pH);
                if (settings.blend > 0.05) {
                    overlayCtx.strokeStyle = "#f0f";
                    sharpStrokeRect(overlayCtx, settings.x * previewFactor - pW / 2 * settings.blend, settings.y * previewFactor - pH / 2 * settings.blend, pW * (1 + settings.blend), pH * (1 + settings.blend));
                }
                overlayCtx.restore();
            } else {
                fullSizeCtx.clearRect(0, 0, width, height);
                fullSizeCtx.drawImage(context.canvas, 0, 0);
                drawPattern(fullSizeCtx, settings);
                const previewCanvas = previewLayer.image;
                const previewCtx = (0, _bb.BB).ctx(previewCanvas);
                previewCtx.clearRect(0, 0, renderW, renderH);
                previewCtx.drawImage(fullSizeCanvas, 0, 0, renderW, renderH);
            }
            klCanvasPreview.render();
            lastDrawnSettings = (0, _bb.BB).copyObj(settings);
        }
        updatePreview();
        // ----- result -------------------
        const destroy = ()=>{
            blendSlider.destroy();
            keyListener.destroy();
            pointerListener.destroy();
            klCanvasPreview.destroy();
        };
        const result = {
            element: rootEl,
            destroy,
            getInput: ()=>{
                destroy();
                return (0, _bb.BB).copyObj(settings);
            }
        };
        if (!isSmall) result.width = (0, _previewSize.mediumPreview).width;
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        const ctx = params.context;
        const history = params.history;
        if (!klCanvas || !history) return false;
        history.pause(true);
        drawPattern(ctx, params.input);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "pattern"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/components/input":"je8IE","../ui/components/kl-slider":"4hcvv","../../language/language":"iiYGN","./filters-consts":"7Xzbl","../canvas-ui/canvas-preview":"gRZnS","../ui/components/two-tabs":"edCwK","../../bb/base/base":"k6nNY","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"dW7B1":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterDistort", ()=>filterDistort);
var _bb = require("../../bb/bb");
var _klSlider = require("../ui/components/kl-slider");
var _language = require("../../language/language");
var _filtersConsts = require("./filters-consts");
var _sharedFx = require("../../fx-canvas/shared-fx");
var _options = require("../ui/components/options");
var _checkbox = require("../ui/components/checkbox");
var _base = require("../../bb/base/base");
var _fxPreviewRenderer = require("../ui/project-viewport/fx-preview-renderer");
var _preview = require("../ui/project-viewport/preview");
var _emotionCssCjs = require("@emotion/css/dist/emotion-css.cjs");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterDistort = {
    getDialog (params) {
        const isSmall = (0, _testIsSmall.testIsSmall)();
        const rootEl = (0, _bb.BB).el();
        const context = params.context;
        let isSynced = true;
        const settings = {
            stepSize: 1,
            distortType: 0,
            scale: {
                x: 100,
                y: 100
            },
            strength: {
                x: 20,
                y: 20
            },
            phase: {
                x: 0,
                y: 0
            },
            offset: {
                x: 0,
                y: 0
            }
        };
        // let lastDrawnSettings = null;
        // ---- thumb -------
        const thumbImgArr = [];
        const thumbSize = 32;
        {
            const canvas = (0, _bb.BB).canvas(thumbSize, thumbSize);
            const ctx = (0, _bb.BB).ctx(canvas);
            ctx.beginPath();
            ctx.arc(thumbSize / 2, thumbSize / 2, thumbSize / 2.5, 0, Math.PI * 2);
            ctx.fill();
            let gradient = ctx.createLinearGradient(0, 0, thumbSize, thumbSize);
            gradient.addColorStop(0, "#00f");
            gradient.addColorStop(0.5, "#f00");
            gradient.addColorStop(1, "#fff");
            ctx.fillStyle = gradient;
            ctx.globalCompositeOperation = "source-atop";
            ctx.fillRect(0, 0, thumbSize, thumbSize);
            gradient = ctx.createLinearGradient(thumbSize, 0, 0, thumbSize);
            gradient.addColorStop(0, "#000");
            gradient.addColorStop(1, "#000");
            ctx.fillStyle = gradient;
            ctx.globalCompositeOperation = "destination-atop";
            ctx.fillRect(0, 0, thumbSize, thumbSize);
            const fxCanvas = (0, _base.throwIfNull)((0, _sharedFx.getSharedFx)());
            const texture = fxCanvas.texture(canvas);
            fxCanvas.draw(texture).update(); // update fxCanvas size
            const scaleFactor = 20;
            [
                0,
                1,
                2
            ].forEach((item)=>{
                const thumbImg = new Image();
                const settingsCopy = (0, _bb.BB).copyObj(settings);
                settingsCopy.distortType = item;
                settingsCopy.scale.x /= scaleFactor;
                settingsCopy.scale.y /= scaleFactor;
                settingsCopy.strength.x /= scaleFactor;
                settingsCopy.strength.y /= scaleFactor;
                fxCanvas.draw(texture).multiplyAlpha().distort(settingsCopy).unmultiplyAlpha().update();
                ctx.clearRect(0, 0, thumbSize, thumbSize);
                ctx.drawImage(fxCanvas, 0, 0);
                thumbImg.src = canvas.toDataURL("image/png");
                thumbImgArr.push(thumbImg);
            });
            texture.destroy();
        }
        // ---- controls ----
        const topRowEl = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: "flex",
                alignItems: "center"
            }
        });
        const typeOptions = new (0, _options.Options)({
            optionArr: thumbImgArr.map((img, index)=>{
                (0, _bb.BB).css(img, {
                    margin: "1px",
                    borderRadius: "3px",
                    transition: "all 0.1s ease-in-out"
                });
                return {
                    id: "" + index,
                    label: img
                };
            }),
            initId: "0",
            onChange: (id)=>{
                settings.distortType = Number(id);
                preview.render();
            }
        });
        function sync(from) {
            if (from === "x") {
                settings.scale.y = settings.scale.x;
                settings.strength.y = settings.strength.x;
                settings.phase.y = settings.phase.x;
                sliderArr[3].setValue(settings.scale.y);
                sliderArr[4].setValue(settings.strength.y);
                sliderArr[5].setValue(settings.phase.y);
            } else {
                settings.scale.x = settings.scale.y;
                settings.strength.x = settings.strength.y;
                settings.phase.x = settings.phase.y;
                sliderArr[0].setValue(settings.scale.x);
                sliderArr[1].setValue(settings.strength.x);
                sliderArr[2].setValue(settings.phase.x);
            }
            preview.render();
        }
        const syncToggle = new (0, _checkbox.Checkbox)({
            init: true,
            label: (0, _language.LANG)("filter-distort-sync-xy"),
            callback: (val)=>{
                isSynced = val;
                if (isSynced) sync("x");
            }
        });
        topRowEl.append(typeOptions.getElement(), (0, _bb.BB).el({
            css: {
                flexGrow: "1"
            }
        }), syncToggle.getElement());
        const xyRowEl = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: "flex",
                flexWrap: "wrap"
            }
        });
        const leftCol = (0, _bb.BB).el({
            parent: xyRowEl,
            css: {
                marginRight: "10px"
            }
        });
        const rightCol = (0, _bb.BB).el({
            parent: xyRowEl
        });
        const sliderWidth = isSmall ? 300 : 245;
        const sliderArr = [];
        [
            "x",
            "y"
        ].forEach((item, index)=>{
            const targetEl = index === 0 ? leftCol : rightCol;
            const scaleSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-noise-scale") + " " + item.toUpperCase(),
                width: sliderWidth,
                height: 30,
                min: 1,
                max: 1000,
                curve: "quadratic",
                value: settings.scale[item],
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: (val)=>{
                    settings.scale[item] = val;
                    if (isSynced) sync(item);
                    else preview.render();
                }
            });
            scaleSlider.getElement().style.marginTop = "20px";
            targetEl.append(scaleSlider.getElement());
            const strengthSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-unsharp-mask-strength") + " " + item.toUpperCase(),
                width: sliderWidth,
                height: 30,
                min: 0,
                max: 200,
                curve: "quadratic",
                value: settings.strength[item],
                eventResMs: (0, _filtersConsts.eventResMs),
                onChange: (val)=>{
                    settings.strength[item] = val;
                    if (isSynced) sync(item);
                    else preview.render();
                }
            });
            strengthSlider.getElement().style.marginTop = "10px";
            targetEl.append(strengthSlider.getElement());
            const phaseSlider = new (0, _klSlider.KlSlider)({
                label: (0, _language.LANG)("filter-distort-phase") + " " + item.toUpperCase(),
                width: sliderWidth,
                height: 30,
                min: 0,
                max: 1,
                value: settings.phase[item],
                manualInputRoundDigits: 2,
                eventResMs: (0, _filtersConsts.eventResMs),
                formatFunc: (val)=>(0, _bb.BB).round(val, 2),
                onChange: (val)=>{
                    settings.phase[item] = val;
                    if (isSynced) sync(item);
                    else preview.render();
                }
            });
            phaseSlider.getElement().style.marginTop = "10px";
            targetEl.append(phaseSlider.getElement());
            sliderArr.push(scaleSlider);
            sliderArr.push(strengthSlider);
            sliderArr.push(phaseSlider);
        });
        const stepSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("filter-distort-stepsize"),
            width: 300,
            height: 30,
            min: 1,
            max: 300,
            curve: "quadratic",
            value: settings.stepSize,
            eventResMs: (0, _filtersConsts.eventResMs),
            onChange: (val)=>{
                settings.stepSize = Math.round(val);
                preview.render();
            }
        });
        stepSlider.getElement().style.marginTop = "20px";
        stepSlider.getElement().style.marginBottom = "10px";
        rootEl.append(stepSlider.getElement());
        // ---- preview ----
        const klCanvas = params.klCanvas;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        const fxPreviewRenderer = new (0, _fxPreviewRenderer.FxPreviewRenderer)({
            original: context.canvas,
            onUpdate: (fxCanvas, transform)=>{
                const scaledSettings = (0, _bb.BB).copyObj(settings);
                scaledSettings.stepSize *= transform.scaleX;
                scaledSettings.strength.x *= transform.scaleX;
                scaledSettings.strength.y *= transform.scaleY;
                if (scaledSettings.distortType !== 2) {
                    scaledSettings.scale.x *= transform.scaleX;
                    scaledSettings.scale.y *= transform.scaleY;
                }
                scaledSettings.offset.x = -transform.x;
                scaledSettings.offset.y = -transform.y;
                return fxCanvas.multiplyAlpha().distort(scaledSettings).unmultiplyAlpha();
            }
        });
        const previewLayerArr = layers.map((item, i)=>{
            return {
                image: i === selectedLayerIndex ? fxPreviewRenderer.render : item.context.canvas,
                isVisible: item.isVisible,
                opacity: item.opacity,
                mixModeStr: item.mixModeStr,
                hasClipping: false
            };
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            }
        });
        preview.render();
        preview.getElement().classList.add((0, _emotionCssCjs.css)({
            marginLeft: "-20px",
            marginRight: "-20px"
        }));
        rootEl.append(preview.getElement());
        const destroy = ()=>{
            typeOptions.destroy();
            sliderArr.forEach((item)=>item.destroy());
            stepSlider.destroy();
            syncToggle.destroy();
            fxPreviewRenderer.destroy();
            preview.destroy();
        };
        // ----- result -------------------
        const result = {
            element: rootEl,
            destroy,
            getInput: ()=>{
                destroy();
                return (0, _bb.BB).copyObj(settings);
            }
        };
        if (!isSmall) result.width = (0, _previewSize.mediumPreview).width;
        return result;
    },
    apply (params) {
        const klCanvas = params.klCanvas;
        const context = params.context;
        const history = params.history;
        if (!klCanvas || !history) return false;
        history.pause(true);
        const fxCanvas = (0, _sharedFx.getSharedFx)();
        if (!fxCanvas) return false; // todo more specific error?
        const texture = fxCanvas.texture(context.canvas);
        fxCanvas.draw(texture).multiplyAlpha().distort(params.input).unmultiplyAlpha().update();
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(fxCanvas, 0, 0);
        texture.destroy();
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "distort"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../ui/components/kl-slider":"4hcvv","../../language/language":"iiYGN","./filters-consts":"7Xzbl","../../fx-canvas/shared-fx":"oGCP8","../ui/components/options":"hNLP6","../ui/components/checkbox":"8fYiz","../../bb/base/base":"k6nNY","../ui/project-viewport/fx-preview-renderer":"1TBrm","../ui/project-viewport/preview":"iWTRk","@emotion/css/dist/emotion-css.cjs":"djBls","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"ftQ30":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "filterVanishPoint", ()=>filterVanishPoint);
var _bb = require("../../bb/bb");
var _language = require("../../language/language");
var _input = require("../ui/components/input");
var _colorOptions = require("../ui/components/color-options");
var _drawVanishPoint = require("../image-operations/draw-vanish-point");
var _klSlider = require("../ui/components/kl-slider");
var _filtersConsts = require("./filters-consts");
var _base = require("../../bb/base/base");
var _preview = require("../ui/project-viewport/preview");
var _draggableInput = require("../ui/components/draggable-input");
var _testIsSmall = require("../ui/utils/test-is-small");
var _previewSize = require("../ui/utils/preview-size");
const filterVanishPoint = {
    getDialog (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        if (!context || !klCanvas) return false;
        const layers = klCanvas.getLayers();
        const selectedLayerIndex = (0, _base.throwIfNull)(klCanvas.getLayerIndex(context.canvas));
        const previewCanvas = (0, _bb.BB).canvas(context.canvas.width, context.canvas.height);
        const previewCtx = (0, _bb.BB).ctx(previewCanvas);
        const rootEl = (0, _bb.BB).el();
        const result = {
            element: rootEl
        };
        const isSmall = (0, _testIsSmall.testIsSmall)();
        if (!isSmall) result.width = (0, _previewSize.getPreviewWidth)(isSmall);
        const settingsObj = {
            x: context.canvas.width / 2,
            y: context.canvas.height / 2,
            lines: 8,
            thickness: 2,
            color: {
                r: 0,
                g: 0,
                b: 0
            },
            opacity: 1
        };
        const linesSlider = new (0, _klSlider.KlSlider)({
            label: (0, _language.LANG)("filter-vanish-point-lines"),
            width: 300,
            height: 30,
            min: 2,
            max: 20,
            value: settingsObj.lines,
            curve: "quadratic",
            eventResMs: (0, _filtersConsts.eventResMs),
            onChange: function(val) {
                settingsObj.lines = Math.round(val);
                update();
            }
        });
        linesSlider.getElement().style.marginBottom = "10px";
        rootEl.append(linesSlider.getElement());
        const line1 = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: "flex",
                alignItems: "center"
            }
        });
        const line2 = (0, _bb.BB).el({
            parent: rootEl,
            css: {
                display: "flex",
                alignItems: "center",
                marginTop: "10px",
                marginBottom: "10px"
            }
        });
        const xInput = (0, _input.input)({
            init: settingsObj.x,
            type: "number",
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.x = parseFloat(v);
                dragInput.setValue({
                    x: settingsObj.x,
                    y: settingsObj.y
                });
                update();
            }
        });
        const yInput = (0, _input.input)({
            init: settingsObj.y,
            type: "number",
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.y = parseFloat(v);
                dragInput.setValue({
                    x: settingsObj.x,
                    y: settingsObj.y
                });
                update();
            }
        });
        const thicknessInput = (0, _input.input)({
            init: 2,
            type: "number",
            min: 1,
            css: {
                width: "75px",
                marginRight: "20px"
            },
            callback: function(v) {
                settingsObj.thickness = parseFloat(v);
                update();
            }
        });
        let selectedRgbaObj = {
            r: 0,
            g: 0,
            b: 0,
            a: 1
        };
        const colorOptionsArr = [
            {
                r: 0,
                g: 0,
                b: 0,
                a: 1
            },
            {
                r: 255,
                g: 255,
                b: 255,
                a: 1
            }
        ];
        colorOptionsArr.push({
            r: params.currentColorRgb.r,
            g: params.currentColorRgb.g,
            b: params.currentColorRgb.b,
            a: 1
        });
        colorOptionsArr.push({
            r: params.secondaryColorRgb.r,
            g: params.secondaryColorRgb.g,
            b: params.secondaryColorRgb.b,
            a: 1
        });
        settingsObj.color = (0, _bb.BB).copyObj(selectedRgbaObj);
        const colorOptions = new (0, _colorOptions.ColorOptions)({
            label: (0, _language.LANG)("shape-stroke"),
            colorArr: colorOptionsArr,
            onChange: function(rgbaObj) {
                selectedRgbaObj = rgbaObj;
                settingsObj.color = (0, _bb.BB).copyObj(selectedRgbaObj);
                update();
            }
        });
        const labelStyle = {
            display: "inline-block",
            marginRight: "5px"
        };
        line1.append((0, _bb.BB).el({
            content: "X:",
            css: labelStyle
        }), xInput, (0, _bb.BB).el({
            content: "Y:",
            css: labelStyle
        }), yInput);
        line2.append((0, _bb.BB).el({
            content: (0, _language.LANG)("shape-line-width") + ":",
            css: labelStyle
        }), thicknessInput, (0, _bb.BB).el({
            css: {
                flexGrow: "1"
            }
        }), colorOptions.getElement());
        // ---- preview input processing ----
        function syncInputs() {
            xInput.value = "" + settingsObj.x;
            yInput.value = "" + settingsObj.y;
        }
        function update() {
            const ctx = previewCtx;
            const w = previewCanvas.width;
            const h = previewCanvas.height;
            ctx.save();
            ctx.clearRect(0, 0, w, h);
            ctx.drawImage(context.canvas, 0, 0, w, h);
            (0, _drawVanishPoint.drawVanishPoint)(ctx, settingsObj.x, settingsObj.y, settingsObj.lines, Math.max(settingsObj.thickness, 1), settingsObj.color, settingsObj.opacity);
            ctx.restore();
            preview.render();
        }
        const onRender = ()=>{
            dragInput.setTransform(preview.getTransform());
            return previewCanvas;
        };
        const previewLayerArr = [];
        for(let i = 0; i < layers.length; i++)previewLayerArr.push({
            image: i === selectedLayerIndex ? onRender : layers[i].context.canvas,
            isVisible: layers[i].isVisible,
            opacity: layers[i].opacity,
            mixModeStr: layers[i].mixModeStr,
            hasClipping: false
        });
        const preview = new (0, _preview.Preview)({
            width: (0, _previewSize.getPreviewWidth)(isSmall),
            height: (0, _previewSize.getPreviewHeight)(isSmall),
            project: {
                width: context.canvas.width,
                height: context.canvas.height,
                layers: previewLayerArr
            }
        });
        (0, _bb.BB).css(preview.getElement(), {
            marginLeft: "-20px",
            marginRight: "-20px",
            overflow: "hidden"
        });
        const dragInput = new (0, _draggableInput.DraggableInput)({
            value: {
                x: settingsObj.x,
                y: settingsObj.y
            },
            onChange: (val)=>{
                settingsObj.x = Math.round(val.x);
                settingsObj.y = Math.round(val.y);
                syncInputs();
                update();
            }
        });
        update();
        preview.getElement().append(dragInput.getElement());
        rootEl.append(preview.getElement());
        result.destroy = ()=>{
            linesSlider.destroy();
            colorOptions.destroy();
            preview.destroy();
        };
        result.getInput = function() {
            result.destroy();
            return (0, _bb.BB).copyObj(settingsObj);
        };
        return result;
    },
    apply (params) {
        const context = params.context;
        const klCanvas = params.klCanvas;
        const history = params.history;
        if (!context || !klCanvas || !history) return false;
        history.pause(true);
        (0, _drawVanishPoint.drawVanishPoint)(context, params.input.x, params.input.y, params.input.lines, params.input.thickness, params.input.color, params.input.opacity);
        history.pause(false);
        history.push({
            tool: [
                "filter",
                "vanishPoint"
            ],
            action: "apply",
            params: [
                {
                    input: params.input
                }
            ]
        });
        return true;
    }
};

},{"../../bb/bb":"dcQKo","../../language/language":"iiYGN","../ui/components/input":"je8IE","../ui/components/color-options":"iXzf7","../image-operations/draw-vanish-point":"gsRRw","../ui/components/kl-slider":"4hcvv","./filters-consts":"7Xzbl","../../bb/base/base":"k6nNY","../ui/project-viewport/preview":"iWTRk","../ui/components/draggable-input":"7Vl8c","../ui/utils/test-is-small":"giqoI","../ui/utils/preview-size":"llYOD","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gsRRw":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "drawVanishPoint", ()=>drawVanishPoint);
var _shapeTool = require("./shape-tool");
var _bb = require("../../bb/bb");
function drawVanishPoint(ctx, x, y, lines, thickness, color, opacity) {
    ctx.save();
    const degIncrement = 180 / lines;
    for(let deg = 0; deg < 180; deg += degIncrement){
        const p2 = (0, _bb.BB).rotateAround({
            x,
            y
        }, {
            x: x + 9999,
            y
        }, deg);
        (0, _shapeTool.drawShape)(ctx, {
            type: "line",
            x1: x,
            y1: y,
            x2: p2.x,
            y2: p2.y,
            //angleRad: 0,
            isOutwards: true,
            opacity,
            //isEraser: false,
            strokeRgb: color,
            lineWidth: thickness
        });
    }
    ctx.restore();
}

},{"./shape-tool":"90Wty","../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gh8aB":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "klCanvasToPsdBlob", ()=>klCanvasToPsdBlob);
var _kl = require("../kl");
var _loadAgPsd = require("./load-ag-psd");
async function klCanvasToPsdBlob(klCanvas) {
    const layerArr = klCanvas.getLayersFast();
    const psdConfig = {
        width: klCanvas.getWidth(),
        height: klCanvas.getHeight(),
        //canvas: klCanvas.getCompleteCanvas(1), // preview, can be skipped
        children: layerArr.map((item)=>{
            // todo - can be optimized if layer mostly empty
            return {
                name: item.name,
                hidden: !item.isVisible,
                opacity: item.opacity,
                canvas: item.canvas,
                blendMode: (0, _kl.KL).PSD.blendKlToPsd(item.mixModeStr),
                left: 0,
                top: 0
            };
        })
    };
    const agPsd = await (0, _loadAgPsd.loadAgPsd)();
    const buffer = agPsd.writePsdBuffer(psdConfig);
    return new Blob([
        buffer
    ], {
        type: "application/octet-stream"
    });
}

},{"../kl":"8nmWp","./load-ag-psd":"gJgsA","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"573tG":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * Line smoothing. EventChain element. Smoothing via blending new position with old position.
 * for onDraw events from KlCanvasWorkspace.
 *
 * in some draw event
 * out some draw event
 *
 * type: 'line' Events are just passed through.
 */ parcelHelpers.export(exports, "LineSmoothing", ()=>LineSmoothing);
var _bb = require("../../bb/bb");
class LineSmoothing {
    // --- public ---
    constructor(p){
        this.smoothing = (0, _bb.BB).clamp(p.smoothing, 0, 1);
    }
    chainIn(event) {
        event = (0, _bb.BB).copyObj(event);
        this.timeout && clearTimeout(this.timeout);
        this.interval && clearInterval(this.interval);
        if (event.type === "down") this.lastMixedInput = {
            x: event.x,
            y: event.y,
            pressure: event.pressure
        };
        if (event.type === "move") {
            const inputX = event.x;
            const inputY = event.y;
            const inputPressure = event.pressure;
            event.x = (0, _bb.BB).mix(event.x, this.lastMixedInput.x, this.smoothing);
            event.y = (0, _bb.BB).mix(event.y, this.lastMixedInput.y, this.smoothing);
            event.pressure = (0, _bb.BB).mix(event.pressure, this.lastMixedInput.pressure, this.smoothing);
            this.lastMixedInput = {
                x: event.x,
                y: event.y,
                pressure: event.pressure
            };
            if (this.smoothing > 0) this.timeout = setTimeout(()=>{
                this.interval = setInterval(()=>{
                    event = JSON.parse(JSON.stringify(event));
                    event.x = (0, _bb.BB).mix(inputX, this.lastMixedInput.x, this.smoothing);
                    event.y = (0, _bb.BB).mix(inputY, this.lastMixedInput.y, this.smoothing);
                    event.pressure = (0, _bb.BB).mix(inputPressure, this.lastMixedInput.pressure, this.smoothing);
                    this.lastMixedInput = {
                        x: event.x,
                        y: event.y,
                        pressure: event.pressure
                    };
                    this.chainOut && this.chainOut(event);
                }, 35);
            }, 80);
        }
        return event;
    }
    setChainOut(func) {
        this.chainOut = func;
    }
    setSmoothing(s) {
        this.smoothing = (0, _bb.BB).clamp(s, 0, 1);
    }
}

},{"../../bb/bb":"dcQKo","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"gOeVc":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
/**
 * cleans up DrawEvents. More trustworthy events. EventChain element
 *
 * in some draw event?
 * out some draw event?
 *
 * that events can only go line this: down -> n x move -> up
 * so, sanitizes this: down, down, down. becomes only one down. the other downs are ignored/swallowed
 */ parcelHelpers.export(exports, "LineSanitizer", ()=>LineSanitizer);
class LineSanitizer {
    // --- public ---
    chainIn(event) {
        if (event.type === "down") {
            if (this.isDrawing) //console.log('line sanitizer - down, but already drawing');
            this.chainOut && this.chainOut({
                type: "up",
                scale: event.scale,
                shiftIsPressed: event.shiftIsPressed,
                isCoalesced: false
            });
            else this.isDrawing = true;
        }
        if (!this.isDrawing && (event.type === "move" || event.type === "up")) //console.log('line sanitizer - ' + event.type + ' but not drawing');
        return null;
        if (event.type === "up" && this.isDrawing) this.isDrawing = false;
        return event;
    }
    setChainOut(func) {
        this.chainOut = func;
    }
    getIsDrawing() {
        return this.isDrawing;
    }
    constructor(){
        this.isDrawing = false;
    }
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"4b82o":[function(require,module,exports) {
/**
 * from stabilizer dropdown value to line-smoothing value
 * @param s
 */ var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "translateSmoothing", ()=>translateSmoothing);
function translateSmoothing(s) {
    if (s == 1) return 0.5;
    if (s == 2) return 0.84;
    if (s == 3) return 0.965;
    if (s == 4) return 0.9825;
    if (s == 5) return 0.99125;
    return s;
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"1HaN7":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
// todo later:
// onImage: (project: IKlProject) => void
// onLayer: (index: number, canvas: HMTLCanvasElement,layerName: string) => void
parcelHelpers.export(exports, "ImportHandler", ()=>ImportHandler);
var _kl = require("../klecks/kl");
var _language = require("../language/language");
var _bb = require("../bb/bb");
var _klHistory = require("../klecks/history/kl-history");
var _base = require("../bb/base/base");
class ImportHandler {
    /**
     *
     * @param importedImage - convertedPsd | {type: 'image', width: number, height: number, canvas: image | canvas}
     * @param filename - string e.g. 'drawing.psd'
     * @param optionStr? - 'default' | 'layer' | 'image'
     */ importFinishedLoading(importedImage, filename, optionStr) {
        if (!importedImage || isNaN(importedImage.width) || isNaN(importedImage.height) || importedImage.width <= 0 || importedImage.height <= 0) {
            (0, _kl.KL).popup({
                target: this.klRootEl,
                type: "error",
                message: (0, _language.LANG)("import-broken-file"),
                buttons: [
                    "Ok"
                ]
            });
            return;
        }
        const getResizedDimensions = (width, height)=>{
            let w = parseInt("" + width);
            let h = parseInt("" + height);
            if (w > this.klMaxCanvasSize) {
                h = this.klMaxCanvasSize / w * h;
                w = this.klMaxCanvasSize;
            }
            if (h > this.klMaxCanvasSize) {
                w = this.klMaxCanvasSize / h * w;
                h = this.klMaxCanvasSize;
            }
            w = parseInt("" + w);
            h = parseInt("" + h);
            return {
                width: w,
                height: h
            };
        };
        const importAsImage = (canvas)=>{
            const resizedDimensions = getResizedDimensions(canvas.width, canvas.height);
            //resize first
            const tempCanvas = (0, _bb.BB).canvas(canvas.width, canvas.height);
            const tempCanvasCtx = (0, _bb.BB).ctx(tempCanvas);
            tempCanvasCtx.drawImage(canvas, 0, 0);
            (0, _bb.BB).resizeCanvas(tempCanvas, resizedDimensions.width, resizedDimensions.height);
            this.klCanvas.reset({
                width: resizedDimensions.width,
                height: resizedDimensions.height,
                image: tempCanvas,
                layerName: filename
            });
            this.layerManager.update(0);
            this.setCurrentLayer(this.klCanvas.getLayer(0));
            this.klCanvasWorkspace.resetOrFitView();
            this.handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
        };
        /**
         *
         * @param convertedPsdObj - if flattened then without layers
         * @param cropObj? - {x: number, y: number, width: number, height: number}
         */ const importAsImagePsd = (convertedPsdObj, cropObj)=>{
            // crop
            const crop = (targetCanvas, cropCanvas, cropObj)=>{
                // eslint-disable-next-line no-self-assign
                cropCanvas.width = cropCanvas.width;
                (0, _bb.BB).ctx(cropCanvas).drawImage(targetCanvas, -cropObj.x, -cropObj.y);
                targetCanvas.width = cropObj.width;
                targetCanvas.height = cropObj.height;
                (0, _bb.BB).ctx(targetCanvas).drawImage(cropCanvas, 0, 0);
            };
            if (cropObj && (cropObj.width !== convertedPsdObj.width || cropObj.height !== convertedPsdObj.height)) {
                const cropCanvas = (0, _bb.BB).canvas(cropObj.width, cropObj.height);
                convertedPsdObj.width = cropObj.width;
                convertedPsdObj.height = cropObj.height;
                if (!convertedPsdObj.layers) crop(convertedPsdObj.canvas, cropCanvas, cropObj);
                if (convertedPsdObj.layers) for(let i = 0; i < convertedPsdObj.layers.length; i++){
                    const item = convertedPsdObj.layers[i];
                    crop(item.image, cropCanvas, cropObj);
                }
            }
            // resize
            const resizedDimensions = getResizedDimensions(convertedPsdObj.width, convertedPsdObj.height);
            convertedPsdObj.width = resizedDimensions.width;
            convertedPsdObj.height = resizedDimensions.height;
            if (!convertedPsdObj.layers) (0, _bb.BB).resizeCanvas(convertedPsdObj.canvas, convertedPsdObj.width, convertedPsdObj.height);
            if (convertedPsdObj.layers) for(let i = 0; i < convertedPsdObj.layers.length; i++){
                const item = convertedPsdObj.layers[i];
                (0, _bb.BB).resizeCanvas(item.image, convertedPsdObj.width, convertedPsdObj.height);
            }
            let layerIndex;
            if (convertedPsdObj.layers) layerIndex = this.klCanvas.reset({
                width: convertedPsdObj.width,
                height: convertedPsdObj.height,
                layers: convertedPsdObj.layers
            });
            else layerIndex = this.klCanvas.reset({
                width: convertedPsdObj.width,
                height: convertedPsdObj.height,
                image: convertedPsdObj.canvas
            });
            this.layerManager.update(layerIndex);
            this.setCurrentLayer((0, _base.throwIfNull)(this.klCanvas.getLayer(layerIndex)));
            this.klCanvasWorkspace.resetOrFitView();
            this.handUi.update(this.klCanvasWorkspace.getScale(), this.klCanvasWorkspace.getAngleDeg());
        };
        const importAsLayer = (canvas)=>{
            (0, _kl.KL).showImportAsLayerDialog({
                target: this.klRootEl,
                klCanvas: this.klCanvas,
                importImage: canvas,
                callback: (transformObj, isPixelated)=>{
                    if (!transformObj) return;
                    (0, _klHistory.klHistory).pause(true);
                    this.klCanvas.addLayer();
                    const layers = this.klCanvas.getLayers();
                    const activeLayerIndex = layers.length - 1;
                    if (filename) this.klCanvas.renameLayer(activeLayerIndex, filename);
                    const activeLayerContext = (0, _base.throwIfNull)(this.klCanvas.getLayerContext(activeLayerIndex));
                    (0, _bb.BB).drawTransformedImageWithBounds(activeLayerContext, canvas, transformObj, undefined, isPixelated);
                    this.setCurrentLayer((0, _base.throwIfNull)(this.klCanvas.getLayer(activeLayerIndex)));
                    this.layerManager.update(activeLayerIndex);
                    (0, _klHistory.klHistory).pause(false);
                    (0, _klHistory.klHistory).push({
                        tool: [
                            "misc"
                        ],
                        action: "importImage",
                        params: [
                            (0, _bb.BB).copyCanvas(activeLayerContext.canvas),
                            filename
                        ]
                    });
                }
            });
        };
        if (optionStr === "default" || !optionStr) (0, _kl.KL).showImportImageDialog({
            image: importedImage,
            target: this.klRootEl,
            maxSize: this.klMaxCanvasSize,
            callback: (res)=>{
                if (res.type === "as-image") importAsImage(res.image);
                else if (res.type === "as-image-psd") importAsImagePsd(res.image, res.cropObj);
                else if (res.type === "as-layer") importAsLayer(res.image);
                else res.type;
            }
        });
        if (optionStr === "layer") importAsLayer(importedImage.canvas);
        if (optionStr === "image") {
            if (importedImage.type === "psd") importAsImagePsd(importedImage);
            else importAsImage(importedImage.canvas);
        }
    }
    // ---- public ----
    constructor(input, callback){
        this.klRootEl = input.klRootEl;
        this.klMaxCanvasSize = input.klMaxCanvasSize;
        this.layerManager = input.layerManager;
        this.setCurrentLayer = input.setCurrentLayer;
        this.klCanvas = input.klCanvas;
        this.klCanvasWorkspace = input.klCanvasWorkspace;
        this.handUi = input.handUi;
        this.onColor = callback.onColor;
    }
    // ---- interface ----
    onPaste(e) {
        if ((0, _kl.KL).dialogCounter.get() > 0) return;
        const retrieveImageFromClipboardAsBlob = (items, callback)=>{
            if (!items) return;
            for(let i = 0; i < items.length; i++){
                if (items[i].type.indexOf("image") == -1) continue;
                const file = items[i].getAsFile();
                file && callback(file);
            }
        };
        e.stopPropagation();
        e.preventDefault();
        if (!e.clipboardData) return;
        if (e.clipboardData.files[0]) retrieveImageFromClipboardAsBlob(e.clipboardData.items, (imageBlob)=>{
            // If there's an image, display it in the canvas
            const img = new Image();
            img.onload = ()=>{
                URL.revokeObjectURL(img.src);
                this.importFinishedLoading({
                    type: "image",
                    width: img.width,
                    height: img.height,
                    canvas: img
                }, undefined, "default");
            };
            const URLObj = window.URL || window.webkitURL;
            img.src = URLObj.createObjectURL(imageBlob);
        });
        else if (e.clipboardData.items[0]) e.clipboardData.items[0].getAsString((pasteStr)=>{
            pasteStr = pasteStr.trim();
            if (pasteStr.match(/^https?/)) {
                // url
                const img = new Image();
                img.onload = ()=>{
                    this.importFinishedLoading({
                        type: "image",
                        width: img.width,
                        height: img.height,
                        canvas: img
                    }, undefined, "default");
                };
                img.onerror = (e)=>{
                    console.log("error loading", e);
                };
                img.crossOrigin = "Anonymous";
                img.src = pasteStr;
            } else if (pasteStr.match(/^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/)) {
                // url
                const rgbObj = (0, _bb.BB).ColorConverter.hexToRGB(pasteStr.replace("#", ""));
                rgbObj && this.onColor(rgbObj);
            }
        });
    }
    handleFileSelect(files, optionStr) {
        const showWarningPsdFlattened = ()=>{
            (0, _kl.KL).popup({
                target: this.klRootEl,
                type: "warning",
                message: (0, _language.LANG)("import-psd-unsupported") + "<br /><br />",
                buttons: [
                    "Ok"
                ]
            });
        };
        let hasUnsupportedFile = false;
        // eslint-disable-next-line no-cond-assign
        for(let i = 0, file; file = files[i]; i++){
            const nameSplit = file.name.split(".");
            const extension = nameSplit[nameSplit.length - 1].toLowerCase();
            if (extension === "psd") ((f)=>{
                const loaderSizeBytes = 26214400; // 25mb
                const maxSizeBytes = 1073741824; // 1gb
                const maxResolution = 4096;
                if (f.size >= maxSizeBytes) {
                    (0, _kl.KL).popup({
                        target: this.klRootEl,
                        type: "error",
                        message: "File too big. Unable to import.<br /><br />",
                        buttons: [
                            "Ok"
                        ]
                    });
                    return;
                }
                const doShowLoader = files.length === 1 && f.size >= loaderSizeBytes;
                let loaderIsOpen = true;
                let closeLoader;
                if (doShowLoader) (0, _kl.KL).popup({
                    target: this.klRootEl,
                    message: (0, _language.LANG)("import-opening"),
                    callback: (result)=>{
                        loaderIsOpen = false;
                        closeLoader = null;
                    },
                    closeFunc: (f)=>{
                        closeLoader = f;
                    }
                });
                const reader = new FileReader();
                reader.onload = (readerResult)=>{
                    const target = (0, _base.throwIfNull)(readerResult.target);
                    (0, _kl.KL).loadAgPsd().then((agPsdLazy)=>{
                        if (doShowLoader && !loaderIsOpen) return;
                        try {
                            let psd;
                            // first pass, only read metadata
                            psd = agPsdLazy.readPsd(target.result, {
                                skipLayerImageData: true,
                                skipThumbnail: true,
                                skipCompositeImageData: true
                            });
                            if (psd.width > maxResolution || psd.height > maxResolution) {
                                if (closeLoader) closeLoader();
                                (0, _kl.KL).popup({
                                    target: this.klRootEl,
                                    type: "error",
                                    message: (0, _language.LANG)("import-psd-too-large").replace(/{x}/g, "" + maxResolution) + "<br /><br />" + (0, _language.LANG)("import-psd-size") + ": " + psd.width + " x " + psd.height + " pixels" + "<br /><br />",
                                    buttons: [
                                        "Ok"
                                    ]
                                });
                                return;
                            }
                            // second pass, now load actual data.
                            psd = null;
                            try {
                                psd = agPsdLazy.readPsd(target.result);
                            } catch (e) {
                            //console.log('failed regular psd import', e);
                            }
                            if (psd) {
                                //console.log('psd', psd);
                                const convertedPsd = (0, _kl.KL).PSD.readPsd(psd);
                                //console.log('converted', convertedPsd);
                                if (optionStr === "image" && convertedPsd.error) showWarningPsdFlattened();
                                if (closeLoader) closeLoader();
                                this.importFinishedLoading(convertedPsd, f.name, optionStr);
                            } else {
                                psd = agPsdLazy.readPsd(target.result, {
                                    skipLayerImageData: true,
                                    skipThumbnail: true
                                });
                                if (optionStr === "image") showWarningPsdFlattened();
                                if (closeLoader) closeLoader();
                                this.importFinishedLoading({
                                    type: "psd",
                                    width: psd.width,
                                    height: psd.height,
                                    canvas: (0, _base.throwIfUndefined)(psd.canvas),
                                    error: true
                                }, f.name, optionStr);
                            }
                        } catch (e) {
                            closeLoader && closeLoader();
                            (0, _kl.KL).popup({
                                target: this.klRootEl,
                                type: "error",
                                message: "Failed to load PSD.<br /><br />",
                                buttons: [
                                    "Ok"
                                ]
                            });
                            console.log(e);
                            setTimeout(()=>{
                                throw new Error("psd load error");
                            });
                        }
                    }).catch((e)=>{
                        closeLoader && closeLoader();
                        alert("Error: failed to load PSD library");
                    });
                };
                reader.readAsArrayBuffer(f);
            })(file);
            else if (file.type.match("image.*")) ((f)=>{
                window.URL = window.URL || window.webkitURL;
                const url = window.URL.createObjectURL(f);
                const im = new Image();
                im.src = url;
                (0, _bb.BB).loadImage(im, ()=>{
                    this.importFinishedLoading({
                        type: "image",
                        width: im.width,
                        height: im.height,
                        canvas: im
                    }, f.name, optionStr);
                });
            })(file);
            else hasUnsupportedFile = true;
        }
        if (hasUnsupportedFile) (0, _kl.KL).popup({
            target: this.klRootEl,
            message: (0, _language.LANG)("import-unsupported-file"),
            type: "error",
            buttons: [
                "OK"
            ]
        });
    }
}

},{"../klecks/kl":"8nmWp","../language/language":"iiYGN","../bb/bb":"dcQKo","../klecks/history/kl-history":"klzEn","../bb/base/base":"k6nNY","@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}],"cXRWb":[function(require,module,exports) {
module.exports = require("a6dc90350ff80481").getBundleURL("d3gnI") + "tab-settings.9f59f00e.svg" + "?" + Date.now();

},{"a6dc90350ff80481":"lgJ39"}],"87cTe":[function(require,module,exports) {
module.exports = require("d68996685cf63c42").getBundleURL("d3gnI") + "tab-layers.c98c4feb.svg" + "?" + Date.now();

},{"d68996685cf63c42":"lgJ39"}],"S0mIC":[function(require,module,exports) {
var parcelHelpers = require("@parcel/transformer-js/src/esmodule-helpers.js");
parcelHelpers.defineInteropFlag(exports);
parcelHelpers.export(exports, "createConsoleApi", ()=>createConsoleApi);
function createConsoleApi(p) {
    const output = [
        "Draw via the console! Learn more: %cKL.help()",
        "background: #000; color: #0f0;"
    ];
    "info" in console ? console.info(...output) : console.log(...output);
    return Object.freeze({
        draw: (path)=>{
            p.onDraw(path);
        },
        help: ()=>{
            console.log(`KL.draw({x: number; y: number}[]) // draw a line
KL.help() // print help
`);
        }
    });
}

},{"@parcel/transformer-js/src/esmodule-helpers.js":"gkKU3"}]},["4yoxy","c1sIO"], "c1sIO", "parcelRequire94c2")

//# sourceMappingURL=index.9aa0ef6a.js.map
